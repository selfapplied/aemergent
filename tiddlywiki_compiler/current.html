<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Compiled Wiki</title>
<script>
var $tw = {
    preloadTiddlers: [
  {
    "title": "no_compression_wiki.html",
    "text": "PCFET0NUWVBFIGh0bWw+CjxodG1sPgo8aGVhZD4KPG1ldGEgY2hhcnNldD0idXRmLTgiPgo8dGl0bGU+Q29tcGlsZWQgV2lraTwvdGl0bGU+CjxzY3JpcHQ+CnZhciAkdHcgPSB7CiAgICBwcmVsb2FkVGlkZGxlcnM6IFsKICB7CiAgICAidGl0bGUiOiAiYWxnb3JpdGhtcyIsCiAgICAidGV4dCI6ICIjIFNhbXBsZSBBbGdvcml0aG1cbmRlZiBmYWN0b3JpYWwobik6XG4gICAgXCJcIlwiXG4gICAgQ29tcHV0ZSBmYWN0b3JpYWwgdXNpbmcgcmVjdXJzaXZlIGFsZ29yaXRobVxuICAgIFRpbWUgY29tcGxleGl0eTogTyhuKVxuICAgIFNwYWNlIGNvbXBsZXhpdHk6IE8obikgZHVlIHRvIHJlY3Vyc2lvblxuICAgIFwiXCJcIlxuICAgIGlmIG4gPD0gMTpcbiAgICAgICAgcmV0dXJuIDFcbiAgICByZXR1cm4gbiAqIGZhY3RvcmlhbChuIC0gMSlcblxuZGVmIGZpYm9uYWNjaShuKTpcbiAgICBcIlwiXCJcbiAgICBDb21wdXRlIEZpYm9uYWNjaSBudW1iZXJcbiAgICBEZW1vbnN0cmF0ZXMgZXhwb25lbnRpYWwgZ3Jvd3RoIHBhdHRlcm5cbiAgICBcIlwiXCJcbiAgICBpZiBuIDw9IDE6XG4gICAgICAgIHJldHVybiBuXG4gICAgcmV0dXJuIGZpYm9uYWNjaShuLTEpICsgZmlib25hY2NpKG4tMilcblxuIyBFeGFtcGxlIHVzYWdlXG5wcmludChmXCI1ISA9IHtmYWN0b3JpYWwoNSl9XCIpXG5wcmludChmXCJGKDEwKSA9IHtmaWJvbmFjY2koMTApfVwiKVxuIiwKICAgICJ0YWdzIjogImRlbW8gY29kZSB0ZXh0IHB5IiwKICAgICJ0eXBlIjogInRleHQvcGxhaW4iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODIwMDA5ODQiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyMDAwOTg0IgogIH0sCiAgewogICAgInRpdGxlIjogImludHJvZHVjdGlvbiIsCiAgICAidGV4dCI6ICIjIFdlbGNvbWUgdG8gdGhlIE1hdGhlbWF0aWNhbCBXaWtpXG5cblRoaXMgd2lraSBkZW1vbnN0cmF0ZXMgdGhlIFRpZGRseVdpa2kgY29tcGlsZXIncyBhYmlsaXR5IHRvIHN0cnVjdHVyZSBhbmQgb3JnYW5pemUgbWF0aGVtYXRpY2FsIGNvbnRlbnQuXG5cbiMjIEZlYXR1cmVzXG5cbi0gKipBdXRvbWF0aWMgdGFnZ2luZyoqIGJhc2VkIG9uIGNvbnRlbnQgcGF0dGVybnNcbi0gKipEaXN0YW5jZS1tZXRyaWMgY29tcHJlc3Npb24qKiB1c2luZyBibG9ja3ByaW1lcyBjb25jZXB0cyAgXG4tICoqU3RydWN0dXJlZCB0aWRkbGVycyoqIHdpdGggc3VtbWFyaWVzIGFuZCBrZXkgY29uY2VwdHNcbi0gKipJbnRlcmFjdGl2ZSBmaWx0ZXJpbmcqKiBieSB0YWdzIGFuZCBzZWFyY2hcblxuIyMgU2FtcGxlIENvbnRlbnRcblxuVGhlIGJsb2NrcHJpbWVzLm1kIGZpbGUgaGFzIGJlZW4gYXV0b21hdGljYWxseSBicm9rZW4gZG93biBpbnRvIG11bHRpcGxlIHRpZGRsZXJzLCBlYWNoIHdpdGg6XG4tIFN1bW1hcnkgc2VjdGlvbnNcbi0gS2V5IGNvbmNlcHQgZXh0cmFjdGlvblxuLSBBdXRvbWF0aWMgdGFnZ2luZyAocHJvb2YsIGRlbW8sIHF1ZXN0aW9uLCBldGMuKVxuLSBGb2xsb3ctdXAgcXVlc3Rpb24gZGV0ZWN0aW9uXG5cbioqRXhhbXBsZSoqOiBNYXRoZW1hdGljYWwgcHJvb2ZzIGFyZSBhdXRvbWF0aWNhbGx5IHRhZ2dlZCBhcyBcInByb29mXCIgYW5kIGZvcm1hdHRlZCB3aXRoIHNwZWNpYWwgc3R5bGluZy5cblxuV2hhdCBwYXR0ZXJucyB3aWxsIHlvdSBkaXNjb3ZlciBpbiB5b3VyIG93biBjb250ZW50P1xuIiwKICAgICJ0YWdzIjogInByb29mIGRlbW8gcXVlc3Rpb24gdGV4dCBtZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODIwMDA5ODQiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyMDAwOTg0IgogIH0sCiAgewogICAgInRpdGxlIjogImNvbmNlcHRzIiwKICAgICJ0ZXh0IjogIktleSBNYXRoZW1hdGljYWwgQ29uY2VwdHNcblxuUHJpbWUgTnVtYmVyczogMiwgMywgNSwgNywgMTEsIDEzLCAxNywgMTksIDIzLCAyOS4uLlxuRmlib25hY2NpIFNlcXVlbmNlOiAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjEsIDM0Li4uXG5GYWN0b3JpYWxzOiAxLCAyLCA2LCAyNCwgMTIwLCA3MjAuLi5cblxuRGlzdGFuY2UgTWV0cmljczpcbi0gRXVjbGlkZWFuOiBkKHgseSkgPSBcdTIyMWEoXHUwM2EzKHhpLXlpKVx1MDBiMilcbi0gTWFuaGF0dGFuOiBkKHgseSkgPSBcdTAzYTN8eGkteWl8XG4tIEhhbW1pbmc6IG51bWJlciBvZiBkaWZmZXJpbmcgcG9zaXRpb25zXG5cbkNvbXB1dGF0aW9uYWwgQ29tcGxleGl0eTpcbi0gTygxKTogY29uc3RhbnQgdGltZVxuLSBPKGxvZyBuKTogbG9nYXJpdGhtaWMgXG4tIE8obik6IGxpbmVhciB0aW1lXG4tIE8obiBsb2cgbik6IGxpbmVhcml0aG1pY1xuLSBPKG5cdTAwYjIpOiBxdWFkcmF0aWMgdGltZVxuXG5XaGF0IHJlbGF0aW9uc2hpcHMgZXhpc3QgYmV0d2VlbiB0aGVzZSBjb25jZXB0cz9cbiIsCiAgICAidGFncyI6ICJxdWVzdGlvbiB0ZXh0IHR4dCIsCiAgICAidHlwZSI6ICJ0ZXh0L3BsYWluIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyMDAwOTg0IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjAwMDk4NCIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogQmxvY2twcmltZXM6IENvbXB1dGF0aW9uYWwgRGlzdGFuY2UgTWV0cmljcyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5cblxuISEgS2V5IENvbmNlcHRzXG5EaXN0YW5jZVxuXG4hISBDb250ZW50XG4jIEJsb2NrcHJpbWVzOiBDb21wdXRhdGlvbmFsIERpc3RhbmNlIE1ldHJpY3NcblxuXG4hISBUYWdzXG5ibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBudW1iZXItdGhlb3J5IiwKICAgICJ0YWdzIjogImJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIG51bWJlci10aGVvcnkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyMDAwOTg1IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjAwMDk4NSIsCiAgICAic3VtbWFyeSI6ICIiLAogICAgImtleV9jb25jZXB0cyI6ICJEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogSW50cm9kdWN0aW9uIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy4gVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuICoqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLiBXaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/XG5cbiEhIEtleSBDb25jZXB0c1xuUHJvb2YgUGF0dGVybiwgZmFjdG9yaXphdGlvbiwgcHJpbWUsIGRpc3RhbmNlLCBQcm9vZlxuXG4hISBDb250ZW50XG4jIyBJbnRyb2R1Y3Rpb25cbkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy5cblxuVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuXG5cbioqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLlxuXG5XaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/XG5cblxuISEgVGFnc1xucHJvb2YgcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0YWdzIjogInByb29mIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODIwMDA5ODUiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyMDAwOTg1IiwKICAgICJzdW1tYXJ5IjogIkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy4gVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuICoqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLiBXaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiUHJvb2YgUGF0dGVybiwgZmFjdG9yaXphdGlvbiwgcHJpbWUsIGRpc3RhbmNlLCBQcm9vZiIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IHRydWUsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImludGVybWVkaWF0ZSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogRGlzdGFuY2UgTWV0cmljcyBpbiBQcmltZSBTcGFjZSIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5cblxuISEgS2V5IENvbmNlcHRzXG5QcmltZSwgRGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMgRGlzdGFuY2UgTWV0cmljcyBpbiBQcmltZSBTcGFjZVxuXG5cbiEhIFRhZ3NcbmJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIG51bWJlci10aGVvcnkiLAogICAgInRhZ3MiOiAiYmxvY2twcmltZXMgYmxvY2twcmltZXMgbnVtYmVyLXRoZW9yeSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODIwMDA5ODUiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyMDAwOTg1IiwKICAgICJzdW1tYXJ5IjogIiIsCiAgICAia2V5X2NvbmNlcHRzIjogIlByaW1lLCBEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogRXVjbGlkZWFuIERpc3RhbmNlIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkZvciBudW1iZXJzIG0gPSBcdTIyMGZwXHUxZDYyXmFcdTFkNjIgYW5kIG4gPSBcdTIyMGZwXHUxZDYyXmJcdTFkNjIsIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgaXM6IGRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpICoqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjogLSBDb29yZGluYXRlczogbSBcdTIxOTIgKDIsMSksIG4gXHUyMTkyICgxLDIpICAgLSBEaXN0YW5jZTogZF9FKDEyLDE4KSA9IFx1MjIxYSgoMi0xKVx1MDBiMiArICgxLTIpXHUwMGIyKSA9IFx1MjIxYTIgVGhpcyBtZXRyaWMgcHJlc2VydmVzIG11bHRpcGxpY2F0aXZlIHN0cnVjdHVyZSB3aGlsZSBlbmFibGluZyBnZW9tZXRyaWMgcmVhc29uaW5nLiBDYW4gd2UgdXNlIHRoaXMgZGlzdGFuY2UgdG8gcHJlZGljdCBjb21wdXRhdGlvbmFsIGNvbXBsZXhpdHkgb2YgZmFjdG9yaXphdGlvbiBhbGdvcml0aG1zP1xuXG4hISBLZXkgQ29uY2VwdHNcbmZhY3Rvcml6YXRpb24sIGRfRSwgRGlzdGFuY2UsIGRpc3RhbmNlLCBEZW1vLCBtZXRyaWMsIGNvbXBsZXhpdHlcblxuISEgQ29udGVudFxuIyMjIEV1Y2xpZGVhbiBEaXN0YW5jZVxuRm9yIG51bWJlcnMgbSA9IFx1MjIwZnBcdTFkNjJeYVx1MWQ2MiBhbmQgbiA9IFx1MjIwZnBcdTFkNjJeYlx1MWQ2MiwgdGhlIEV1Y2xpZGVhbiBkaXN0YW5jZSBpczpcbmRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpXG5cbioqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjpcbi0gQ29vcmRpbmF0ZXM6IG0gXHUyMTkyICgyLDEpLCBuIFx1MjE5MiAoMSwyKSAgXG4tIERpc3RhbmNlOiBkX0UoMTIsMTgpID0gXHUyMjFhKCgyLTEpXHUwMGIyICsgKDEtMilcdTAwYjIpID0gXHUyMjFhMlxuXG5UaGlzIG1ldHJpYyBwcmVzZXJ2ZXMgbXVsdGlwbGljYXRpdmUgc3RydWN0dXJlIHdoaWxlIGVuYWJsaW5nIGdlb21ldHJpYyByZWFzb25pbmcuXG5cbkNhbiB3ZSB1c2UgdGhpcyBkaXN0YW5jZSB0byBwcmVkaWN0IGNvbXB1dGF0aW9uYWwgY29tcGxleGl0eSBvZiBmYWN0b3JpemF0aW9uIGFsZ29yaXRobXM/XG5cblxuISEgVGFnc1xuZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0YWdzIjogImRlbW8gcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSBmb2xsb3ctdXAgY29tcGxleGl0eSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODIwMDA5ODUiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyMDAwOTg1IiwKICAgICJzdW1tYXJ5IjogIkZvciBudW1iZXJzIG0gPSBcdTIyMGZwXHUxZDYyXmFcdTFkNjIgYW5kIG4gPSBcdTIyMGZwXHUxZDYyXmJcdTFkNjIsIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgaXM6IGRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpICoqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjogLSBDb29yZGluYXRlczogbSBcdTIxOTIgKDIsMSksIG4gXHUyMTkyICgxLDIpICAgLSBEaXN0YW5jZTogZF9FKDEyLDE4KSA9IFx1MjIxYSgoMi0xKVx1MDBiMiArICgxLTIpXHUwMGIyKSA9IFx1MjIxYTIgVGhpcyBtZXRyaWMgcHJlc2VydmVzIG11bHRpcGxpY2F0aXZlIHN0cnVjdHVyZSB3aGlsZSBlbmFibGluZyBnZW9tZXRyaWMgcmVhc29uaW5nLiBDYW4gd2UgdXNlIHRoaXMgZGlzdGFuY2UgdG8gcHJlZGljdCBjb21wdXRhdGlvbmFsIGNvbXBsZXhpdHkgb2YgZmFjdG9yaXphdGlvbiBhbGdvcml0aG1zPyIsCiAgICAia2V5X2NvbmNlcHRzIjogImZhY3Rvcml6YXRpb24sIGRfRSwgRGlzdGFuY2UsIGRpc3RhbmNlLCBEZW1vLCBtZXRyaWMsIGNvbXBsZXhpdHkiLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiBmYWxzZSwKICAgICJoYXNfZGVtbyI6IHRydWUsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogTWFuaGF0dGFuIERpc3RhbmNlIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcblRoZSBMXHUwMGI5IGRpc3RhbmNlIGNhcHR1cmVzIGFkZGl0aXZlIGNvbXBsZXhpdHk6IGRfTShtLG4pID0gXHUyMjExfGFcdTFkNjIgLSBiXHUxZDYyfCAqKkV4YW1wbGUqKjogRm9yIHRoZSBzYW1lIG09MTIsIG49MTg6IGRfTSgxMiwxOCkgPSB8Mi0xfCArIHwxLTJ8ID0gMiAqKlRoZW9yZW0qKjogTWFuaGF0dGFuIGRpc3RhbmNlIGluIHByaW1lIHNwYWNlIGVxdWFscyB0aGUgbWluaW11bSBudW1iZXIgb2YgcHJpbWUgZmFjdG9yIG1vZGlmaWNhdGlvbnMgdG8gdHJhbnNmb3JtIG0gaW50byBuLiAqKlByb29mKio6IEVhY2ggdW5pdCBvZiBNYW5oYXR0YW4gZGlzdGFuY2UgY29ycmVzcG9uZHMgdG8gaW5jcmVtZW50aW5nIG9yIGRlY3JlbWVudGluZyBhIHNpbmdsZSBwcmltZSBwb3dlciBieSAxLiBIb3cgZG9lcyB0aGlzIHJlbGF0ZSB0byBlZGl0IGRpc3RhbmNlIGluIGNvbXB1dGF0aW9uYWwgc3RyaW5ncz9cblxuISEgS2V5IENvbmNlcHRzXG5kX00sIFRoZW9yZW0sIEV4YW1wbGUsIHByaW1lLCBEaXN0YW5jZSwgZGlzdGFuY2UsIFByb29mLCBjb21wbGV4aXR5XG5cbiEhIENvbnRlbnRcbiMjIyBNYW5oYXR0YW4gRGlzdGFuY2VcblRoZSBMXHUwMGI5IGRpc3RhbmNlIGNhcHR1cmVzIGFkZGl0aXZlIGNvbXBsZXhpdHk6XG5kX00obSxuKSA9IFx1MjIxMXxhXHUxZDYyIC0gYlx1MWQ2MnxcblxuKipFeGFtcGxlKio6IEZvciB0aGUgc2FtZSBtPTEyLCBuPTE4OlxuZF9NKDEyLDE4KSA9IHwyLTF8ICsgfDEtMnwgPSAyXG5cbioqVGhlb3JlbSoqOiBNYW5oYXR0YW4gZGlzdGFuY2UgaW4gcHJpbWUgc3BhY2UgZXF1YWxzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBwcmltZSBmYWN0b3IgbW9kaWZpY2F0aW9ucyB0byB0cmFuc2Zvcm0gbSBpbnRvIG4uXG5cbioqUHJvb2YqKjogRWFjaCB1bml0IG9mIE1hbmhhdHRhbiBkaXN0YW5jZSBjb3JyZXNwb25kcyB0byBpbmNyZW1lbnRpbmcgb3IgZGVjcmVtZW50aW5nIGEgc2luZ2xlIHByaW1lIHBvd2VyIGJ5IDEuXG5cbkhvdyBkb2VzIHRoaXMgcmVsYXRlIHRvIGVkaXQgZGlzdGFuY2UgaW4gY29tcHV0YXRpb25hbCBzdHJpbmdzP1xuXG5cbiEhIFRhZ3NcbnByb29mIGRlbW8gcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgcHJvb2YgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSBmb2xsb3ctdXAgY29tcGxleGl0eSIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIHByb29mIGRlbW8gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyMDAwOTg1IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjAwMDk4NSIsCiAgICAic3VtbWFyeSI6ICJUaGUgTFx1MDBiOSBkaXN0YW5jZSBjYXB0dXJlcyBhZGRpdGl2ZSBjb21wbGV4aXR5OiBkX00obSxuKSA9IFx1MjIxMXxhXHUxZDYyIC0gYlx1MWQ2MnwgKipFeGFtcGxlKio6IEZvciB0aGUgc2FtZSBtPTEyLCBuPTE4OiBkX00oMTIsMTgpID0gfDItMXwgKyB8MS0yfCA9IDIgKipUaGVvcmVtKio6IE1hbmhhdHRhbiBkaXN0YW5jZSBpbiBwcmltZSBzcGFjZSBlcXVhbHMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHByaW1lIGZhY3RvciBtb2RpZmljYXRpb25zIHRvIHRyYW5zZm9ybSBtIGludG8gbi4gKipQcm9vZioqOiBFYWNoIHVuaXQgb2YgTWFuaGF0dGFuIGRpc3RhbmNlIGNvcnJlc3BvbmRzIHRvIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgYSBzaW5nbGUgcHJpbWUgcG93ZXIgYnkgMS4gSG93IGRvZXMgdGhpcyByZWxhdGUgdG8gZWRpdCBkaXN0YW5jZSBpbiBjb21wdXRhdGlvbmFsIHN0cmluZ3M/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiZF9NLCBUaGVvcmVtLCBFeGFtcGxlLCBwcmltZSwgRGlzdGFuY2UsIGRpc3RhbmNlLCBQcm9vZiwgY29tcGxleGl0eSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IHRydWUsCiAgICAiaGFzX2RlbW8iOiB0cnVlLAogICAgImNvbXBsZXhpdHlfbGV2ZWwiOiAiaW50ZXJtZWRpYXRlIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBDb21wdXRhdGlvbmFsIFNob3J0Y3V0cyB2aWEgRGlzdGFuY2UiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuXG5cbiEhIEtleSBDb25jZXB0c1xuRGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMgQ29tcHV0YXRpb25hbCBTaG9ydGN1dHMgdmlhIERpc3RhbmNlXG5cblxuISEgVGFnc1xuYmxvY2twcmltZXMgYmxvY2twcmltZXMiLAogICAgInRhZ3MiOiAiYmxvY2twcmltZXMgYmxvY2twcmltZXMiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyMDAwOTg1IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjAwMDk4NSIsCiAgICAic3VtbWFyeSI6ICIiLAogICAgImtleV9jb25jZXB0cyI6ICJEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogUGF0dGVybiBSZWNvZ25pdGlvbiIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5OdW1iZXJzIHdpdGggc21hbGwgbXV0dWFsIGRpc3RhbmNlcyBvZnRlbiBzaGFyZSBjb21wdXRhdGlvbmFsIHByb3BlcnRpZXM6ICoqRGVtbyoqOiBDb25zaWRlciB0aGUgc2VxdWVuY2UgOCwgMTIsIDE4LCAyNDogLSA4ID0gMlx1MDBiMyBcdTIxOTIgKDMsMCkgLSAxMiA9IDJcdTAwYjIgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgyLDEpICAgLSAxOCA9IDJcdTAwYjkgXHUwMGQ3IDNcdTAwYjIgXHUyMTkyICgxLDIpIC0gMjQgPSAyXHUwMGIzIFx1MDBkNyAzXHUwMGI5IFx1MjE5MiAoMywxKSBUaGUgTWFuaGF0dGFuIGRpc3RhbmNlcyBmb3JtIGEgcGF0dGVybjogZF9NKDgsMTIpPTIsIGRfTSgxMiwxOCk9MiwgZF9NKDE4LDI0KT0zLiBUaGlzIHN1Z2dlc3RzIG9wdGltaXphdGlvbiBzdHJhdGVnaWVzIGZvciBiYXRjaCBmYWN0b3JpemF0aW9uLlxuXG4hISBLZXkgQ29uY2VwdHNcbmRfTSwgRGVtbywgZmFjdG9yaXphdGlvblxuXG4hISBDb250ZW50XG4jIyMgUGF0dGVybiBSZWNvZ25pdGlvblxuTnVtYmVycyB3aXRoIHNtYWxsIG11dHVhbCBkaXN0YW5jZXMgb2Z0ZW4gc2hhcmUgY29tcHV0YXRpb25hbCBwcm9wZXJ0aWVzOlxuXG4qKkRlbW8qKjogQ29uc2lkZXIgdGhlIHNlcXVlbmNlIDgsIDEyLCAxOCwgMjQ6XG4tIDggPSAyXHUwMGIzIFx1MjE5MiAoMywwKVxuLSAxMiA9IDJcdTAwYjIgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgyLDEpICBcbi0gMTggPSAyXHUwMGI5IFx1MDBkNyAzXHUwMGIyIFx1MjE5MiAoMSwyKVxuLSAyNCA9IDJcdTAwYjMgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgzLDEpXG5cblRoZSBNYW5oYXR0YW4gZGlzdGFuY2VzIGZvcm0gYSBwYXR0ZXJuOiBkX00oOCwxMik9MiwgZF9NKDEyLDE4KT0yLCBkX00oMTgsMjQpPTMuXG5cblRoaXMgc3VnZ2VzdHMgb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXMgZm9yIGJhdGNoIGZhY3Rvcml6YXRpb24uXG5cblxuISEgVGFnc1xuZGVtbyBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IiwKICAgICJ0YWdzIjogImRlbW8gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODIwMDA5ODUiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyMDAwOTg1IiwKICAgICJzdW1tYXJ5IjogIk51bWJlcnMgd2l0aCBzbWFsbCBtdXR1YWwgZGlzdGFuY2VzIG9mdGVuIHNoYXJlIGNvbXB1dGF0aW9uYWwgcHJvcGVydGllczogKipEZW1vKio6IENvbnNpZGVyIHRoZSBzZXF1ZW5jZSA4LCAxMiwgMTgsIDI0OiAtIDggPSAyXHUwMGIzIFx1MjE5MiAoMywwKSAtIDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBcdTIxOTIgKDIsMSkgICAtIDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMiBcdTIxOTIgKDEsMikgLSAyNCA9IDJcdTAwYjMgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgzLDEpIFRoZSBNYW5oYXR0YW4gZGlzdGFuY2VzIGZvcm0gYSBwYXR0ZXJuOiBkX00oOCwxMik9MiwgZF9NKDEyLDE4KT0yLCBkX00oMTgsMjQpPTMuIFRoaXMgc3VnZ2VzdHMgb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXMgZm9yIGJhdGNoIGZhY3Rvcml6YXRpb24uIiwKICAgICJrZXlfY29uY2VwdHMiOiAiZF9NLCBEZW1vLCBmYWN0b3JpemF0aW9uIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDAsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiB0cnVlLAogICAgImNvbXBsZXhpdHlfbGV2ZWwiOiAiYmFzaWMiCiAgfSwKICB7CiAgICAidGl0bGUiOiAiYmxvY2twcmltZXM6IENvbXByZXNzaW9uIFRocm91Z2ggRGlzdGFuY2UiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuSW5zdGVhZCBvZiBzdG9yaW5nIGZ1bGwgZmFjdG9yaXphdGlvbnMsIHdlIGNhbiBlbmNvZGU6IDEuIEEgcmVmZXJlbmNlIHBvaW50IChhbmNob3IgZmFjdG9yaXphdGlvbikgMi4gRGlzdGFuY2UgdmVjdG9ycyB0byBuZWFyYnkgbnVtYmVycyAqKkFsZ29yaXRobSoqOiAgYGBgIGZ1bmN0aW9uIGVuY29kZV9ibG9jayhudW1iZXJzKTogICAgIGFuY2hvciA9IGdlb21ldHJpY19tZWRpYW4obnVtYmVycykgICAgIHJldHVybiBbYW5jaG9yLCBbZGlzdGFuY2VfdmVjdG9yKG4sIGFuY2hvcikgZm9yIG4gaW4gbnVtYmVyc11dIGBgYCBXaGF0IGlzIHRoZSBjb21wcmVzc2lvbiByYXRpbyBjb21wYXJlZCB0byBuYWl2ZSBzdG9yYWdlP1xuXG4hISBLZXkgQ29uY2VwdHNcbmZhY3Rvcml6YXRpb24sIEFsZ29yaXRobSwgRGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMjIENvbXByZXNzaW9uIFRocm91Z2ggRGlzdGFuY2Vcbkluc3RlYWQgb2Ygc3RvcmluZyBmdWxsIGZhY3Rvcml6YXRpb25zLCB3ZSBjYW4gZW5jb2RlOlxuMS4gQSByZWZlcmVuY2UgcG9pbnQgKGFuY2hvciBmYWN0b3JpemF0aW9uKVxuMi4gRGlzdGFuY2UgdmVjdG9ycyB0byBuZWFyYnkgbnVtYmVyc1xuXG4qKkFsZ29yaXRobSoqOiBcbmBgYFxuZnVuY3Rpb24gZW5jb2RlX2Jsb2NrKG51bWJlcnMpOlxuICAgIGFuY2hvciA9IGdlb21ldHJpY19tZWRpYW4obnVtYmVycylcbiAgICByZXR1cm4gW2FuY2hvciwgW2Rpc3RhbmNlX3ZlY3RvcihuLCBhbmNob3IpIGZvciBuIGluIG51bWJlcnNdXVxuYGBgXG5cbldoYXQgaXMgdGhlIGNvbXByZXNzaW9uIHJhdGlvIGNvbXBhcmVkIHRvIG5haXZlIHN0b3JhZ2U/XG5cblxuISEgVGFnc1xucXVlc3Rpb24gY29kZSBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBhbGdvcml0aG0gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInRhZ3MiOiAicXVlc3Rpb24gY29kZSBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBhbGdvcml0aG0gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyMDAwOTg2IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjAwMDk4NiIsCiAgICAic3VtbWFyeSI6ICJJbnN0ZWFkIG9mIHN0b3JpbmcgZnVsbCBmYWN0b3JpemF0aW9ucywgd2UgY2FuIGVuY29kZTogMS4gQSByZWZlcmVuY2UgcG9pbnQgKGFuY2hvciBmYWN0b3JpemF0aW9uKSAyLiBEaXN0YW5jZSB2ZWN0b3JzIHRvIG5lYXJieSBudW1iZXJzICoqQWxnb3JpdGhtKio6ICBgYGAgZnVuY3Rpb24gZW5jb2RlX2Jsb2NrKG51bWJlcnMpOiAgICAgYW5jaG9yID0gZ2VvbWV0cmljX21lZGlhbihudW1iZXJzKSAgICAgcmV0dXJuIFthbmNob3IsIFtkaXN0YW5jZV92ZWN0b3IobiwgYW5jaG9yKSBmb3IgbiBpbiBudW1iZXJzXV0gYGBgIFdoYXQgaXMgdGhlIGNvbXByZXNzaW9uIHJhdGlvIGNvbXBhcmVkIHRvIG5haXZlIHN0b3JhZ2U/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgQWxnb3JpdGhtLCBEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJpbnRlcm1lZGlhdGUiCiAgfSwKICB7CiAgICAidGl0bGUiOiAiYmxvY2twcmltZXM6IEFwcGxpY2F0aW9ucyB0byBDcnlwdG9ncmFwaHkiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuXG5cbiEhIEtleSBDb25jZXB0c1xuXG5cbiEhIENvbnRlbnRcbiMjIEFwcGxpY2F0aW9ucyB0byBDcnlwdG9ncmFwaHlcblxuXG4hISBUYWdzXG5ibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBzZWN1cml0eSIsCiAgICAidGFncyI6ICJibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBzZWN1cml0eSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODIwMDA5ODYiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyMDAwOTg2IiwKICAgICJzdW1tYXJ5IjogIiIsCiAgICAia2V5X2NvbmNlcHRzIjogIiIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJhZHZhbmNlZCIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogUlNBIEtleSBEaXN0YW5jZSBBbmFseXNpcyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5Gb3IgUlNBIG1vZHVsaSBOXHUyMDgxID0gcFx1MjA4MXFcdTIwODEgYW5kIE5cdTIwODIgPSBwXHUyMDgycVx1MjA4MiwgdGhlIGRpc3RhbmNlIGQoTlx1MjA4MSxOXHUyMDgyKSByZXZlYWxzIHN0cnVjdHVyYWwgc2ltaWxhcml0eS4gKipTZWN1cml0eSBJbXBsaWNhdGlvbioqOiBJZiBkKE5cdTIwODEsTlx1MjA4MikgPCB0aHJlc2hvbGQsIHRoZSBrZXlzIG1heSBzaGFyZSB2dWxuZXJhYmlsaXRpZXMuICoqUHJvb2YgU2tldGNoKio6IENsb3NlIGRpc3RhbmNlcyBpbXBseSBzaW1pbGFyIHByaW1lIHN0cnVjdHVyZXMsIHBvdGVudGlhbGx5IGVuYWJsaW5nIGNyb3NzLWtleSBhdHRhY2tzIHRocm91Z2ggc2hhcmVkIGZhY3Rvcml6YXRpb24gc2hvcnRjdXRzLiAqKkV4YW1wbGUqKjogSWYgTlx1MjA4MSA9IDc3ID0gN1x1MDBkNzExIGFuZCBOXHUyMDgyID0gOTEgPSA3XHUwMGQ3MTMsIHRoZXkgc2hhcmUgdGhlIHByaW1lIDcsIGxlYWRpbmcgdG8gZ2NkKE5cdTIwODEsTlx1MjA4MikgPSA3LiBDb3VsZCB3ZSBkZXZlbG9wIGRpc3RhbmNlLWJhc2VkIFJTQSBrZXkgdmFsaWRhdGlvbj9cblxuISEgS2V5IENvbmNlcHRzXG5mYWN0b3JpemF0aW9uLCBQcm9vZiBTa2V0Y2gsIEV4YW1wbGUsIHByaW1lLCBTZWN1cml0eSBJbXBsaWNhdGlvbiwgRGlzdGFuY2UsIFByb29mLCBkaXN0YW5jZVxuXG4hISBDb250ZW50XG4jIyMgUlNBIEtleSBEaXN0YW5jZSBBbmFseXNpc1xuRm9yIFJTQSBtb2R1bGkgTlx1MjA4MSA9IHBcdTIwODFxXHUyMDgxIGFuZCBOXHUyMDgyID0gcFx1MjA4MnFcdTIwODIsIHRoZSBkaXN0YW5jZSBkKE5cdTIwODEsTlx1MjA4MikgcmV2ZWFscyBzdHJ1Y3R1cmFsIHNpbWlsYXJpdHkuXG5cbioqU2VjdXJpdHkgSW1wbGljYXRpb24qKjogSWYgZChOXHUyMDgxLE5cdTIwODIpIDwgdGhyZXNob2xkLCB0aGUga2V5cyBtYXkgc2hhcmUgdnVsbmVyYWJpbGl0aWVzLlxuXG4qKlByb29mIFNrZXRjaCoqOiBDbG9zZSBkaXN0YW5jZXMgaW1wbHkgc2ltaWxhciBwcmltZSBzdHJ1Y3R1cmVzLCBwb3RlbnRpYWxseSBlbmFibGluZyBjcm9zcy1rZXkgYXR0YWNrcyB0aHJvdWdoIHNoYXJlZCBmYWN0b3JpemF0aW9uIHNob3J0Y3V0cy5cblxuKipFeGFtcGxlKio6IElmIE5cdTIwODEgPSA3NyA9IDdcdTAwZDcxMSBhbmQgTlx1MjA4MiA9IDkxID0gN1x1MDBkNzEzLCB0aGV5IHNoYXJlIHRoZSBwcmltZSA3LCBsZWFkaW5nIHRvIGdjZChOXHUyMDgxLE5cdTIwODIpID0gNy5cblxuQ291bGQgd2UgZGV2ZWxvcCBkaXN0YW5jZS1iYXNlZCBSU0Ega2V5IHZhbGlkYXRpb24/XG5cblxuISEgVGFnc1xucHJvb2YgZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIHNlY3VyaXR5IGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRlbW8gc2VjdXJpdHkgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MjAwMDk4NiIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODIwMDA5ODYiLAogICAgInN1bW1hcnkiOiAiRm9yIFJTQSBtb2R1bGkgTlx1MjA4MSA9IHBcdTIwODFxXHUyMDgxIGFuZCBOXHUyMDgyID0gcFx1MjA4MnFcdTIwODIsIHRoZSBkaXN0YW5jZSBkKE5cdTIwODEsTlx1MjA4MikgcmV2ZWFscyBzdHJ1Y3R1cmFsIHNpbWlsYXJpdHkuICoqU2VjdXJpdHkgSW1wbGljYXRpb24qKjogSWYgZChOXHUyMDgxLE5cdTIwODIpIDwgdGhyZXNob2xkLCB0aGUga2V5cyBtYXkgc2hhcmUgdnVsbmVyYWJpbGl0aWVzLiAqKlByb29mIFNrZXRjaCoqOiBDbG9zZSBkaXN0YW5jZXMgaW1wbHkgc2ltaWxhciBwcmltZSBzdHJ1Y3R1cmVzLCBwb3RlbnRpYWxseSBlbmFibGluZyBjcm9zcy1rZXkgYXR0YWNrcyB0aHJvdWdoIHNoYXJlZCBmYWN0b3JpemF0aW9uIHNob3J0Y3V0cy4gKipFeGFtcGxlKio6IElmIE5cdTIwODEgPSA3NyA9IDdcdTAwZDcxMSBhbmQgTlx1MjA4MiA9IDkxID0gN1x1MDBkNzEzLCB0aGV5IHNoYXJlIHRoZSBwcmltZSA3LCBsZWFkaW5nIHRvIGdjZChOXHUyMDgxLE5cdTIwODIpID0gNy4gQ291bGQgd2UgZGV2ZWxvcCBkaXN0YW5jZS1iYXNlZCBSU0Ega2V5IHZhbGlkYXRpb24/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgUHJvb2YgU2tldGNoLCBFeGFtcGxlLCBwcmltZSwgU2VjdXJpdHkgSW1wbGljYXRpb24sIERpc3RhbmNlLCBQcm9vZiwgZGlzdGFuY2UiLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiB0cnVlLAogICAgImhhc19kZW1vIjogdHJ1ZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImJhc2ljIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBGZXJtYXQgTnVtYmVyIENvbm5lY3Rpb25zIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcblxuXG4hISBLZXkgQ29uY2VwdHNcblxuXG4hISBDb250ZW50XG4jIyBGZXJtYXQgTnVtYmVyIENvbm5lY3Rpb25zXG5cblxuISEgVGFnc1xuYmxvY2twcmltZXMgYmxvY2twcmltZXMgbnVtYmVyLXRoZW9yeSIsCiAgICAidGFncyI6ICJibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBudW1iZXItdGhlb3J5IiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MjAwMDk4NiIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODIwMDA5ODYiLAogICAgInN1bW1hcnkiOiAiIiwKICAgICJrZXlfY29uY2VwdHMiOiAiIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDAsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImJhc2ljIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBEaXN0YW5jZSB0byBGZXJtYXQgTnVtYmVycyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5GZXJtYXQgbnVtYmVycyBGXHUyMDk5ID0gMl4oMlx1MjA3ZikgKyAxIHNlcnZlIGFzIHJlZmVyZW5jZSBwb2ludHMgaW4gcHJpbWUgc3BhY2UuICoqT2JzZXJ2YXRpb24qKjogTnVtYmVycyBuZWFyIEZlcm1hdCBudW1iZXJzIGluIGRpc3RhbmNlIG1ldHJpYyBvZnRlbiBleGhpYml0IHNwZWNpYWwgcHJvcGVydGllcy4gKipEZW1vKio6IEZcdTIwODAgPSAzLCBGXHUyMDgxID0gNSwgRlx1MjA4MiA9IDE3LCBGXHUyMDgzID0gMjU3IERpc3RhbmNlIGFuYWx5c2lzIHJldmVhbHMgY2x1c3RlcmluZyBhcm91bmQgcG93ZXJzIG9mIDIuICoqT3BlbiBRdWVzdGlvbioqOiBEb2VzIHByb3hpbWl0eSB0byBGZXJtYXQgbnVtYmVycyBwcmVkaWN0IHByaW1hbGl0eSB0ZXN0aW5nIGVmZmljaWVuY3k/XG5cbiEhIEtleSBDb25jZXB0c1xucHJpbWUsIE9ic2VydmF0aW9uLCBEaXN0YW5jZSwgT3BlbiBRdWVzdGlvbiwgZGlzdGFuY2UsIERlbW8sIG1ldHJpY1xuXG4hISBDb250ZW50XG4jIyMgRGlzdGFuY2UgdG8gRmVybWF0IE51bWJlcnNcbkZlcm1hdCBudW1iZXJzIEZcdTIwOTkgPSAyXigyXHUyMDdmKSArIDEgc2VydmUgYXMgcmVmZXJlbmNlIHBvaW50cyBpbiBwcmltZSBzcGFjZS5cblxuKipPYnNlcnZhdGlvbioqOiBOdW1iZXJzIG5lYXIgRmVybWF0IG51bWJlcnMgaW4gZGlzdGFuY2UgbWV0cmljIG9mdGVuIGV4aGliaXQgc3BlY2lhbCBwcm9wZXJ0aWVzLlxuXG4qKkRlbW8qKjogRlx1MjA4MCA9IDMsIEZcdTIwODEgPSA1LCBGXHUyMDgyID0gMTcsIEZcdTIwODMgPSAyNTdcbkRpc3RhbmNlIGFuYWx5c2lzIHJldmVhbHMgY2x1c3RlcmluZyBhcm91bmQgcG93ZXJzIG9mIDIuXG5cbioqT3BlbiBRdWVzdGlvbioqOiBEb2VzIHByb3hpbWl0eSB0byBGZXJtYXQgbnVtYmVycyBwcmVkaWN0IHByaW1hbGl0eSB0ZXN0aW5nIGVmZmljaWVuY3k/XG5cblxuISEgVGFnc1xuZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidGFncyI6ICJkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRlbW8gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MjAwMDk4NiIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODIwMDA5ODYiLAogICAgInN1bW1hcnkiOiAiRmVybWF0IG51bWJlcnMgRlx1MjA5OSA9IDJeKDJcdTIwN2YpICsgMSBzZXJ2ZSBhcyByZWZlcmVuY2UgcG9pbnRzIGluIHByaW1lIHNwYWNlLiAqKk9ic2VydmF0aW9uKio6IE51bWJlcnMgbmVhciBGZXJtYXQgbnVtYmVycyBpbiBkaXN0YW5jZSBtZXRyaWMgb2Z0ZW4gZXhoaWJpdCBzcGVjaWFsIHByb3BlcnRpZXMuICoqRGVtbyoqOiBGXHUyMDgwID0gMywgRlx1MjA4MSA9IDUsIEZcdTIwODIgPSAxNywgRlx1MjA4MyA9IDI1NyBEaXN0YW5jZSBhbmFseXNpcyByZXZlYWxzIGNsdXN0ZXJpbmcgYXJvdW5kIHBvd2VycyBvZiAyLiAqKk9wZW4gUXVlc3Rpb24qKjogRG9lcyBwcm94aW1pdHkgdG8gRmVybWF0IG51bWJlcnMgcHJlZGljdCBwcmltYWxpdHkgdGVzdGluZyBlZmZpY2llbmN5PyIsCiAgICAia2V5X2NvbmNlcHRzIjogInByaW1lLCBPYnNlcnZhdGlvbiwgRGlzdGFuY2UsIE9wZW4gUXVlc3Rpb24sIGRpc3RhbmNlLCBEZW1vLCBtZXRyaWMiLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiBmYWxzZSwKICAgICJoYXNfZGVtbyI6IHRydWUsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogQ29tcHV0YXRpb25hbCBJbXBsaWNhdGlvbnMiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOiAxLiBQcmVkaWN0aXZlIGNvbXBsZXhpdHkgYW5hbHlzaXMgMi4gT3B0aW1pemVkIGZhY3Rvcml6YXRpb24gcm91dGVzICAgMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHMgNC4gUGF0dGVybiBkaXNjb3ZlcnkgaW4gbnVtYmVyIHNlcXVlbmNlcyAqKlJlc2VhcmNoIERpcmVjdGlvbioqOiBDYW4gd2UgZXh0ZW5kIHRoaXMgZnJhbWV3b3JrIHRvIGFsZ2VicmFpYyBpbnRlZ2VycyBhbmQgb3RoZXIgbWF0aGVtYXRpY2FsIHN0cnVjdHVyZXM/XG5cbiEhIEtleSBDb25jZXB0c1xuZmFjdG9yaXphdGlvbiwgUmVzZWFyY2ggRGlyZWN0aW9uLCBkaXN0YW5jZSwgbWV0cmljLCBjb21wbGV4aXR5XG5cbiEhIENvbnRlbnRcbiMjIyBDb21wdXRhdGlvbmFsIEltcGxpY2F0aW9uc1xuVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOlxuMS4gUHJlZGljdGl2ZSBjb21wbGV4aXR5IGFuYWx5c2lzXG4yLiBPcHRpbWl6ZWQgZmFjdG9yaXphdGlvbiByb3V0ZXMgIFxuMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHNcbjQuIFBhdHRlcm4gZGlzY292ZXJ5IGluIG51bWJlciBzZXF1ZW5jZXNcblxuKipSZXNlYXJjaCBEaXJlY3Rpb24qKjogQ2FuIHdlIGV4dGVuZCB0aGlzIGZyYW1ld29yayB0byBhbGdlYnJhaWMgaW50ZWdlcnMgYW5kIG90aGVyIG1hdGhlbWF0aWNhbCBzdHJ1Y3R1cmVzP1xuXG5cbiEhIFRhZ3NcbnF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0YWdzIjogInF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MjAwMDk4NiIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODIwMDA5ODYiLAogICAgInN1bW1hcnkiOiAiVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOiAxLiBQcmVkaWN0aXZlIGNvbXBsZXhpdHkgYW5hbHlzaXMgMi4gT3B0aW1pemVkIGZhY3Rvcml6YXRpb24gcm91dGVzICAgMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHMgNC4gUGF0dGVybiBkaXNjb3ZlcnkgaW4gbnVtYmVyIHNlcXVlbmNlcyAqKlJlc2VhcmNoIERpcmVjdGlvbioqOiBDYW4gd2UgZXh0ZW5kIHRoaXMgZnJhbWV3b3JrIHRvIGFsZ2VicmFpYyBpbnRlZ2VycyBhbmQgb3RoZXIgbWF0aGVtYXRpY2FsIHN0cnVjdHVyZXM/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgUmVzZWFyY2ggRGlyZWN0aW9uLCBkaXN0YW5jZSwgbWV0cmljLCBjb21wbGV4aXR5IiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDEsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImFkdmFuY2VkIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBDb25jbHVzaW9uIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkJsb2NrIHByaW1lIGRpc3RhbmNlIG1ldHJpY3MgdHJhbnNmb3JtIGRpc2NyZXRlIG51bWJlciB0aGVvcnkgaW50byBjb250aW51b3VzIGdlb21ldHJpYyBvcHRpbWl6YXRpb24uIFRoaXMgZW5hYmxlcyBuZXcgY29tcHV0YXRpb25hbCBzaG9ydGN1dHMgYW5kIHJldmVhbHMgaGlkZGVuIHBhdHRlcm5zIGluIG1hdGhlbWF0aWNhbCBzdHJ1Y3R1cmVzLiAqKkZ1dHVyZSBXb3JrKio6IEludmVzdGlnYXRlIGRpc3RhbmNlLXByZXNlcnZpbmcgdHJhbnNmb3JtYXRpb25zIGFuZCB0aGVpciBpbXBhY3Qgb24gYWxnb3JpdGhtaWMgY29tcGxleGl0eS4gSG93IG1pZ2h0IHF1YW50dW0gY29tcHV0aW5nIGNoYW5nZSB0aGVzZSBkaXN0YW5jZSByZWxhdGlvbnNoaXBzP1xuXG4hISBLZXkgQ29uY2VwdHNcbnByaW1lLCBkaXN0YW5jZSwgY29tcGxleGl0eSwgRnV0dXJlIFdvcmtcblxuISEgQ29udGVudFxuIyMgQ29uY2x1c2lvblxuXG5CbG9jayBwcmltZSBkaXN0YW5jZSBtZXRyaWNzIHRyYW5zZm9ybSBkaXNjcmV0ZSBudW1iZXIgdGhlb3J5IGludG8gY29udGludW91cyBnZW9tZXRyaWMgb3B0aW1pemF0aW9uLiBUaGlzIGVuYWJsZXMgbmV3IGNvbXB1dGF0aW9uYWwgc2hvcnRjdXRzIGFuZCByZXZlYWxzIGhpZGRlbiBwYXR0ZXJucyBpbiBtYXRoZW1hdGljYWwgc3RydWN0dXJlcy5cblxuKipGdXR1cmUgV29yayoqOiBJbnZlc3RpZ2F0ZSBkaXN0YW5jZS1wcmVzZXJ2aW5nIHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlaXIgaW1wYWN0IG9uIGFsZ29yaXRobWljIGNvbXBsZXhpdHkuXG5cbkhvdyBtaWdodCBxdWFudHVtIGNvbXB1dGluZyBjaGFuZ2UgdGhlc2UgZGlzdGFuY2UgcmVsYXRpb25zaGlwcz9cblxuISEgVGFnc1xucXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInRhZ3MiOiAicXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyMDAwOTg2IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjAwMDk4NiIsCiAgICAic3VtbWFyeSI6ICJCbG9jayBwcmltZSBkaXN0YW5jZSBtZXRyaWNzIHRyYW5zZm9ybSBkaXNjcmV0ZSBudW1iZXIgdGhlb3J5IGludG8gY29udGludW91cyBnZW9tZXRyaWMgb3B0aW1pemF0aW9uLiBUaGlzIGVuYWJsZXMgbmV3IGNvbXB1dGF0aW9uYWwgc2hvcnRjdXRzIGFuZCByZXZlYWxzIGhpZGRlbiBwYXR0ZXJucyBpbiBtYXRoZW1hdGljYWwgc3RydWN0dXJlcy4gKipGdXR1cmUgV29yayoqOiBJbnZlc3RpZ2F0ZSBkaXN0YW5jZS1wcmVzZXJ2aW5nIHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlaXIgaW1wYWN0IG9uIGFsZ29yaXRobWljIGNvbXBsZXhpdHkuIEhvdyBtaWdodCBxdWFudHVtIGNvbXB1dGluZyBjaGFuZ2UgdGhlc2UgZGlzdGFuY2UgcmVsYXRpb25zaGlwcz8iLAogICAgImtleV9jb25jZXB0cyI6ICJwcmltZSwgZGlzdGFuY2UsIGNvbXBsZXhpdHksIEZ1dHVyZSBXb3JrIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDEsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImludGVybWVkaWF0ZSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJ0aGVvcmVtMSIsCiAgICAidGV4dCI6ICIjIEZ1bmRhbWVudGFsIFRoZW9yZW0gb2YgQXJpdGhtZXRpY1xuXG4qKlRoZW9yZW0qKjogRXZlcnkgaW50ZWdlciBncmVhdGVyIHRoYW4gMSBpcyBlaXRoZXIgcHJpbWUgb3IgY2FuIGJlIHVuaXF1ZWx5IGZhY3RvcmVkIGludG8gcHJpbWUgbnVtYmVycy5cblxuKipQcm9vZioqOiBcbjEuIEV4aXN0ZW5jZTogQXNzdW1lIHNvbWUgaW50ZWdlciBuID4gMSBjYW5ub3QgYmUgZmFjdG9yZWQuIFxuMi4gTGV0IFMgYmUgdGhlIHNldCBvZiBhbGwgc3VjaCBpbnRlZ2Vycy5cbjMuIEJ5IHdlbGwtb3JkZXJpbmcsIFMgaGFzIGEgbWluaW11bSBlbGVtZW50IG0uXG40LiBTaW5jZSBtIGNhbm5vdCBiZSBmYWN0b3JlZCwgbSBtdXN0IGJlIHByaW1lLlxuNS4gVGhpcyBjb250cmFkaWN0cyBvdXIgYXNzdW1wdGlvbi5cblxuVGhlcmVmb3JlLCBldmVyeSBpbnRlZ2VyIGNhbiBiZSBmYWN0b3JlZCBpbnRvIHByaW1lcy5cblxuKipEZW1vKio6IDEyID0gMlx1MDBiMiBcdTAwZDcgMywgMTUgPSAzIFx1MDBkNyA1LCAzMCA9IDIgXHUwMGQ3IDMgXHUwMGQ3IDVcblxuVGhpcyB0aGVvcmVtIGlzIGZ1bmRhbWVudGFsIHRvIG51bWJlciB0aGVvcnkgYW5kIGNyeXB0b2dyYXBoeS5cblxuSG93IGRvZXMgdGhpcyByZWxhdGUgdG8gdGhlIGRpc3RhbmNlIG1ldHJpY3MgaW4gcHJpbWUgc3BhY2U/XG4iLAogICAgInRhZ3MiOiAicHJvb2YgZGVtbyBxdWVzdGlvbiB0ZXh0IG1kIiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MjAwMDk4NiIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODIwMDA5ODYiCiAgfQpdCn07Cjwvc2NyaXB0Pgo8L2hlYWQ+Cjxib2R5Pgo8ZGl2IGlkPSJ0aWRkbHl3aWtpIj4KPGgxPkNvbXBpbGVkIFdpa2k8L2gxPgo8cD5UaGlzIHdpa2kgY29udGFpbnMgMTggdGlkZGxlcnMgY29tcGlsZWQgZnJvbSBzYW1wbGVfY29udGVudDwvcD4KPC9kaXY+CjwvYm9keT4KPC9odG1sPg==",
    "tags": "binary attachment",
    "type": "text/html",
    "created": "20250802082912815",
    "modified": "20250802082912815",
    "_canonical_uri": "data:text/html;base64,"
  },
  {
    "title": "demo",
    "text": "#!/usr/bin/env python3\n\"\"\"\nDemo script for TiddlyWiki Compiler\nShows how to compile files into a TiddlyWiki with sample content\n\"\"\"\n\nimport os\nimport sys\nfrom pathlib import Path\n\n# Add the current directory to the path so we can import our modules\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom main import TiddlyWikiCompiler\n\n\ndef create_sample_content():\n    \"\"\"Create sample content for demonstration\"\"\"\n    sample_dir = Path(\"sample_content\")\n    sample_dir.mkdir(exist_ok=True)\n    \n    # Copy the sample blockprimes.md file\n    blockprimes_source = Path(\"sample_blockprimes.md\")\n    if blockprimes_source.exists():\n        import shutil\n        shutil.copy(blockprimes_source, sample_dir / \"blockprimes.md\")\n    \n    # Create additional sample files\n    (sample_dir / \"introduction.md\").write_text(\"\"\"# Welcome to the math Wiki\n\nThis wiki demonstrates the TiddlyWiki compiler's ability to structure and organize math content.\n\n## Features\n\n- **Automatic tagging** based on content patterns\n- **Distance-metric compression** using blockprimes concepts  \n- **Structured tiddlers** with summaries and key concepts\n- **Interactive filtering** by tags and search\n\n## Sample Content\n\nThe blockprimes.md file has been automatically broken down into multiple tiddlers, each with:\n- Summary sections\n- Key concept extraction\n- Automatic tagging (proof, demo, question, etc.)\n- Follow-up question detection\n\n**Example**: math proofs are automatically tagged as \"proof\" and formatted with special styling.\n\nWhat patterns will you discover in your own content?\n\"\"\")\n    \n    (sample_dir / \"algorithms.py\").write_text(\"\"\"# Sample algo\ndef factorial(n):\n    \\\"\\\"\\\"\n    Compute factorial using recursive algo\n    Time complexity: O(n)\n    Space complexity: O(n) due to recursion\n    \\\"\\\"\\\"\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n\ndef fibonacci(n):\n    \\\"\\\"\\\"\n    Compute Fibonacci number\n    Demonstrates exponential growth pattern\n    \\\"\\\"\\\"\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Example usage\nprint(f\"5! = {factorial(5)}\")\nprint(f\"F(10) = {fibonacci(10)}\")\n\"\"\")\n    \n    (sample_dir / \"concepts.txt\").write_text(\"\"\"Key math Concepts\n\nPrime Numbers: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29...\nFibonacci Sequence: 1, 1, 2, 3, 5, 8, 13, 21, 34...\nFactorials: 1, 2, 6, 24, 120, 720...\n\nDistance Metrics:\n- Euclidean: d(x,y) = \u221a(\u03a3(xi-yi)\u00b2)\n- Manhattan: d(x,y) = \u03a3|xi-yi|\n- Hamming: number of differing positions\n\nComputational Complexity:\n- O(1): constant time\n- O(log n): logarithmic \n- O(n): linear time\n- O(n log n): linearithmic\n- O(n\u00b2): quadratic time\n\nWhat relationships exist between these concepts?\n\"\"\")\n    \n    # Create a subdirectory with more content\n    (sample_dir / \"proofs\").mkdir(exist_ok=True)\n    (sample_dir / \"proofs\" / \"theorem1.md\").write_text(\"\"\"# Fundamental Theorem of Arithmetic\n\n**Theorem**: Every integer greater than 1 is either prime or can be uniquely factored into prime numbers.\n\n**Proof**: \n1. Existence: Assume some integer n > 1 cannot be factored. \n2. Let S be the set of all such integers.\n3. By well-ordering, S has a minimum element m.\n4. Since m cannot be factored, m must be prime.\n5. This contradicts our assumption.\n\nTherefore, every integer can be factored into primes.\n\n**Demo**: 12 = 2\u00b2 \u00d7 3, 15 = 3 \u00d7 5, 30 = 2 \u00d7 3 \u00d7 5\n\nThis theorem is fundamental to number theory and cryptography.\n\nHow does this relate to the distance metrics in prime space?\n\"\"\")\n    \n    return sample_dir\n\n\ndef run_demo():\n    \"\"\"Run the demonstration\"\"\"\n    print(\"TiddlyWiki Compiler Demo\")\n    print(\"=\" * 40)\n    \n    # Create sample content\n    print(\"Creating sample content...\")\n    sample_dir = create_sample_content()\n    print(f\"Sample content created in: {sample_dir}\")\n    \n    # Initialize compiler\n    print(\"\\nInitializing TiddlyWiki compiler...\")\n    compiler = TiddlyWikiCompiler(str(sample_dir), \"demo_wiki.html\")\n    compiler.compression_enabled = True\n    \n    # Compile the wiki\n    print(\"Compiling wiki...\")\n    compiler.compile()\n    \n    print(f\"\\nDemo complete!\")\n    print(f\"Generated wiki: demo_wiki.html\")\n    print(f\"Processed {len(compiler.tiddlers)} tiddlers\")\n    \n    # Show tiddler breakdown\n    print(\"\\nTiddler Breakdown:\")\n    for tiddler in compiler.tiddlers:\n        print(f\"  - {tiddler.title} ({len(tiddler.tags)} tags)\")\n        print(f\"    Tags: {', '.join(tiddler.tags)}\")\n        if hasattr(tiddler, 'fields') and tiddler.fields.get('complexity_level'):\n            print(f\"    Complexity: {tiddler.fields['complexity_level']}\")\n        print()\n    \n    # Show tag statistics\n    all_tags = []\n    for tiddler in compiler.tiddlers:\n        all_tags.extend(tiddler.tags)\n    \n    tag_counts = {}\n    for tag in all_tags:\n        tag_counts[tag] = tag_counts.get(tag, 0) + 1\n    \n    print(\"Tag Statistics:\")\n    for tag, count in sorted(tag_counts.items(), key=lambda x: x[1], reverse=True):\n        print(f\"  {tag}: {count}\")\n    \n    print(f\"\\nOpen demo_wiki.html in your browser to explore the compiled wiki!\")\n\n\nif __name__ == \"__main__\":\n    run_demo()",
    "tags": "proof demo question code text py compressed",
    "type": "text/plain",
    "created": "20250802082912816",
    "modified": "20250802082912816"
  },
  {
    "title": "sample_blockprimes: Blockprimes: Computational Distance Metrics",
    "text": "!! Summary\n\n\n!! Key Concepts\nDistance\n\n!! Content\n# Blockprimes: Computational Distance Metrics\n\n\n!! Tags\nsample_blockprimes blockprimes number-theory",
    "tags": "sample_blockprimes blockprimes number-theory",
    "type": "text/x-markdown",
    "created": "20250802082912817",
    "modified": "20250802082912817",
    "summary": "",
    "key_concepts": "Distance",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "basic"
  },
  {
    "title": "sample_blockprimes: Introduction",
    "text": "!! Summary\nBlock primes represent a novel approach to computational distance measurement in mathematical spaces. By encoding prime factorizations as spatial coordinates, we can transform number theory problems into geometric optimization challenges. The fundamental insight is that every composite number n can be represented as a point in prime-factorization space, where coordinates correspond to prime powers: n = p\u2081^a\u2081 \u00d7 p\u2082^a\u2082 \u00d7 ... \u00d7 p\u2096^a\u2096. **Proof Pattern**: Given any composite number n, its unique prime factorization provides coordinates (a\u2081, a\u2082, ..., a\u2096) in \u2124\u1d4f space. What computational patterns emerge when we measure distances between these points?\n\n!! Key Concepts\nfactorization, distance, prime, Proof Pattern, Proof\n\n!! Content\n## Introduction\nBlock primes represent a novel approach to computational distance measurement in mathematical spaces. By encoding prime factorizations as spatial coordinates, we can transform number theory problems into geometric optimization challenges.\n\nThe fundamental insight is that every composite number n can be represented as a point in prime-factorization space, where coordinates correspond to prime powers: n = p\u2081^a\u2081 \u00d7 p\u2082^a\u2082 \u00d7 ... \u00d7 p\u2096^a\u2096.\n\n**Proof Pattern**: Given any composite number n, its unique prime factorization provides coordinates (a\u2081, a\u2082, ..., a\u2096) in \u2124\u1d4f space.\n\nWhat computational patterns emerge when we measure distances between these points?\n\n\n!! Tags\nproof question sample_blockprimes blockprimes distance-metric number-theory follow-up",
    "tags": "proof question sample_blockprimes blockprimes distance-metric number-theory follow-up",
    "type": "text/x-markdown",
    "created": "20250802082912817",
    "modified": "20250802082912817",
    "summary": "Block primes represent a novel approach to computational distance measurement in mathematical spaces. By encoding prime factorizations as spatial coordinates, we can transform number theory problems into geometric optimization challenges. The fundamental insight is that every composite number n can be represented as a point in prime-factorization space, where coordinates correspond to prime powers: n = p\u2081^a\u2081 \u00d7 p\u2082^a\u2082 \u00d7 ... \u00d7 p\u2096^a\u2096. **Proof Pattern**: Given any composite number n, its unique prime factorization provides coordinates (a\u2081, a\u2082, ..., a\u2096) in \u2124\u1d4f space. What computational patterns emerge when we measure distances between these points?",
    "key_concepts": "factorization, distance, prime, Proof Pattern, Proof",
    "question_count": 1,
    "has_proof": true,
    "has_demo": false,
    "complexity_level": "intermediate"
  },
  {
    "title": "sample_blockprimes: Distance Metrics in Prime Space",
    "text": "!! Summary\n\n\n!! Key Concepts\nDistance, Prime\n\n!! Content\n## Distance Metrics in Prime Space\n\n\n!! Tags\nsample_blockprimes blockprimes number-theory",
    "tags": "sample_blockprimes blockprimes number-theory",
    "type": "text/x-markdown",
    "created": "20250802082912817",
    "modified": "20250802082912817",
    "summary": "",
    "key_concepts": "Distance, Prime",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "basic"
  },
  {
    "title": "sample_blockprimes: Euclidean Distance",
    "text": "!! Summary\nFor numbers m = \u220fp\u1d62^a\u1d62 and n = \u220fp\u1d62^b\u1d62, the Euclidean distance is: d_E(m,n) = \u221a(\u2211(a\u1d62 - b\u1d62)\u00b2) **Demo**: Let m = 12 = 2\u00b2 \u00d7 3\u00b9 and n = 18 = 2\u00b9 \u00d7 3\u00b2. Then: - Coordinates: m \u2192 (2,1), n \u2192 (1,2)   - Distance: d_E(12,18) = \u221a((2-1)\u00b2 + (1-2)\u00b2) = \u221a2 This metric preserves multiplicative structure while enabling geometric reasoning. Can we use this distance to predict computational complexity of factorization algorithms?\n\n!! Key Concepts\nmetric, factorization, d_E, complexity, distance, Distance, Demo\n\n!! Content\n### Euclidean Distance\nFor numbers m = \u220fp\u1d62^a\u1d62 and n = \u220fp\u1d62^b\u1d62, the Euclidean distance is:\nd_E(m,n) = \u221a(\u2211(a\u1d62 - b\u1d62)\u00b2)\n\n**Demo**: Let m = 12 = 2\u00b2 \u00d7 3\u00b9 and n = 18 = 2\u00b9 \u00d7 3\u00b2. Then:\n- Coordinates: m \u2192 (2,1), n \u2192 (1,2)  \n- Distance: d_E(12,18) = \u221a((2-1)\u00b2 + (1-2)\u00b2) = \u221a2\n\nThis metric preserves multiplicative structure while enabling geometric reasoning.\n\nCan we use this distance to predict computational complexity of factorization algorithms?\n\n\n!! Tags\ndemo question sample_blockprimes blockprimes demo distance-metric number-theory follow-up complexity",
    "tags": "demo question sample_blockprimes blockprimes demo distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912817",
    "modified": "20250802082912817",
    "summary": "For numbers m = \u220fp\u1d62^a\u1d62 and n = \u220fp\u1d62^b\u1d62, the Euclidean distance is: d_E(m,n) = \u221a(\u2211(a\u1d62 - b\u1d62)\u00b2) **Demo**: Let m = 12 = 2\u00b2 \u00d7 3\u00b9 and n = 18 = 2\u00b9 \u00d7 3\u00b2. Then: - Coordinates: m \u2192 (2,1), n \u2192 (1,2)   - Distance: d_E(12,18) = \u221a((2-1)\u00b2 + (1-2)\u00b2) = \u221a2 This metric preserves multiplicative structure while enabling geometric reasoning. Can we use this distance to predict computational complexity of factorization algorithms?",
    "key_concepts": "metric, factorization, d_E, complexity, distance, Distance, Demo",
    "question_count": 1,
    "has_proof": false,
    "has_demo": true,
    "complexity_level": "basic"
  },
  {
    "title": "sample_blockprimes: Manhattan Distance",
    "text": "!! Summary\nThe L\u00b9 distance captures additive complexity: d_M(m,n) = \u2211|a\u1d62 - b\u1d62| **Example**: For the same m=12, n=18: d_M(12,18) = |2-1| + |1-2| = 2 **Theorem**: Manhattan distance in prime space equals the minimum number of prime factor modifications to transform m into n. **Proof**: Each unit of Manhattan distance corresponds to incrementing or decrementing a single prime power by 1. How does this relate to edit distance in computational strings?\n\n!! Key Concepts\ncomplexity, distance, prime, Example, d_M, Distance, Theorem, Proof\n\n!! Content\n### Manhattan Distance\nThe L\u00b9 distance captures additive complexity:\nd_M(m,n) = \u2211|a\u1d62 - b\u1d62|\n\n**Example**: For the same m=12, n=18:\nd_M(12,18) = |2-1| + |1-2| = 2\n\n**Theorem**: Manhattan distance in prime space equals the minimum number of prime factor modifications to transform m into n.\n\n**Proof**: Each unit of Manhattan distance corresponds to incrementing or decrementing a single prime power by 1.\n\nHow does this relate to edit distance in computational strings?\n\n\n!! Tags\nproof demo question sample_blockprimes blockprimes proof demo distance-metric number-theory follow-up complexity",
    "tags": "proof demo question sample_blockprimes blockprimes proof demo distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912817",
    "modified": "20250802082912817",
    "summary": "The L\u00b9 distance captures additive complexity: d_M(m,n) = \u2211|a\u1d62 - b\u1d62| **Example**: For the same m=12, n=18: d_M(12,18) = |2-1| + |1-2| = 2 **Theorem**: Manhattan distance in prime space equals the minimum number of prime factor modifications to transform m into n. **Proof**: Each unit of Manhattan distance corresponds to incrementing or decrementing a single prime power by 1. How does this relate to edit distance in computational strings?",
    "key_concepts": "complexity, distance, prime, Example, d_M, Distance, Theorem, Proof",
    "question_count": 1,
    "has_proof": true,
    "has_demo": true,
    "complexity_level": "intermediate"
  },
  {
    "title": "sample_blockprimes: Computational Shortcuts via Distance",
    "text": "!! Summary\n\n\n!! Key Concepts\nDistance\n\n!! Content\n## Computational Shortcuts via Distance\n\n\n!! Tags\nsample_blockprimes blockprimes",
    "tags": "sample_blockprimes blockprimes",
    "type": "text/x-markdown",
    "created": "20250802082912817",
    "modified": "20250802082912817",
    "summary": "",
    "key_concepts": "Distance",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "basic"
  },
  {
    "title": "sample_blockprimes: Pattern Recognition",
    "text": "!! Summary\nNumbers with small mutual distances often share computational properties: **Demo**: Consider the sequence 8, 12, 18, 24: - 8 = 2\u00b3 \u2192 (3,0) - 12 = 2\u00b2 \u00d7 3\u00b9 \u2192 (2,1)   - 18 = 2\u00b9 \u00d7 3\u00b2 \u2192 (1,2) - 24 = 2\u00b3 \u00d7 3\u00b9 \u2192 (3,1) The Manhattan distances form a pattern: d_M(8,12)=2, d_M(12,18)=2, d_M(18,24)=3. This suggests optimization strategies for batch factorization.\n\n!! Key Concepts\nfactorization, Demo, d_M\n\n!! Content\n### Pattern Recognition\nNumbers with small mutual distances often share computational properties:\n\n**Demo**: Consider the sequence 8, 12, 18, 24:\n- 8 = 2\u00b3 \u2192 (3,0)\n- 12 = 2\u00b2 \u00d7 3\u00b9 \u2192 (2,1)  \n- 18 = 2\u00b9 \u00d7 3\u00b2 \u2192 (1,2)\n- 24 = 2\u00b3 \u00d7 3\u00b9 \u2192 (3,1)\n\nThe Manhattan distances form a pattern: d_M(8,12)=2, d_M(12,18)=2, d_M(18,24)=3.\n\nThis suggests optimization strategies for batch factorization.\n\n\n!! Tags\ndemo sample_blockprimes blockprimes demo distance-metric number-theory",
    "tags": "demo sample_blockprimes blockprimes demo distance-metric number-theory",
    "type": "text/x-markdown",
    "created": "20250802082912817",
    "modified": "20250802082912817",
    "summary": "Numbers with small mutual distances often share computational properties: **Demo**: Consider the sequence 8, 12, 18, 24: - 8 = 2\u00b3 \u2192 (3,0) - 12 = 2\u00b2 \u00d7 3\u00b9 \u2192 (2,1)   - 18 = 2\u00b9 \u00d7 3\u00b2 \u2192 (1,2) - 24 = 2\u00b3 \u00d7 3\u00b9 \u2192 (3,1) The Manhattan distances form a pattern: d_M(8,12)=2, d_M(12,18)=2, d_M(18,24)=3. This suggests optimization strategies for batch factorization.",
    "key_concepts": "factorization, Demo, d_M",
    "question_count": 0,
    "has_proof": false,
    "has_demo": true,
    "complexity_level": "basic"
  },
  {
    "title": "sample_blockprimes: Compression Through Distance",
    "text": "!! Summary\nInstead of storing full factorizations, we can encode: 1. A reference point (anchor factorization) 2. Distance vectors to nearby numbers **Algorithm**:  ``` function encode_block(numbers):     anchor = geometric_median(numbers)     return [anchor, [distance_vector(n, anchor) for n in numbers]] ``` What is the compression ratio compared to naive storage?\n\n!! Key Concepts\nfactorization, Distance, Algorithm\n\n!! Content\n### Compression Through Distance\nInstead of storing full factorizations, we can encode:\n1. A reference point (anchor factorization)\n2. Distance vectors to nearby numbers\n\n**Algorithm**: \n```\nfunction encode_block(numbers):\n    anchor = geometric_median(numbers)\n    return [anchor, [distance_vector(n, anchor) for n in numbers]]\n```\n\nWhat is the compression ratio compared to naive storage?\n\n\n!! Tags\nquestion code sample_blockprimes blockprimes algorithm distance-metric number-theory follow-up complexity",
    "tags": "question code sample_blockprimes blockprimes algorithm distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912818",
    "modified": "20250802082912818",
    "summary": "Instead of storing full factorizations, we can encode: 1. A reference point (anchor factorization) 2. Distance vectors to nearby numbers **Algorithm**:  ``` function encode_block(numbers):     anchor = geometric_median(numbers)     return [anchor, [distance_vector(n, anchor) for n in numbers]] ``` What is the compression ratio compared to naive storage?",
    "key_concepts": "factorization, Distance, Algorithm",
    "question_count": 1,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "intermediate"
  },
  {
    "title": "sample_blockprimes: Applications to Cryptography",
    "text": "!! Summary\n\n\n!! Key Concepts\n\n\n!! Content\n## Applications to Cryptography\n\n\n!! Tags\nsample_blockprimes blockprimes security",
    "tags": "sample_blockprimes blockprimes security",
    "type": "text/x-markdown",
    "created": "20250802082912818",
    "modified": "20250802082912818",
    "summary": "",
    "key_concepts": "",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "advanced"
  },
  {
    "title": "sample_blockprimes: RSA Key Distance Analysis",
    "text": "!! Summary\nFor RSA moduli N\u2081 = p\u2081q\u2081 and N\u2082 = p\u2082q\u2082, the distance d(N\u2081,N\u2082) reveals structural similarity. **Security Implication**: If d(N\u2081,N\u2082) < threshold, the keys may share vulnerabilities. **Proof Sketch**: Close distances imply similar prime structures, potentially enabling cross-key attacks through shared factorization shortcuts. **Example**: If N\u2081 = 77 = 7\u00d711 and N\u2082 = 91 = 7\u00d713, they share the prime 7, leading to gcd(N\u2081,N\u2082) = 7. Could we develop distance-based RSA key validation?\n\n!! Key Concepts\nfactorization, Security Implication, distance, prime, Example, Distance, Proof, Proof Sketch\n\n!! Content\n### RSA Key Distance Analysis\nFor RSA moduli N\u2081 = p\u2081q\u2081 and N\u2082 = p\u2082q\u2082, the distance d(N\u2081,N\u2082) reveals structural similarity.\n\n**Security Implication**: If d(N\u2081,N\u2082) < threshold, the keys may share vulnerabilities.\n\n**Proof Sketch**: Close distances imply similar prime structures, potentially enabling cross-key attacks through shared factorization shortcuts.\n\n**Example**: If N\u2081 = 77 = 7\u00d711 and N\u2082 = 91 = 7\u00d713, they share the prime 7, leading to gcd(N\u2081,N\u2082) = 7.\n\nCould we develop distance-based RSA key validation?\n\n\n!! Tags\nproof demo question sample_blockprimes blockprimes demo security distance-metric number-theory follow-up",
    "tags": "proof demo question sample_blockprimes blockprimes demo security distance-metric number-theory follow-up",
    "type": "text/x-markdown",
    "created": "20250802082912818",
    "modified": "20250802082912818",
    "summary": "For RSA moduli N\u2081 = p\u2081q\u2081 and N\u2082 = p\u2082q\u2082, the distance d(N\u2081,N\u2082) reveals structural similarity. **Security Implication**: If d(N\u2081,N\u2082) < threshold, the keys may share vulnerabilities. **Proof Sketch**: Close distances imply similar prime structures, potentially enabling cross-key attacks through shared factorization shortcuts. **Example**: If N\u2081 = 77 = 7\u00d711 and N\u2082 = 91 = 7\u00d713, they share the prime 7, leading to gcd(N\u2081,N\u2082) = 7. Could we develop distance-based RSA key validation?",
    "key_concepts": "factorization, Security Implication, distance, prime, Example, Distance, Proof, Proof Sketch",
    "question_count": 1,
    "has_proof": true,
    "has_demo": true,
    "complexity_level": "basic"
  },
  {
    "title": "sample_blockprimes: Fermat Number Connections",
    "text": "!! Summary\n\n\n!! Key Concepts\n\n\n!! Content\n## Fermat Number Connections\n\n\n!! Tags\nsample_blockprimes blockprimes number-theory",
    "tags": "sample_blockprimes blockprimes number-theory",
    "type": "text/x-markdown",
    "created": "20250802082912818",
    "modified": "20250802082912818",
    "summary": "",
    "key_concepts": "",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "basic"
  },
  {
    "title": "sample_blockprimes: Distance to Fermat Numbers",
    "text": "!! Summary\nFermat numbers F\u2099 = 2^(2\u207f) + 1 serve as reference points in prime space. **Observation**: Numbers near Fermat numbers in distance metric often exhibit special properties. **Demo**: F\u2080 = 3, F\u2081 = 5, F\u2082 = 17, F\u2083 = 257 Distance analysis reveals clustering around powers of 2. **Open Question**: Does proximity to Fermat numbers predict primality testing efficiency?\n\n!! Key Concepts\nmetric, Observation, Open Question, distance, prime, Distance, Demo\n\n!! Content\n### Distance to Fermat Numbers\nFermat numbers F\u2099 = 2^(2\u207f) + 1 serve as reference points in prime space.\n\n**Observation**: Numbers near Fermat numbers in distance metric often exhibit special properties.\n\n**Demo**: F\u2080 = 3, F\u2081 = 5, F\u2082 = 17, F\u2083 = 257\nDistance analysis reveals clustering around powers of 2.\n\n**Open Question**: Does proximity to Fermat numbers predict primality testing efficiency?\n\n\n!! Tags\ndemo question sample_blockprimes blockprimes demo distance-metric number-theory follow-up",
    "tags": "demo question sample_blockprimes blockprimes demo distance-metric number-theory follow-up",
    "type": "text/x-markdown",
    "created": "20250802082912818",
    "modified": "20250802082912818",
    "summary": "Fermat numbers F\u2099 = 2^(2\u207f) + 1 serve as reference points in prime space. **Observation**: Numbers near Fermat numbers in distance metric often exhibit special properties. **Demo**: F\u2080 = 3, F\u2081 = 5, F\u2082 = 17, F\u2083 = 257 Distance analysis reveals clustering around powers of 2. **Open Question**: Does proximity to Fermat numbers predict primality testing efficiency?",
    "key_concepts": "metric, Observation, Open Question, distance, prime, Distance, Demo",
    "question_count": 1,
    "has_proof": false,
    "has_demo": true,
    "complexity_level": "basic"
  },
  {
    "title": "sample_blockprimes: Computational Implications",
    "text": "!! Summary\nThe distance metric enables: 1. Predictive complexity analysis 2. Optimized factorization routes   3. Compression of mathematical objects 4. Pattern discovery in number sequences **Research Direction**: Can we extend this framework to algebraic integers and other mathematical structures?\n\n!! Key Concepts\nmetric, factorization, complexity, distance, Research Direction\n\n!! Content\n### Computational Implications\nThe distance metric enables:\n1. Predictive complexity analysis\n2. Optimized factorization routes  \n3. Compression of mathematical objects\n4. Pattern discovery in number sequences\n\n**Research Direction**: Can we extend this framework to algebraic integers and other mathematical structures?\n\n\n!! Tags\nquestion sample_blockprimes blockprimes distance-metric number-theory follow-up complexity",
    "tags": "question sample_blockprimes blockprimes distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912818",
    "modified": "20250802082912818",
    "summary": "The distance metric enables: 1. Predictive complexity analysis 2. Optimized factorization routes   3. Compression of mathematical objects 4. Pattern discovery in number sequences **Research Direction**: Can we extend this framework to algebraic integers and other mathematical structures?",
    "key_concepts": "metric, factorization, complexity, distance, Research Direction",
    "question_count": 1,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "advanced"
  },
  {
    "title": "sample_blockprimes: Conclusion",
    "text": "!! Summary\nBlock prime distance metrics transform discrete number theory into continuous geometric optimization. This enables new computational shortcuts and reveals hidden patterns in mathematical structures. **Future Work**: Investigate distance-preserving transformations and their impact on algorithmic complexity. How might quantum computing change these distance relationships?\n\n!! Key Concepts\ndistance, Future Work, prime, complexity\n\n!! Content\n## Conclusion\n\nBlock prime distance metrics transform discrete number theory into continuous geometric optimization. This enables new computational shortcuts and reveals hidden patterns in mathematical structures.\n\n**Future Work**: Investigate distance-preserving transformations and their impact on algorithmic complexity.\n\nHow might quantum computing change these distance relationships?\n\n!! Tags\nquestion sample_blockprimes blockprimes distance-metric number-theory follow-up complexity",
    "tags": "question sample_blockprimes blockprimes distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912818",
    "modified": "20250802082912818",
    "summary": "Block prime distance metrics transform discrete number theory into continuous geometric optimization. This enables new computational shortcuts and reveals hidden patterns in mathematical structures. **Future Work**: Investigate distance-preserving transformations and their impact on algorithmic complexity. How might quantum computing change these distance relationships?",
    "key_concepts": "distance, Future Work, prime, complexity",
    "question_count": 1,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "intermediate"
  },
  {
    "title": "compression",
    "text": "\"\"\"\nAdvanced compression system for TiddlyWiki compiler\nIntegrates with aemergent codec system for distance-metric based compression\n\"\"\"\n\nimport sys\nimport os\nfrom pathlib import Path\nimport re\nfrom typing import Dict, List, Tuple, Any\n\n# Add aemergent to path if available\nif Path(\"../aemergent\").exists():\n    sys.path.append(str(Path(\"../aemergent\").resolve()))\n\ntry:\n    from aemergent.codec_system import CodecSystem\n    from aemergent.combit import Combit\n    from aemergent.pascell import Pascell\n    AEMERGENT_AVAILABLE = True\nexcept ImportError:\n    AEMERGENT_AVAILABLE = False\n\n\nclass DistanceMetricCompressor:\n    \"\"\"Distance-metric based compressor using blockprimes-style comp repr\"\"\"\n    \n    def __init__(self):\n        self.pattern_cache = {}\n        self.distance_cache = {}\n        \n        # math pattern templates\n        self.math_patterns = {\n            \"prime_sequence\": r\"2,\\s*3,\\s*5,\\s*7,\\s*11\",\n            \"fibonacci\": r\"1,\\s*1,\\s*2,\\s*3,\\s*5,\\s*8\",\n            \"factorial\": r\"1,\\s*2,\\s*6,\\s*24,\\s*120\",\n            \"powers_of_2\": r\"1,\\s*2,\\s*4,\\s*8,\\s*16\",\n            \"powers_of_3\": r\"1,\\s*3,\\s*9,\\s*27,\\s*81\"\n        }\n        \n        # Computational distance representations\n        self.distance_encodings = {\n            \"linear_growth\": \"L\",\n            \"exponential_growth\": \"E\", \n            \"logarithmic_growth\": \"G\",\n            \"polynomial_growth\": \"P\",\n            \"prime_distribution\": \"R\",\n            \"recursive_pattern\": \"X\"\n        }\n        \n    def compute_pattern_distance(self, text: str) -> Dict[str, float]:\n        \"\"\"Compute distances to various math/computational patterns\"\"\"\n        distances = {}\n        \n        # Check for math sequences\n        for pattern_name, pattern_regex in self.math_patterns.items():\n            matches = re.findall(pattern_regex, text)\n            if matches:\n                # Distance inversely proportional to number of matches\n                distances[pattern_name] = 1.0 / (len(matches) + 1)\n            else:\n                distances[pattern_name] = 1.0\n        \n        # Check for computational complexity patterns\n        if re.search(r'O\\([n\\^2]+\\)', text):\n            distances[\"quadratic_complexity\"] = 0.2\n        elif re.search(r'O\\(n\\s*log\\s*n\\)', text):\n            distances[\"linearithmic_complexity\"] = 0.3\n        elif re.search(r'O\\(n\\)', text):\n            distances[\"linear_complexity\"] = 0.1\n            \n        # Check for proof structures\n        if re.search(r'assume|suppose|given|therefore|thus|hence', text, re.IGNORECASE):\n            distances[\"proof_structure\"] = 0.1\n            \n        return distances\n    \n    def encode_via_distances(self, text: str) -> str:\n        \"\"\"Encode text using distance metrics to computational patterns\"\"\"\n        distances = self.compute_pattern_distance(text)\n        \n        # Create compact repr\n        encoding_parts = []\n        \n        # Sort by distance (closest patterns first)\n        sorted_distances = sorted(distances.items(), key=lambda x: x[1])\n        \n        for pattern, distance in sorted_distances[:3]:  # Top 3 closest patterns\n            # Convert distance to compact repr\n            distance_code = int(distance * 100)  # 0-100 scale\n            encoding_parts.append(f\"{pattern[:2]}{distance_code:02d}\")\n        \n        # Add length indicator\n        length_code = min(len(text) // 10, 99)\n        encoding_parts.append(f\"L{length_code:02d}\")\n        \n        compressed_header = \"|\".join(encoding_parts)\n        \n        # Apply basic text compression\n        compressed_text = self.compress_text_content(text)\n        \n        return f\"[DIST:{compressed_header}]{compressed_text}\"\n    \n    def compress_text_content(self, text: str) -> str:\n        \"\"\"Apply content-aware text compression\"\"\"\n        # Common math/technical term abbreviations\n        abbreviations = {\n            \"comp\": \"comp\",\n            \"algo\": \"algo\", \n            \"func\": \"func\",\n            \"variable\": \"var\",\n            \"parameter\": \"param\",\n            \"theorem\": \"thm\",\n            \"proposition\": \"prop\",\n            \"corollary\": \"cor\",\n            \"definition\": \"def\",\n            \"example\": \"ex\",\n            \"demonstration\": \"demo\",\n            \"therefore\": \"\u2234\",\n            \"because\": \"\u2235\",\n            \"approximately\": \"\u2248\",\n            \"equivalent\": \"\u2261\"\n        }\n        \n        compressed = text\n        for full_term, abbrev in abbreviations.items():\n            compressed = re.sub(r'\\b' + full_term + r'\\b', abbrev, compressed, flags=re.IGNORECASE)\n        \n        # Compress repeated whitespace\n        compressed = re.sub(r'\\s+', ' ', compressed)\n        \n        return compressed\n\n\nclass AemergentCompressor:\n    \"\"\"Compression using the aemergent codec system\"\"\"\n    \n    def __init__(self):\n        self.available = AEMERGENT_AVAILABLE\n        if self.available:\n            self.codec_system = CodecSystem()\n            \n    def compress(self, text: str) -> str:\n        \"\"\"Compress text using aemergent codecs\"\"\"\n        if not self.available:\n            return text\n            \n        try:\n            # Convert text to numeric repr for codec processing\n            numeric_data = [ord(c) for c in text]\n            \n            # Use Combit for bit-level compression\n            combit = Combit()\n            compressed_bits = combit.compress_sequence(numeric_data)\n            \n            # Encode result\n            return f\"[AEMERGENT:{len(compressed_bits)}]{compressed_bits}\"\n            \n        except Exception as e:\n            print(f\"Aemergent compression failed: {e}\")\n            return text\n\n\nclass HybridCompressor:\n    \"\"\"Hybrid compression combining distance metrics and aemergent codecs\"\"\"\n    \n    def __init__(self):\n        self.distance_compressor = DistanceMetricCompressor()\n        self.aemergent_compressor = AemergentCompressor()\n        \n    def compress(self, text: str, prefer_distance_metrics: bool = True) -> str:\n        \"\"\"Apply hybrid compression strategy\"\"\"\n        \n        # Try distance metric compression first\n        distance_result = self.distance_compressor.encode_via_distances(text)\n        \n        # Try aemergent compression\n        aemergent_result = self.aemergent_compressor.compress(text)\n        \n        # Choose best compression\n        if prefer_distance_metrics:\n            return distance_result\n        else:\n            # Choose based on compression ratio\n            if len(aemergent_result) < len(distance_result):\n                return aemergent_result\n            else:\n                return distance_result\n    \n    def decompress(self, compressed_text: str) -> str:\n        \"\"\"Decompress text (basic implementation)\"\"\"\n        if compressed_text.startswith(\"[DIST:\"):\n            # Extract header and content\n            header_end = compressed_text.find(\"]\")\n            header = compressed_text[6:header_end]\n            content = compressed_text[header_end+1:]\n            \n            # Basic decompression (expand abbreviations)\n            decompressed = content.replace(\"comp\", \"comp\")\n            decompressed = decompressed.replace(\"algo\", \"algo\")\n            decompressed = decompressed.replace(\"func\", \"func\")\n            # ... (add reverse mappings for other abbreviations)\n            \n            return decompressed\n            \n        elif compressed_text.startswith(\"[AEMERGENT:\"):\n            # Aemergent decompression would be implemented here\n            return compressed_text\n            \n        else:\n            return compressed_text\n\n\ndef create_compressor(compression_type: str = \"hybrid\") -> Any:\n    \"\"\"Factory func to create appropriate compressor\"\"\"\n    if compression_type == \"distance\":\n        return DistanceMetricCompressor()\n    elif compression_type == \"aemergent\":\n        return AemergentCompressor()\n    else:\n        return HybridCompressor()",
    "tags": "mathematics proof demo code text py compressed",
    "type": "text/plain",
    "created": "20250802082912819",
    "modified": "20250802082912819"
  },
  {
    "title": "cli_test_wiki.html",
    "text": "PCFET0NUWVBFIGh0bWw+CjxodG1sPgo8aGVhZD4KPG1ldGEgY2hhcnNldD0idXRmLTgiPgo8dGl0bGU+Q29tcGlsZWQgV2lraTwvdGl0bGU+CjxzY3JpcHQ+CnZhciAkdHcgPSB7CiAgICBwcmVsb2FkVGlkZGxlcnM6IFsKICB7CiAgICAidGl0bGUiOiAiYWxnb3JpdGhtcyIsCiAgICAidGV4dCI6ICIjIFNhbXBsZSBhbGdvXG5kZWYgZmFjdG9yaWFsKG4pOlxuICAgIFwiXCJcIlxuICAgIENvbXB1dGUgZmFjdG9yaWFsIHVzaW5nIHJlY3Vyc2l2ZSBhbGdvXG4gICAgVGltZSBjb21wbGV4aXR5OiBPKG4pXG4gICAgU3BhY2UgY29tcGxleGl0eTogTyhuKSBkdWUgdG8gcmVjdXJzaW9uXG4gICAgXCJcIlwiXG4gICAgaWYgbiA8PSAxOlxuICAgICAgICByZXR1cm4gMVxuICAgIHJldHVybiBuICogZmFjdG9yaWFsKG4gLSAxKVxuXG5kZWYgZmlib25hY2NpKG4pOlxuICAgIFwiXCJcIlxuICAgIENvbXB1dGUgRmlib25hY2NpIG51bWJlclxuICAgIERlbW9uc3RyYXRlcyBleHBvbmVudGlhbCBncm93dGggcGF0dGVyblxuICAgIFwiXCJcIlxuICAgIGlmIG4gPD0gMTpcbiAgICAgICAgcmV0dXJuIG5cbiAgICByZXR1cm4gZmlib25hY2NpKG4tMSkgKyBmaWJvbmFjY2kobi0yKVxuXG4jIEV4YW1wbGUgdXNhZ2VcbnByaW50KGZcIjUhID0ge2ZhY3RvcmlhbCg1KX1cIilcbnByaW50KGZcIkYoMTApID0ge2ZpYm9uYWNjaSgxMCl9XCIpXG4iLAogICAgInRhZ3MiOiAiZGVtbyBjb2RlIHRleHQgcHkgY29tcHJlc3NlZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3BsYWluIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTUxNDA2IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTk1MTQwNiIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJpbnRyb2R1Y3Rpb24iLAogICAgInRleHQiOiAiIyBXZWxjb21lIHRvIHRoZSBtYXRoIFdpa2lcblxuVGhpcyB3aWtpIGRlbW9uc3RyYXRlcyB0aGUgVGlkZGx5V2lraSBjb21waWxlcidzIGFiaWxpdHkgdG8gc3RydWN0dXJlIGFuZCBvcmdhbml6ZSBtYXRoIGNvbnRlbnQuXG5cbiMjIEZlYXR1cmVzXG5cbi0gKipBdXRvbWF0aWMgdGFnZ2luZyoqIGJhc2VkIG9uIGNvbnRlbnQgcGF0dGVybnNcbi0gKipEaXN0YW5jZS1tZXRyaWMgY29tcHJlc3Npb24qKiB1c2luZyBibG9ja3ByaW1lcyBjb25jZXB0cyAgXG4tICoqU3RydWN0dXJlZCB0aWRkbGVycyoqIHdpdGggc3VtbWFyaWVzIGFuZCBrZXkgY29uY2VwdHNcbi0gKipJbnRlcmFjdGl2ZSBmaWx0ZXJpbmcqKiBieSB0YWdzIGFuZCBzZWFyY2hcblxuIyMgU2FtcGxlIENvbnRlbnRcblxuVGhlIGJsb2NrcHJpbWVzLm1kIGZpbGUgaGFzIGJlZW4gYXV0b21hdGljYWxseSBicm9rZW4gZG93biBpbnRvIG11bHRpcGxlIHRpZGRsZXJzLCBlYWNoIHdpdGg6XG4tIFN1bW1hcnkgc2VjdGlvbnNcbi0gS2V5IGNvbmNlcHQgZXh0cmFjdGlvblxuLSBBdXRvbWF0aWMgdGFnZ2luZyAocHJvb2YsIGRlbW8sIHF1ZXN0aW9uLCBldGMuKVxuLSBGb2xsb3ctdXAgcXVlc3Rpb24gZGV0ZWN0aW9uXG5cbioqRXhhbXBsZSoqOiBtYXRoIHByb29mcyBhcmUgYXV0b21hdGljYWxseSB0YWdnZWQgYXMgXCJwcm9vZlwiIGFuZCBmb3JtYXR0ZWQgd2l0aCBzcGVjaWFsIHN0eWxpbmcuXG5cbldoYXQgcGF0dGVybnMgd2lsbCB5b3UgZGlzY292ZXIgaW4geW91ciBvd24gY29udGVudD9cbiIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIHRleHQgbWQgY29tcHJlc3NlZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5NTE0MDYiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTUxNDA2IgogIH0sCiAgewogICAgInRpdGxlIjogImNvbmNlcHRzIiwKICAgICJ0ZXh0IjogIktleSBtYXRoIENvbmNlcHRzXG5cblByaW1lIE51bWJlcnM6IDIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjkuLi5cbkZpYm9uYWNjaSBTZXF1ZW5jZTogMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxLCAzNC4uLlxuRmFjdG9yaWFsczogMSwgMiwgNiwgMjQsIDEyMCwgNzIwLi4uXG5cbkRpc3RhbmNlIE1ldHJpY3M6XG4tIEV1Y2xpZGVhbjogZCh4LHkpID0gXHUyMjFhKFx1MDNhMyh4aS15aSlcdTAwYjIpXG4tIE1hbmhhdHRhbjogZCh4LHkpID0gXHUwM2EzfHhpLXlpfFxuLSBIYW1taW5nOiBudW1iZXIgb2YgZGlmZmVyaW5nIHBvc2l0aW9uc1xuXG5Db21wdXRhdGlvbmFsIENvbXBsZXhpdHk6XG4tIE8oMSk6IGNvbnN0YW50IHRpbWVcbi0gTyhsb2cgbik6IGxvZ2FyaXRobWljIFxuLSBPKG4pOiBsaW5lYXIgdGltZVxuLSBPKG4gbG9nIG4pOiBsaW5lYXJpdGhtaWNcbi0gTyhuXHUwMGIyKTogcXVhZHJhdGljIHRpbWVcblxuV2hhdCByZWxhdGlvbnNoaXBzIGV4aXN0IGJldHdlZW4gdGhlc2UgY29uY2VwdHM/XG4iLAogICAgInRhZ3MiOiAicXVlc3Rpb24gdGV4dCB0eHQgY29tcHJlc3NlZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3BsYWluIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTUxNDA2IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTk1MTQwNiIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogQmxvY2twcmltZXM6IENvbXB1dGF0aW9uYWwgRGlzdGFuY2UgTWV0cmljcyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5cblxuISEgS2V5IENvbmNlcHRzXG5EaXN0YW5jZVxuXG4hISBDb250ZW50XG4jIEJsb2NrcHJpbWVzOiBDb21wdXRhdGlvbmFsIERpc3RhbmNlIE1ldHJpY3NcblxuXG4hISBUYWdzXG5ibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBudW1iZXItdGhlb3J5IiwKICAgICJ0YWdzIjogImJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIG51bWJlci10aGVvcnkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTUxNDA3IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTk1MTQwNyIsCiAgICAic3VtbWFyeSI6ICIiLAogICAgImtleV9jb25jZXB0cyI6ICJEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogSW50cm9kdWN0aW9uIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy4gVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuICoqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLiBXaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/XG5cbiEhIEtleSBDb25jZXB0c1xuZmFjdG9yaXphdGlvbiwgUHJvb2YsIGRpc3RhbmNlLCBwcmltZSwgUHJvb2YgUGF0dGVyblxuXG4hISBDb250ZW50XG4jIyBJbnRyb2R1Y3Rpb25cbkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy5cblxuVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuXG5cbioqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLlxuXG5XaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/XG5cblxuISEgVGFnc1xucHJvb2YgcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0YWdzIjogInByb29mIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5NTE0MDciLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTUxNDA3IiwKICAgICJzdW1tYXJ5IjogIkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy4gVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuICoqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLiBXaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgUHJvb2YsIGRpc3RhbmNlLCBwcmltZSwgUHJvb2YgUGF0dGVybiIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IHRydWUsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImludGVybWVkaWF0ZSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogRGlzdGFuY2UgTWV0cmljcyBpbiBQcmltZSBTcGFjZSIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5cblxuISEgS2V5IENvbmNlcHRzXG5EaXN0YW5jZSwgUHJpbWVcblxuISEgQ29udGVudFxuIyMgRGlzdGFuY2UgTWV0cmljcyBpbiBQcmltZSBTcGFjZVxuXG5cbiEhIFRhZ3NcbmJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIG51bWJlci10aGVvcnkiLAogICAgInRhZ3MiOiAiYmxvY2twcmltZXMgYmxvY2twcmltZXMgbnVtYmVyLXRoZW9yeSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5NTE0MDciLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTUxNDA3IiwKICAgICJzdW1tYXJ5IjogIiIsCiAgICAia2V5X2NvbmNlcHRzIjogIkRpc3RhbmNlLCBQcmltZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogRXVjbGlkZWFuIERpc3RhbmNlIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkZvciBudW1iZXJzIG0gPSBcdTIyMGZwXHUxZDYyXmFcdTFkNjIgYW5kIG4gPSBcdTIyMGZwXHUxZDYyXmJcdTFkNjIsIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgaXM6IGRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpICoqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjogLSBDb29yZGluYXRlczogbSBcdTIxOTIgKDIsMSksIG4gXHUyMTkyICgxLDIpICAgLSBEaXN0YW5jZTogZF9FKDEyLDE4KSA9IFx1MjIxYSgoMi0xKVx1MDBiMiArICgxLTIpXHUwMGIyKSA9IFx1MjIxYTIgVGhpcyBtZXRyaWMgcHJlc2VydmVzIG11bHRpcGxpY2F0aXZlIHN0cnVjdHVyZSB3aGlsZSBlbmFibGluZyBnZW9tZXRyaWMgcmVhc29uaW5nLiBDYW4gd2UgdXNlIHRoaXMgZGlzdGFuY2UgdG8gcHJlZGljdCBjb21wdXRhdGlvbmFsIGNvbXBsZXhpdHkgb2YgZmFjdG9yaXphdGlvbiBhbGdvcml0aG1zP1xuXG4hISBLZXkgQ29uY2VwdHNcbmZhY3Rvcml6YXRpb24sIG1ldHJpYywgY29tcGxleGl0eSwgZF9FLCBEaXN0YW5jZSwgZGlzdGFuY2UsIERlbW9cblxuISEgQ29udGVudFxuIyMjIEV1Y2xpZGVhbiBEaXN0YW5jZVxuRm9yIG51bWJlcnMgbSA9IFx1MjIwZnBcdTFkNjJeYVx1MWQ2MiBhbmQgbiA9IFx1MjIwZnBcdTFkNjJeYlx1MWQ2MiwgdGhlIEV1Y2xpZGVhbiBkaXN0YW5jZSBpczpcbmRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpXG5cbioqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjpcbi0gQ29vcmRpbmF0ZXM6IG0gXHUyMTkyICgyLDEpLCBuIFx1MjE5MiAoMSwyKSAgXG4tIERpc3RhbmNlOiBkX0UoMTIsMTgpID0gXHUyMjFhKCgyLTEpXHUwMGIyICsgKDEtMilcdTAwYjIpID0gXHUyMjFhMlxuXG5UaGlzIG1ldHJpYyBwcmVzZXJ2ZXMgbXVsdGlwbGljYXRpdmUgc3RydWN0dXJlIHdoaWxlIGVuYWJsaW5nIGdlb21ldHJpYyByZWFzb25pbmcuXG5cbkNhbiB3ZSB1c2UgdGhpcyBkaXN0YW5jZSB0byBwcmVkaWN0IGNvbXB1dGF0aW9uYWwgY29tcGxleGl0eSBvZiBmYWN0b3JpemF0aW9uIGFsZ29yaXRobXM/XG5cblxuISEgVGFnc1xuZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0YWdzIjogImRlbW8gcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSBmb2xsb3ctdXAgY29tcGxleGl0eSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5NTE0MDciLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTUxNDA3IiwKICAgICJzdW1tYXJ5IjogIkZvciBudW1iZXJzIG0gPSBcdTIyMGZwXHUxZDYyXmFcdTFkNjIgYW5kIG4gPSBcdTIyMGZwXHUxZDYyXmJcdTFkNjIsIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgaXM6IGRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpICoqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjogLSBDb29yZGluYXRlczogbSBcdTIxOTIgKDIsMSksIG4gXHUyMTkyICgxLDIpICAgLSBEaXN0YW5jZTogZF9FKDEyLDE4KSA9IFx1MjIxYSgoMi0xKVx1MDBiMiArICgxLTIpXHUwMGIyKSA9IFx1MjIxYTIgVGhpcyBtZXRyaWMgcHJlc2VydmVzIG11bHRpcGxpY2F0aXZlIHN0cnVjdHVyZSB3aGlsZSBlbmFibGluZyBnZW9tZXRyaWMgcmVhc29uaW5nLiBDYW4gd2UgdXNlIHRoaXMgZGlzdGFuY2UgdG8gcHJlZGljdCBjb21wdXRhdGlvbmFsIGNvbXBsZXhpdHkgb2YgZmFjdG9yaXphdGlvbiBhbGdvcml0aG1zPyIsCiAgICAia2V5X2NvbmNlcHRzIjogImZhY3Rvcml6YXRpb24sIG1ldHJpYywgY29tcGxleGl0eSwgZF9FLCBEaXN0YW5jZSwgZGlzdGFuY2UsIERlbW8iLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiBmYWxzZSwKICAgICJoYXNfZGVtbyI6IHRydWUsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogTWFuaGF0dGFuIERpc3RhbmNlIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcblRoZSBMXHUwMGI5IGRpc3RhbmNlIGNhcHR1cmVzIGFkZGl0aXZlIGNvbXBsZXhpdHk6IGRfTShtLG4pID0gXHUyMjExfGFcdTFkNjIgLSBiXHUxZDYyfCAqKkV4YW1wbGUqKjogRm9yIHRoZSBzYW1lIG09MTIsIG49MTg6IGRfTSgxMiwxOCkgPSB8Mi0xfCArIHwxLTJ8ID0gMiAqKlRoZW9yZW0qKjogTWFuaGF0dGFuIGRpc3RhbmNlIGluIHByaW1lIHNwYWNlIGVxdWFscyB0aGUgbWluaW11bSBudW1iZXIgb2YgcHJpbWUgZmFjdG9yIG1vZGlmaWNhdGlvbnMgdG8gdHJhbnNmb3JtIG0gaW50byBuLiAqKlByb29mKio6IEVhY2ggdW5pdCBvZiBNYW5oYXR0YW4gZGlzdGFuY2UgY29ycmVzcG9uZHMgdG8gaW5jcmVtZW50aW5nIG9yIGRlY3JlbWVudGluZyBhIHNpbmdsZSBwcmltZSBwb3dlciBieSAxLiBIb3cgZG9lcyB0aGlzIHJlbGF0ZSB0byBlZGl0IGRpc3RhbmNlIGluIGNvbXB1dGF0aW9uYWwgc3RyaW5ncz9cblxuISEgS2V5IENvbmNlcHRzXG5Qcm9vZiwgY29tcGxleGl0eSwgRGlzdGFuY2UsIFRoZW9yZW0sIGRfTSwgZGlzdGFuY2UsIHByaW1lLCBFeGFtcGxlXG5cbiEhIENvbnRlbnRcbiMjIyBNYW5oYXR0YW4gRGlzdGFuY2VcblRoZSBMXHUwMGI5IGRpc3RhbmNlIGNhcHR1cmVzIGFkZGl0aXZlIGNvbXBsZXhpdHk6XG5kX00obSxuKSA9IFx1MjIxMXxhXHUxZDYyIC0gYlx1MWQ2MnxcblxuKipFeGFtcGxlKio6IEZvciB0aGUgc2FtZSBtPTEyLCBuPTE4OlxuZF9NKDEyLDE4KSA9IHwyLTF8ICsgfDEtMnwgPSAyXG5cbioqVGhlb3JlbSoqOiBNYW5oYXR0YW4gZGlzdGFuY2UgaW4gcHJpbWUgc3BhY2UgZXF1YWxzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBwcmltZSBmYWN0b3IgbW9kaWZpY2F0aW9ucyB0byB0cmFuc2Zvcm0gbSBpbnRvIG4uXG5cbioqUHJvb2YqKjogRWFjaCB1bml0IG9mIE1hbmhhdHRhbiBkaXN0YW5jZSBjb3JyZXNwb25kcyB0byBpbmNyZW1lbnRpbmcgb3IgZGVjcmVtZW50aW5nIGEgc2luZ2xlIHByaW1lIHBvd2VyIGJ5IDEuXG5cbkhvdyBkb2VzIHRoaXMgcmVsYXRlIHRvIGVkaXQgZGlzdGFuY2UgaW4gY29tcHV0YXRpb25hbCBzdHJpbmdzP1xuXG5cbiEhIFRhZ3NcbnByb29mIGRlbW8gcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgcHJvb2YgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSBmb2xsb3ctdXAgY29tcGxleGl0eSIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIHByb29mIGRlbW8gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTUxNDA4IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTk1MTQwOCIsCiAgICAic3VtbWFyeSI6ICJUaGUgTFx1MDBiOSBkaXN0YW5jZSBjYXB0dXJlcyBhZGRpdGl2ZSBjb21wbGV4aXR5OiBkX00obSxuKSA9IFx1MjIxMXxhXHUxZDYyIC0gYlx1MWQ2MnwgKipFeGFtcGxlKio6IEZvciB0aGUgc2FtZSBtPTEyLCBuPTE4OiBkX00oMTIsMTgpID0gfDItMXwgKyB8MS0yfCA9IDIgKipUaGVvcmVtKio6IE1hbmhhdHRhbiBkaXN0YW5jZSBpbiBwcmltZSBzcGFjZSBlcXVhbHMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHByaW1lIGZhY3RvciBtb2RpZmljYXRpb25zIHRvIHRyYW5zZm9ybSBtIGludG8gbi4gKipQcm9vZioqOiBFYWNoIHVuaXQgb2YgTWFuaGF0dGFuIGRpc3RhbmNlIGNvcnJlc3BvbmRzIHRvIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgYSBzaW5nbGUgcHJpbWUgcG93ZXIgYnkgMS4gSG93IGRvZXMgdGhpcyByZWxhdGUgdG8gZWRpdCBkaXN0YW5jZSBpbiBjb21wdXRhdGlvbmFsIHN0cmluZ3M/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiUHJvb2YsIGNvbXBsZXhpdHksIERpc3RhbmNlLCBUaGVvcmVtLCBkX00sIGRpc3RhbmNlLCBwcmltZSwgRXhhbXBsZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IHRydWUsCiAgICAiaGFzX2RlbW8iOiB0cnVlLAogICAgImNvbXBsZXhpdHlfbGV2ZWwiOiAiaW50ZXJtZWRpYXRlIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBDb21wdXRhdGlvbmFsIFNob3J0Y3V0cyB2aWEgRGlzdGFuY2UiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuXG5cbiEhIEtleSBDb25jZXB0c1xuRGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMgQ29tcHV0YXRpb25hbCBTaG9ydGN1dHMgdmlhIERpc3RhbmNlXG5cblxuISEgVGFnc1xuYmxvY2twcmltZXMgYmxvY2twcmltZXMiLAogICAgInRhZ3MiOiAiYmxvY2twcmltZXMgYmxvY2twcmltZXMiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTUxNDA4IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTk1MTQwOCIsCiAgICAic3VtbWFyeSI6ICIiLAogICAgImtleV9jb25jZXB0cyI6ICJEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogUGF0dGVybiBSZWNvZ25pdGlvbiIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5OdW1iZXJzIHdpdGggc21hbGwgbXV0dWFsIGRpc3RhbmNlcyBvZnRlbiBzaGFyZSBjb21wdXRhdGlvbmFsIHByb3BlcnRpZXM6ICoqRGVtbyoqOiBDb25zaWRlciB0aGUgc2VxdWVuY2UgOCwgMTIsIDE4LCAyNDogLSA4ID0gMlx1MDBiMyBcdTIxOTIgKDMsMCkgLSAxMiA9IDJcdTAwYjIgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgyLDEpICAgLSAxOCA9IDJcdTAwYjkgXHUwMGQ3IDNcdTAwYjIgXHUyMTkyICgxLDIpIC0gMjQgPSAyXHUwMGIzIFx1MDBkNyAzXHUwMGI5IFx1MjE5MiAoMywxKSBUaGUgTWFuaGF0dGFuIGRpc3RhbmNlcyBmb3JtIGEgcGF0dGVybjogZF9NKDgsMTIpPTIsIGRfTSgxMiwxOCk9MiwgZF9NKDE4LDI0KT0zLiBUaGlzIHN1Z2dlc3RzIG9wdGltaXphdGlvbiBzdHJhdGVnaWVzIGZvciBiYXRjaCBmYWN0b3JpemF0aW9uLlxuXG4hISBLZXkgQ29uY2VwdHNcbmZhY3Rvcml6YXRpb24sIERlbW8sIGRfTVxuXG4hISBDb250ZW50XG4jIyMgUGF0dGVybiBSZWNvZ25pdGlvblxuTnVtYmVycyB3aXRoIHNtYWxsIG11dHVhbCBkaXN0YW5jZXMgb2Z0ZW4gc2hhcmUgY29tcHV0YXRpb25hbCBwcm9wZXJ0aWVzOlxuXG4qKkRlbW8qKjogQ29uc2lkZXIgdGhlIHNlcXVlbmNlIDgsIDEyLCAxOCwgMjQ6XG4tIDggPSAyXHUwMGIzIFx1MjE5MiAoMywwKVxuLSAxMiA9IDJcdTAwYjIgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgyLDEpICBcbi0gMTggPSAyXHUwMGI5IFx1MDBkNyAzXHUwMGIyIFx1MjE5MiAoMSwyKVxuLSAyNCA9IDJcdTAwYjMgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgzLDEpXG5cblRoZSBNYW5oYXR0YW4gZGlzdGFuY2VzIGZvcm0gYSBwYXR0ZXJuOiBkX00oOCwxMik9MiwgZF9NKDEyLDE4KT0yLCBkX00oMTgsMjQpPTMuXG5cblRoaXMgc3VnZ2VzdHMgb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXMgZm9yIGJhdGNoIGZhY3Rvcml6YXRpb24uXG5cblxuISEgVGFnc1xuZGVtbyBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IiwKICAgICJ0YWdzIjogImRlbW8gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5NTE0MDgiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTUxNDA4IiwKICAgICJzdW1tYXJ5IjogIk51bWJlcnMgd2l0aCBzbWFsbCBtdXR1YWwgZGlzdGFuY2VzIG9mdGVuIHNoYXJlIGNvbXB1dGF0aW9uYWwgcHJvcGVydGllczogKipEZW1vKio6IENvbnNpZGVyIHRoZSBzZXF1ZW5jZSA4LCAxMiwgMTgsIDI0OiAtIDggPSAyXHUwMGIzIFx1MjE5MiAoMywwKSAtIDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBcdTIxOTIgKDIsMSkgICAtIDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMiBcdTIxOTIgKDEsMikgLSAyNCA9IDJcdTAwYjMgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgzLDEpIFRoZSBNYW5oYXR0YW4gZGlzdGFuY2VzIGZvcm0gYSBwYXR0ZXJuOiBkX00oOCwxMik9MiwgZF9NKDEyLDE4KT0yLCBkX00oMTgsMjQpPTMuIFRoaXMgc3VnZ2VzdHMgb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXMgZm9yIGJhdGNoIGZhY3Rvcml6YXRpb24uIiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgRGVtbywgZF9NIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDAsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiB0cnVlLAogICAgImNvbXBsZXhpdHlfbGV2ZWwiOiAiYmFzaWMiCiAgfSwKICB7CiAgICAidGl0bGUiOiAiYmxvY2twcmltZXM6IENvbXByZXNzaW9uIFRocm91Z2ggRGlzdGFuY2UiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuSW5zdGVhZCBvZiBzdG9yaW5nIGZ1bGwgZmFjdG9yaXphdGlvbnMsIHdlIGNhbiBlbmNvZGU6IDEuIEEgcmVmZXJlbmNlIHBvaW50IChhbmNob3IgZmFjdG9yaXphdGlvbikgMi4gRGlzdGFuY2UgdmVjdG9ycyB0byBuZWFyYnkgbnVtYmVycyAqKkFsZ29yaXRobSoqOiAgYGBgIGZ1bmN0aW9uIGVuY29kZV9ibG9jayhudW1iZXJzKTogICAgIGFuY2hvciA9IGdlb21ldHJpY19tZWRpYW4obnVtYmVycykgICAgIHJldHVybiBbYW5jaG9yLCBbZGlzdGFuY2VfdmVjdG9yKG4sIGFuY2hvcikgZm9yIG4gaW4gbnVtYmVyc11dIGBgYCBXaGF0IGlzIHRoZSBjb21wcmVzc2lvbiByYXRpbyBjb21wYXJlZCB0byBuYWl2ZSBzdG9yYWdlP1xuXG4hISBLZXkgQ29uY2VwdHNcbmZhY3Rvcml6YXRpb24sIERpc3RhbmNlLCBBbGdvcml0aG1cblxuISEgQ29udGVudFxuIyMjIENvbXByZXNzaW9uIFRocm91Z2ggRGlzdGFuY2Vcbkluc3RlYWQgb2Ygc3RvcmluZyBmdWxsIGZhY3Rvcml6YXRpb25zLCB3ZSBjYW4gZW5jb2RlOlxuMS4gQSByZWZlcmVuY2UgcG9pbnQgKGFuY2hvciBmYWN0b3JpemF0aW9uKVxuMi4gRGlzdGFuY2UgdmVjdG9ycyB0byBuZWFyYnkgbnVtYmVyc1xuXG4qKkFsZ29yaXRobSoqOiBcbmBgYFxuZnVuY3Rpb24gZW5jb2RlX2Jsb2NrKG51bWJlcnMpOlxuICAgIGFuY2hvciA9IGdlb21ldHJpY19tZWRpYW4obnVtYmVycylcbiAgICByZXR1cm4gW2FuY2hvciwgW2Rpc3RhbmNlX3ZlY3RvcihuLCBhbmNob3IpIGZvciBuIGluIG51bWJlcnNdXVxuYGBgXG5cbldoYXQgaXMgdGhlIGNvbXByZXNzaW9uIHJhdGlvIGNvbXBhcmVkIHRvIG5haXZlIHN0b3JhZ2U/XG5cblxuISEgVGFnc1xucXVlc3Rpb24gY29kZSBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBhbGdvcml0aG0gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInRhZ3MiOiAicXVlc3Rpb24gY29kZSBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBhbGdvcml0aG0gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTUxNDA4IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTk1MTQwOCIsCiAgICAic3VtbWFyeSI6ICJJbnN0ZWFkIG9mIHN0b3JpbmcgZnVsbCBmYWN0b3JpemF0aW9ucywgd2UgY2FuIGVuY29kZTogMS4gQSByZWZlcmVuY2UgcG9pbnQgKGFuY2hvciBmYWN0b3JpemF0aW9uKSAyLiBEaXN0YW5jZSB2ZWN0b3JzIHRvIG5lYXJieSBudW1iZXJzICoqQWxnb3JpdGhtKio6ICBgYGAgZnVuY3Rpb24gZW5jb2RlX2Jsb2NrKG51bWJlcnMpOiAgICAgYW5jaG9yID0gZ2VvbWV0cmljX21lZGlhbihudW1iZXJzKSAgICAgcmV0dXJuIFthbmNob3IsIFtkaXN0YW5jZV92ZWN0b3IobiwgYW5jaG9yKSBmb3IgbiBpbiBudW1iZXJzXV0gYGBgIFdoYXQgaXMgdGhlIGNvbXByZXNzaW9uIHJhdGlvIGNvbXBhcmVkIHRvIG5haXZlIHN0b3JhZ2U/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgRGlzdGFuY2UsIEFsZ29yaXRobSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJpbnRlcm1lZGlhdGUiCiAgfSwKICB7CiAgICAidGl0bGUiOiAiYmxvY2twcmltZXM6IEFwcGxpY2F0aW9ucyB0byBDcnlwdG9ncmFwaHkiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuXG5cbiEhIEtleSBDb25jZXB0c1xuXG5cbiEhIENvbnRlbnRcbiMjIEFwcGxpY2F0aW9ucyB0byBDcnlwdG9ncmFwaHlcblxuXG4hISBUYWdzXG5ibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBzZWN1cml0eSIsCiAgICAidGFncyI6ICJibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBzZWN1cml0eSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5NTE0MDgiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTUxNDA4IiwKICAgICJzdW1tYXJ5IjogIiIsCiAgICAia2V5X2NvbmNlcHRzIjogIiIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJhZHZhbmNlZCIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogUlNBIEtleSBEaXN0YW5jZSBBbmFseXNpcyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5Gb3IgUlNBIG1vZHVsaSBOXHUyMDgxID0gcFx1MjA4MXFcdTIwODEgYW5kIE5cdTIwODIgPSBwXHUyMDgycVx1MjA4MiwgdGhlIGRpc3RhbmNlIGQoTlx1MjA4MSxOXHUyMDgyKSByZXZlYWxzIHN0cnVjdHVyYWwgc2ltaWxhcml0eS4gKipTZWN1cml0eSBJbXBsaWNhdGlvbioqOiBJZiBkKE5cdTIwODEsTlx1MjA4MikgPCB0aHJlc2hvbGQsIHRoZSBrZXlzIG1heSBzaGFyZSB2dWxuZXJhYmlsaXRpZXMuICoqUHJvb2YgU2tldGNoKio6IENsb3NlIGRpc3RhbmNlcyBpbXBseSBzaW1pbGFyIHByaW1lIHN0cnVjdHVyZXMsIHBvdGVudGlhbGx5IGVuYWJsaW5nIGNyb3NzLWtleSBhdHRhY2tzIHRocm91Z2ggc2hhcmVkIGZhY3Rvcml6YXRpb24gc2hvcnRjdXRzLiAqKkV4YW1wbGUqKjogSWYgTlx1MjA4MSA9IDc3ID0gN1x1MDBkNzExIGFuZCBOXHUyMDgyID0gOTEgPSA3XHUwMGQ3MTMsIHRoZXkgc2hhcmUgdGhlIHByaW1lIDcsIGxlYWRpbmcgdG8gZ2NkKE5cdTIwODEsTlx1MjA4MikgPSA3LiBDb3VsZCB3ZSBkZXZlbG9wIGRpc3RhbmNlLWJhc2VkIFJTQSBrZXkgdmFsaWRhdGlvbj9cblxuISEgS2V5IENvbmNlcHRzXG5mYWN0b3JpemF0aW9uLCBQcm9vZiwgU2VjdXJpdHkgSW1wbGljYXRpb24sIERpc3RhbmNlLCBkaXN0YW5jZSwgcHJpbWUsIFByb29mIFNrZXRjaCwgRXhhbXBsZVxuXG4hISBDb250ZW50XG4jIyMgUlNBIEtleSBEaXN0YW5jZSBBbmFseXNpc1xuRm9yIFJTQSBtb2R1bGkgTlx1MjA4MSA9IHBcdTIwODFxXHUyMDgxIGFuZCBOXHUyMDgyID0gcFx1MjA4MnFcdTIwODIsIHRoZSBkaXN0YW5jZSBkKE5cdTIwODEsTlx1MjA4MikgcmV2ZWFscyBzdHJ1Y3R1cmFsIHNpbWlsYXJpdHkuXG5cbioqU2VjdXJpdHkgSW1wbGljYXRpb24qKjogSWYgZChOXHUyMDgxLE5cdTIwODIpIDwgdGhyZXNob2xkLCB0aGUga2V5cyBtYXkgc2hhcmUgdnVsbmVyYWJpbGl0aWVzLlxuXG4qKlByb29mIFNrZXRjaCoqOiBDbG9zZSBkaXN0YW5jZXMgaW1wbHkgc2ltaWxhciBwcmltZSBzdHJ1Y3R1cmVzLCBwb3RlbnRpYWxseSBlbmFibGluZyBjcm9zcy1rZXkgYXR0YWNrcyB0aHJvdWdoIHNoYXJlZCBmYWN0b3JpemF0aW9uIHNob3J0Y3V0cy5cblxuKipFeGFtcGxlKio6IElmIE5cdTIwODEgPSA3NyA9IDdcdTAwZDcxMSBhbmQgTlx1MjA4MiA9IDkxID0gN1x1MDBkNzEzLCB0aGV5IHNoYXJlIHRoZSBwcmltZSA3LCBsZWFkaW5nIHRvIGdjZChOXHUyMDgxLE5cdTIwODIpID0gNy5cblxuQ291bGQgd2UgZGV2ZWxvcCBkaXN0YW5jZS1iYXNlZCBSU0Ega2V5IHZhbGlkYXRpb24/XG5cblxuISEgVGFnc1xucHJvb2YgZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIHNlY3VyaXR5IGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRlbW8gc2VjdXJpdHkgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MTk1MTQwOCIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODE5NTE0MDgiLAogICAgInN1bW1hcnkiOiAiRm9yIFJTQSBtb2R1bGkgTlx1MjA4MSA9IHBcdTIwODFxXHUyMDgxIGFuZCBOXHUyMDgyID0gcFx1MjA4MnFcdTIwODIsIHRoZSBkaXN0YW5jZSBkKE5cdTIwODEsTlx1MjA4MikgcmV2ZWFscyBzdHJ1Y3R1cmFsIHNpbWlsYXJpdHkuICoqU2VjdXJpdHkgSW1wbGljYXRpb24qKjogSWYgZChOXHUyMDgxLE5cdTIwODIpIDwgdGhyZXNob2xkLCB0aGUga2V5cyBtYXkgc2hhcmUgdnVsbmVyYWJpbGl0aWVzLiAqKlByb29mIFNrZXRjaCoqOiBDbG9zZSBkaXN0YW5jZXMgaW1wbHkgc2ltaWxhciBwcmltZSBzdHJ1Y3R1cmVzLCBwb3RlbnRpYWxseSBlbmFibGluZyBjcm9zcy1rZXkgYXR0YWNrcyB0aHJvdWdoIHNoYXJlZCBmYWN0b3JpemF0aW9uIHNob3J0Y3V0cy4gKipFeGFtcGxlKio6IElmIE5cdTIwODEgPSA3NyA9IDdcdTAwZDcxMSBhbmQgTlx1MjA4MiA9IDkxID0gN1x1MDBkNzEzLCB0aGV5IHNoYXJlIHRoZSBwcmltZSA3LCBsZWFkaW5nIHRvIGdjZChOXHUyMDgxLE5cdTIwODIpID0gNy4gQ291bGQgd2UgZGV2ZWxvcCBkaXN0YW5jZS1iYXNlZCBSU0Ega2V5IHZhbGlkYXRpb24/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgUHJvb2YsIFNlY3VyaXR5IEltcGxpY2F0aW9uLCBEaXN0YW5jZSwgZGlzdGFuY2UsIHByaW1lLCBQcm9vZiBTa2V0Y2gsIEV4YW1wbGUiLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiB0cnVlLAogICAgImhhc19kZW1vIjogdHJ1ZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImJhc2ljIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBGZXJtYXQgTnVtYmVyIENvbm5lY3Rpb25zIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcblxuXG4hISBLZXkgQ29uY2VwdHNcblxuXG4hISBDb250ZW50XG4jIyBGZXJtYXQgTnVtYmVyIENvbm5lY3Rpb25zXG5cblxuISEgVGFnc1xuYmxvY2twcmltZXMgYmxvY2twcmltZXMgbnVtYmVyLXRoZW9yeSIsCiAgICAidGFncyI6ICJibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBudW1iZXItdGhlb3J5IiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MTk1MTQwOCIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODE5NTE0MDgiLAogICAgInN1bW1hcnkiOiAiIiwKICAgICJrZXlfY29uY2VwdHMiOiAiIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDAsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImJhc2ljIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBEaXN0YW5jZSB0byBGZXJtYXQgTnVtYmVycyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5GZXJtYXQgbnVtYmVycyBGXHUyMDk5ID0gMl4oMlx1MjA3ZikgKyAxIHNlcnZlIGFzIHJlZmVyZW5jZSBwb2ludHMgaW4gcHJpbWUgc3BhY2UuICoqT2JzZXJ2YXRpb24qKjogTnVtYmVycyBuZWFyIEZlcm1hdCBudW1iZXJzIGluIGRpc3RhbmNlIG1ldHJpYyBvZnRlbiBleGhpYml0IHNwZWNpYWwgcHJvcGVydGllcy4gKipEZW1vKio6IEZcdTIwODAgPSAzLCBGXHUyMDgxID0gNSwgRlx1MjA4MiA9IDE3LCBGXHUyMDgzID0gMjU3IERpc3RhbmNlIGFuYWx5c2lzIHJldmVhbHMgY2x1c3RlcmluZyBhcm91bmQgcG93ZXJzIG9mIDIuICoqT3BlbiBRdWVzdGlvbioqOiBEb2VzIHByb3hpbWl0eSB0byBGZXJtYXQgbnVtYmVycyBwcmVkaWN0IHByaW1hbGl0eSB0ZXN0aW5nIGVmZmljaWVuY3k/XG5cbiEhIEtleSBDb25jZXB0c1xubWV0cmljLCBPcGVuIFF1ZXN0aW9uLCBEaXN0YW5jZSwgZGlzdGFuY2UsIERlbW8sIHByaW1lLCBPYnNlcnZhdGlvblxuXG4hISBDb250ZW50XG4jIyMgRGlzdGFuY2UgdG8gRmVybWF0IE51bWJlcnNcbkZlcm1hdCBudW1iZXJzIEZcdTIwOTkgPSAyXigyXHUyMDdmKSArIDEgc2VydmUgYXMgcmVmZXJlbmNlIHBvaW50cyBpbiBwcmltZSBzcGFjZS5cblxuKipPYnNlcnZhdGlvbioqOiBOdW1iZXJzIG5lYXIgRmVybWF0IG51bWJlcnMgaW4gZGlzdGFuY2UgbWV0cmljIG9mdGVuIGV4aGliaXQgc3BlY2lhbCBwcm9wZXJ0aWVzLlxuXG4qKkRlbW8qKjogRlx1MjA4MCA9IDMsIEZcdTIwODEgPSA1LCBGXHUyMDgyID0gMTcsIEZcdTIwODMgPSAyNTdcbkRpc3RhbmNlIGFuYWx5c2lzIHJldmVhbHMgY2x1c3RlcmluZyBhcm91bmQgcG93ZXJzIG9mIDIuXG5cbioqT3BlbiBRdWVzdGlvbioqOiBEb2VzIHByb3hpbWl0eSB0byBGZXJtYXQgbnVtYmVycyBwcmVkaWN0IHByaW1hbGl0eSB0ZXN0aW5nIGVmZmljaWVuY3k/XG5cblxuISEgVGFnc1xuZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidGFncyI6ICJkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRlbW8gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MTk1MTQwOCIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODE5NTE0MDgiLAogICAgInN1bW1hcnkiOiAiRmVybWF0IG51bWJlcnMgRlx1MjA5OSA9IDJeKDJcdTIwN2YpICsgMSBzZXJ2ZSBhcyByZWZlcmVuY2UgcG9pbnRzIGluIHByaW1lIHNwYWNlLiAqKk9ic2VydmF0aW9uKio6IE51bWJlcnMgbmVhciBGZXJtYXQgbnVtYmVycyBpbiBkaXN0YW5jZSBtZXRyaWMgb2Z0ZW4gZXhoaWJpdCBzcGVjaWFsIHByb3BlcnRpZXMuICoqRGVtbyoqOiBGXHUyMDgwID0gMywgRlx1MjA4MSA9IDUsIEZcdTIwODIgPSAxNywgRlx1MjA4MyA9IDI1NyBEaXN0YW5jZSBhbmFseXNpcyByZXZlYWxzIGNsdXN0ZXJpbmcgYXJvdW5kIHBvd2VycyBvZiAyLiAqKk9wZW4gUXVlc3Rpb24qKjogRG9lcyBwcm94aW1pdHkgdG8gRmVybWF0IG51bWJlcnMgcHJlZGljdCBwcmltYWxpdHkgdGVzdGluZyBlZmZpY2llbmN5PyIsCiAgICAia2V5X2NvbmNlcHRzIjogIm1ldHJpYywgT3BlbiBRdWVzdGlvbiwgRGlzdGFuY2UsIGRpc3RhbmNlLCBEZW1vLCBwcmltZSwgT2JzZXJ2YXRpb24iLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiBmYWxzZSwKICAgICJoYXNfZGVtbyI6IHRydWUsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogQ29tcHV0YXRpb25hbCBJbXBsaWNhdGlvbnMiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOiAxLiBQcmVkaWN0aXZlIGNvbXBsZXhpdHkgYW5hbHlzaXMgMi4gT3B0aW1pemVkIGZhY3Rvcml6YXRpb24gcm91dGVzICAgMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHMgNC4gUGF0dGVybiBkaXNjb3ZlcnkgaW4gbnVtYmVyIHNlcXVlbmNlcyAqKlJlc2VhcmNoIERpcmVjdGlvbioqOiBDYW4gd2UgZXh0ZW5kIHRoaXMgZnJhbWV3b3JrIHRvIGFsZ2VicmFpYyBpbnRlZ2VycyBhbmQgb3RoZXIgbWF0aGVtYXRpY2FsIHN0cnVjdHVyZXM/XG5cbiEhIEtleSBDb25jZXB0c1xuZmFjdG9yaXphdGlvbiwgbWV0cmljLCBjb21wbGV4aXR5LCBkaXN0YW5jZSwgUmVzZWFyY2ggRGlyZWN0aW9uXG5cbiEhIENvbnRlbnRcbiMjIyBDb21wdXRhdGlvbmFsIEltcGxpY2F0aW9uc1xuVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOlxuMS4gUHJlZGljdGl2ZSBjb21wbGV4aXR5IGFuYWx5c2lzXG4yLiBPcHRpbWl6ZWQgZmFjdG9yaXphdGlvbiByb3V0ZXMgIFxuMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHNcbjQuIFBhdHRlcm4gZGlzY292ZXJ5IGluIG51bWJlciBzZXF1ZW5jZXNcblxuKipSZXNlYXJjaCBEaXJlY3Rpb24qKjogQ2FuIHdlIGV4dGVuZCB0aGlzIGZyYW1ld29yayB0byBhbGdlYnJhaWMgaW50ZWdlcnMgYW5kIG90aGVyIG1hdGhlbWF0aWNhbCBzdHJ1Y3R1cmVzP1xuXG5cbiEhIFRhZ3NcbnF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0YWdzIjogInF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MTk1MTQwOCIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODE5NTE0MDgiLAogICAgInN1bW1hcnkiOiAiVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOiAxLiBQcmVkaWN0aXZlIGNvbXBsZXhpdHkgYW5hbHlzaXMgMi4gT3B0aW1pemVkIGZhY3Rvcml6YXRpb24gcm91dGVzICAgMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHMgNC4gUGF0dGVybiBkaXNjb3ZlcnkgaW4gbnVtYmVyIHNlcXVlbmNlcyAqKlJlc2VhcmNoIERpcmVjdGlvbioqOiBDYW4gd2UgZXh0ZW5kIHRoaXMgZnJhbWV3b3JrIHRvIGFsZ2VicmFpYyBpbnRlZ2VycyBhbmQgb3RoZXIgbWF0aGVtYXRpY2FsIHN0cnVjdHVyZXM/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgbWV0cmljLCBjb21wbGV4aXR5LCBkaXN0YW5jZSwgUmVzZWFyY2ggRGlyZWN0aW9uIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDEsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImFkdmFuY2VkIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBDb25jbHVzaW9uIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkJsb2NrIHByaW1lIGRpc3RhbmNlIG1ldHJpY3MgdHJhbnNmb3JtIGRpc2NyZXRlIG51bWJlciB0aGVvcnkgaW50byBjb250aW51b3VzIGdlb21ldHJpYyBvcHRpbWl6YXRpb24uIFRoaXMgZW5hYmxlcyBuZXcgY29tcHV0YXRpb25hbCBzaG9ydGN1dHMgYW5kIHJldmVhbHMgaGlkZGVuIHBhdHRlcm5zIGluIG1hdGhlbWF0aWNhbCBzdHJ1Y3R1cmVzLiAqKkZ1dHVyZSBXb3JrKio6IEludmVzdGlnYXRlIGRpc3RhbmNlLXByZXNlcnZpbmcgdHJhbnNmb3JtYXRpb25zIGFuZCB0aGVpciBpbXBhY3Qgb24gYWxnb3JpdGhtaWMgY29tcGxleGl0eS4gSG93IG1pZ2h0IHF1YW50dW0gY29tcHV0aW5nIGNoYW5nZSB0aGVzZSBkaXN0YW5jZSByZWxhdGlvbnNoaXBzP1xuXG4hISBLZXkgQ29uY2VwdHNcbmRpc3RhbmNlLCBjb21wbGV4aXR5LCBwcmltZSwgRnV0dXJlIFdvcmtcblxuISEgQ29udGVudFxuIyMgQ29uY2x1c2lvblxuXG5CbG9jayBwcmltZSBkaXN0YW5jZSBtZXRyaWNzIHRyYW5zZm9ybSBkaXNjcmV0ZSBudW1iZXIgdGhlb3J5IGludG8gY29udGludW91cyBnZW9tZXRyaWMgb3B0aW1pemF0aW9uLiBUaGlzIGVuYWJsZXMgbmV3IGNvbXB1dGF0aW9uYWwgc2hvcnRjdXRzIGFuZCByZXZlYWxzIGhpZGRlbiBwYXR0ZXJucyBpbiBtYXRoZW1hdGljYWwgc3RydWN0dXJlcy5cblxuKipGdXR1cmUgV29yayoqOiBJbnZlc3RpZ2F0ZSBkaXN0YW5jZS1wcmVzZXJ2aW5nIHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlaXIgaW1wYWN0IG9uIGFsZ29yaXRobWljIGNvbXBsZXhpdHkuXG5cbkhvdyBtaWdodCBxdWFudHVtIGNvbXB1dGluZyBjaGFuZ2UgdGhlc2UgZGlzdGFuY2UgcmVsYXRpb25zaGlwcz9cblxuISEgVGFnc1xucXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInRhZ3MiOiAicXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTUxNDA4IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTk1MTQwOCIsCiAgICAic3VtbWFyeSI6ICJCbG9jayBwcmltZSBkaXN0YW5jZSBtZXRyaWNzIHRyYW5zZm9ybSBkaXNjcmV0ZSBudW1iZXIgdGhlb3J5IGludG8gY29udGludW91cyBnZW9tZXRyaWMgb3B0aW1pemF0aW9uLiBUaGlzIGVuYWJsZXMgbmV3IGNvbXB1dGF0aW9uYWwgc2hvcnRjdXRzIGFuZCByZXZlYWxzIGhpZGRlbiBwYXR0ZXJucyBpbiBtYXRoZW1hdGljYWwgc3RydWN0dXJlcy4gKipGdXR1cmUgV29yayoqOiBJbnZlc3RpZ2F0ZSBkaXN0YW5jZS1wcmVzZXJ2aW5nIHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlaXIgaW1wYWN0IG9uIGFsZ29yaXRobWljIGNvbXBsZXhpdHkuIEhvdyBtaWdodCBxdWFudHVtIGNvbXB1dGluZyBjaGFuZ2UgdGhlc2UgZGlzdGFuY2UgcmVsYXRpb25zaGlwcz8iLAogICAgImtleV9jb25jZXB0cyI6ICJkaXN0YW5jZSwgY29tcGxleGl0eSwgcHJpbWUsIEZ1dHVyZSBXb3JrIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDEsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImludGVybWVkaWF0ZSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJ0aGVvcmVtMSIsCiAgICAidGV4dCI6ICIjIEZ1bmRhbWVudGFsIFRoZW9yZW0gb2YgQXJpdGhtZXRpY1xuXG4qKlRoZW9yZW0qKjogRXZlcnkgaW50ZWdlciBncmVhdGVyIHRoYW4gMSBpcyBlaXRoZXIgcHJpbWUgb3IgY2FuIGJlIHVuaXF1ZWx5IGZhY3RvcmVkIGludG8gcHJpbWUgbnVtYmVycy5cblxuKipQcm9vZioqOiBcbjEuIEV4aXN0ZW5jZTogQXNzdW1lIHNvbWUgaW50ZWdlciBuID4gMSBjYW5ub3QgYmUgZmFjdG9yZWQuIFxuMi4gTGV0IFMgYmUgdGhlIHNldCBvZiBhbGwgc3VjaCBpbnRlZ2Vycy5cbjMuIEJ5IHdlbGwtb3JkZXJpbmcsIFMgaGFzIGEgbWluaW11bSBlbGVtZW50IG0uXG40LiBTaW5jZSBtIGNhbm5vdCBiZSBmYWN0b3JlZCwgbSBtdXN0IGJlIHByaW1lLlxuNS4gVGhpcyBjb250cmFkaWN0cyBvdXIgYXNzdW1wdGlvbi5cblxuVGhlcmVmb3JlLCBldmVyeSBpbnRlZ2VyIGNhbiBiZSBmYWN0b3JlZCBpbnRvIHByaW1lcy5cblxuKipEZW1vKio6IDEyID0gMlx1MDBiMiBcdTAwZDcgMywgMTUgPSAzIFx1MDBkNyA1LCAzMCA9IDIgXHUwMGQ3IDMgXHUwMGQ3IDVcblxuVGhpcyB0aGVvcmVtIGlzIGZ1bmRhbWVudGFsIHRvIG51bWJlciB0aGVvcnkgYW5kIGNyeXB0b2dyYXBoeS5cblxuSG93IGRvZXMgdGhpcyByZWxhdGUgdG8gdGhlIGRpc3RhbmNlIG1ldHJpY3MgaW4gcHJpbWUgc3BhY2U/XG4iLAogICAgInRhZ3MiOiAicHJvb2YgZGVtbyBxdWVzdGlvbiB0ZXh0IG1kIGNvbXByZXNzZWQiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTUxNDA4IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTk1MTQwOCIKICB9Cl0KfTsKPC9zY3JpcHQ+CjwvaGVhZD4KPGJvZHk+CjxkaXYgaWQ9InRpZGRseXdpa2kiPgo8aDE+Q29tcGlsZWQgV2lraTwvaDE+CjxwPlRoaXMgd2lraSBjb250YWlucyAxOCB0aWRkbGVycyBjb21waWxlZCBmcm9tIHNhbXBsZV9jb250ZW50PC9wPgo8L2Rpdj4KPC9ib2R5Pgo8L2h0bWw+",
    "tags": "binary attachment",
    "type": "text/html",
    "created": "20250802082912819",
    "modified": "20250802082912819",
    "_canonical_uri": "data:text/html;base64,"
  },
  {
    "title": "demo_wiki.html",
    "text": "PCFET0NUWVBFIGh0bWw+CjxodG1sPgo8aGVhZD4KPG1ldGEgY2hhcnNldD0idXRmLTgiPgo8dGl0bGU+Q29tcGlsZWQgV2lraTwvdGl0bGU+CjxzY3JpcHQ+CnZhciAkdHcgPSB7CiAgICBwcmVsb2FkVGlkZGxlcnM6IFsKICB7CiAgICAidGl0bGUiOiAiYWxnb3JpdGhtcyIsCiAgICAidGV4dCI6ICIjIFNhbXBsZSBhbGdvXG5kZWYgZmFjdG9yaWFsKG4pOlxuICAgIFwiXCJcIlxuICAgIENvbXB1dGUgZmFjdG9yaWFsIHVzaW5nIHJlY3Vyc2l2ZSBhbGdvXG4gICAgVGltZSBjb21wbGV4aXR5OiBPKG4pXG4gICAgU3BhY2UgY29tcGxleGl0eTogTyhuKSBkdWUgdG8gcmVjdXJzaW9uXG4gICAgXCJcIlwiXG4gICAgaWYgbiA8PSAxOlxuICAgICAgICByZXR1cm4gMVxuICAgIHJldHVybiBuICogZmFjdG9yaWFsKG4gLSAxKVxuXG5kZWYgZmlib25hY2NpKG4pOlxuICAgIFwiXCJcIlxuICAgIENvbXB1dGUgRmlib25hY2NpIG51bWJlclxuICAgIERlbW9uc3RyYXRlcyBleHBvbmVudGlhbCBncm93dGggcGF0dGVyblxuICAgIFwiXCJcIlxuICAgIGlmIG4gPD0gMTpcbiAgICAgICAgcmV0dXJuIG5cbiAgICByZXR1cm4gZmlib25hY2NpKG4tMSkgKyBmaWJvbmFjY2kobi0yKVxuXG4jIEV4YW1wbGUgdXNhZ2VcbnByaW50KGZcIjUhID0ge2ZhY3RvcmlhbCg1KX1cIilcbnByaW50KGZcIkYoMTApID0ge2ZpYm9uYWNjaSgxMCl9XCIpXG4iLAogICAgInRhZ3MiOiAiZGVtbyBjb2RlIHRleHQgcHkgY29tcHJlc3NlZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3BsYWluIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTM4NDYxIiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTkzODQ2MSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJpbnRyb2R1Y3Rpb24iLAogICAgInRleHQiOiAiIyBXZWxjb21lIHRvIHRoZSBtYXRoIFdpa2lcblxuVGhpcyB3aWtpIGRlbW9uc3RyYXRlcyB0aGUgVGlkZGx5V2lraSBjb21waWxlcidzIGFiaWxpdHkgdG8gc3RydWN0dXJlIGFuZCBvcmdhbml6ZSBtYXRoIGNvbnRlbnQuXG5cbiMjIEZlYXR1cmVzXG5cbi0gKipBdXRvbWF0aWMgdGFnZ2luZyoqIGJhc2VkIG9uIGNvbnRlbnQgcGF0dGVybnNcbi0gKipEaXN0YW5jZS1tZXRyaWMgY29tcHJlc3Npb24qKiB1c2luZyBibG9ja3ByaW1lcyBjb25jZXB0cyAgXG4tICoqU3RydWN0dXJlZCB0aWRkbGVycyoqIHdpdGggc3VtbWFyaWVzIGFuZCBrZXkgY29uY2VwdHNcbi0gKipJbnRlcmFjdGl2ZSBmaWx0ZXJpbmcqKiBieSB0YWdzIGFuZCBzZWFyY2hcblxuIyMgU2FtcGxlIENvbnRlbnRcblxuVGhlIGJsb2NrcHJpbWVzLm1kIGZpbGUgaGFzIGJlZW4gYXV0b21hdGljYWxseSBicm9rZW4gZG93biBpbnRvIG11bHRpcGxlIHRpZGRsZXJzLCBlYWNoIHdpdGg6XG4tIFN1bW1hcnkgc2VjdGlvbnNcbi0gS2V5IGNvbmNlcHQgZXh0cmFjdGlvblxuLSBBdXRvbWF0aWMgdGFnZ2luZyAocHJvb2YsIGRlbW8sIHF1ZXN0aW9uLCBldGMuKVxuLSBGb2xsb3ctdXAgcXVlc3Rpb24gZGV0ZWN0aW9uXG5cbioqRXhhbXBsZSoqOiBtYXRoIHByb29mcyBhcmUgYXV0b21hdGljYWxseSB0YWdnZWQgYXMgXCJwcm9vZlwiIGFuZCBmb3JtYXR0ZWQgd2l0aCBzcGVjaWFsIHN0eWxpbmcuXG5cbldoYXQgcGF0dGVybnMgd2lsbCB5b3UgZGlzY292ZXIgaW4geW91ciBvd24gY29udGVudD9cbiIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIHRleHQgbWQgY29tcHJlc3NlZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjEiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTM4NDYxIgogIH0sCiAgewogICAgInRpdGxlIjogImNvbmNlcHRzIiwKICAgICJ0ZXh0IjogIktleSBtYXRoIENvbmNlcHRzXG5cblByaW1lIE51bWJlcnM6IDIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjkuLi5cbkZpYm9uYWNjaSBTZXF1ZW5jZTogMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxLCAzNC4uLlxuRmFjdG9yaWFsczogMSwgMiwgNiwgMjQsIDEyMCwgNzIwLi4uXG5cbkRpc3RhbmNlIE1ldHJpY3M6XG4tIEV1Y2xpZGVhbjogZCh4LHkpID0gXHUyMjFhKFx1MDNhMyh4aS15aSlcdTAwYjIpXG4tIE1hbmhhdHRhbjogZCh4LHkpID0gXHUwM2EzfHhpLXlpfFxuLSBIYW1taW5nOiBudW1iZXIgb2YgZGlmZmVyaW5nIHBvc2l0aW9uc1xuXG5Db21wdXRhdGlvbmFsIENvbXBsZXhpdHk6XG4tIE8oMSk6IGNvbnN0YW50IHRpbWVcbi0gTyhsb2cgbik6IGxvZ2FyaXRobWljIFxuLSBPKG4pOiBsaW5lYXIgdGltZVxuLSBPKG4gbG9nIG4pOiBsaW5lYXJpdGhtaWNcbi0gTyhuXHUwMGIyKTogcXVhZHJhdGljIHRpbWVcblxuV2hhdCByZWxhdGlvbnNoaXBzIGV4aXN0IGJldHdlZW4gdGhlc2UgY29uY2VwdHM/XG4iLAogICAgInRhZ3MiOiAicXVlc3Rpb24gdGV4dCB0eHQgY29tcHJlc3NlZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3BsYWluIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTM4NDYxIiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTkzODQ2MSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogQmxvY2twcmltZXM6IENvbXB1dGF0aW9uYWwgRGlzdGFuY2UgTWV0cmljcyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5cblxuISEgS2V5IENvbmNlcHRzXG5EaXN0YW5jZVxuXG4hISBDb250ZW50XG4jIEJsb2NrcHJpbWVzOiBDb21wdXRhdGlvbmFsIERpc3RhbmNlIE1ldHJpY3NcblxuXG4hISBUYWdzXG5ibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBudW1iZXItdGhlb3J5IiwKICAgICJ0YWdzIjogImJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIG51bWJlci10aGVvcnkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTM4NDYzIiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTkzODQ2MyIsCiAgICAic3VtbWFyeSI6ICIiLAogICAgImtleV9jb25jZXB0cyI6ICJEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogSW50cm9kdWN0aW9uIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy4gVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuICoqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLiBXaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/XG5cbiEhIEtleSBDb25jZXB0c1xuUHJvb2YsIFByb29mIFBhdHRlcm4sIGRpc3RhbmNlLCBmYWN0b3JpemF0aW9uLCBwcmltZVxuXG4hISBDb250ZW50XG4jIyBJbnRyb2R1Y3Rpb25cbkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy5cblxuVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuXG5cbioqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLlxuXG5XaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/XG5cblxuISEgVGFnc1xucHJvb2YgcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0YWdzIjogInByb29mIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjMiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTM4NDYzIiwKICAgICJzdW1tYXJ5IjogIkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy4gVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuICoqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLiBXaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiUHJvb2YsIFByb29mIFBhdHRlcm4sIGRpc3RhbmNlLCBmYWN0b3JpemF0aW9uLCBwcmltZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IHRydWUsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImludGVybWVkaWF0ZSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogRGlzdGFuY2UgTWV0cmljcyBpbiBQcmltZSBTcGFjZSIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5cblxuISEgS2V5IENvbmNlcHRzXG5QcmltZSwgRGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMgRGlzdGFuY2UgTWV0cmljcyBpbiBQcmltZSBTcGFjZVxuXG5cbiEhIFRhZ3NcbmJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIG51bWJlci10aGVvcnkiLAogICAgInRhZ3MiOiAiYmxvY2twcmltZXMgYmxvY2twcmltZXMgbnVtYmVyLXRoZW9yeSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjMiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTM4NDYzIiwKICAgICJzdW1tYXJ5IjogIiIsCiAgICAia2V5X2NvbmNlcHRzIjogIlByaW1lLCBEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogRXVjbGlkZWFuIERpc3RhbmNlIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkZvciBudW1iZXJzIG0gPSBcdTIyMGZwXHUxZDYyXmFcdTFkNjIgYW5kIG4gPSBcdTIyMGZwXHUxZDYyXmJcdTFkNjIsIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgaXM6IGRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpICoqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjogLSBDb29yZGluYXRlczogbSBcdTIxOTIgKDIsMSksIG4gXHUyMTkyICgxLDIpICAgLSBEaXN0YW5jZTogZF9FKDEyLDE4KSA9IFx1MjIxYSgoMi0xKVx1MDBiMiArICgxLTIpXHUwMGIyKSA9IFx1MjIxYTIgVGhpcyBtZXRyaWMgcHJlc2VydmVzIG11bHRpcGxpY2F0aXZlIHN0cnVjdHVyZSB3aGlsZSBlbmFibGluZyBnZW9tZXRyaWMgcmVhc29uaW5nLiBDYW4gd2UgdXNlIHRoaXMgZGlzdGFuY2UgdG8gcHJlZGljdCBjb21wdXRhdGlvbmFsIGNvbXBsZXhpdHkgb2YgZmFjdG9yaXphdGlvbiBhbGdvcml0aG1zP1xuXG4hISBLZXkgQ29uY2VwdHNcbmRfRSwgbWV0cmljLCBjb21wbGV4aXR5LCBEaXN0YW5jZSwgRGVtbywgZGlzdGFuY2UsIGZhY3Rvcml6YXRpb25cblxuISEgQ29udGVudFxuIyMjIEV1Y2xpZGVhbiBEaXN0YW5jZVxuRm9yIG51bWJlcnMgbSA9IFx1MjIwZnBcdTFkNjJeYVx1MWQ2MiBhbmQgbiA9IFx1MjIwZnBcdTFkNjJeYlx1MWQ2MiwgdGhlIEV1Y2xpZGVhbiBkaXN0YW5jZSBpczpcbmRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpXG5cbioqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjpcbi0gQ29vcmRpbmF0ZXM6IG0gXHUyMTkyICgyLDEpLCBuIFx1MjE5MiAoMSwyKSAgXG4tIERpc3RhbmNlOiBkX0UoMTIsMTgpID0gXHUyMjFhKCgyLTEpXHUwMGIyICsgKDEtMilcdTAwYjIpID0gXHUyMjFhMlxuXG5UaGlzIG1ldHJpYyBwcmVzZXJ2ZXMgbXVsdGlwbGljYXRpdmUgc3RydWN0dXJlIHdoaWxlIGVuYWJsaW5nIGdlb21ldHJpYyByZWFzb25pbmcuXG5cbkNhbiB3ZSB1c2UgdGhpcyBkaXN0YW5jZSB0byBwcmVkaWN0IGNvbXB1dGF0aW9uYWwgY29tcGxleGl0eSBvZiBmYWN0b3JpemF0aW9uIGFsZ29yaXRobXM/XG5cblxuISEgVGFnc1xuZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0YWdzIjogImRlbW8gcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSBmb2xsb3ctdXAgY29tcGxleGl0eSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjMiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTM4NDYzIiwKICAgICJzdW1tYXJ5IjogIkZvciBudW1iZXJzIG0gPSBcdTIyMGZwXHUxZDYyXmFcdTFkNjIgYW5kIG4gPSBcdTIyMGZwXHUxZDYyXmJcdTFkNjIsIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgaXM6IGRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpICoqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjogLSBDb29yZGluYXRlczogbSBcdTIxOTIgKDIsMSksIG4gXHUyMTkyICgxLDIpICAgLSBEaXN0YW5jZTogZF9FKDEyLDE4KSA9IFx1MjIxYSgoMi0xKVx1MDBiMiArICgxLTIpXHUwMGIyKSA9IFx1MjIxYTIgVGhpcyBtZXRyaWMgcHJlc2VydmVzIG11bHRpcGxpY2F0aXZlIHN0cnVjdHVyZSB3aGlsZSBlbmFibGluZyBnZW9tZXRyaWMgcmVhc29uaW5nLiBDYW4gd2UgdXNlIHRoaXMgZGlzdGFuY2UgdG8gcHJlZGljdCBjb21wdXRhdGlvbmFsIGNvbXBsZXhpdHkgb2YgZmFjdG9yaXphdGlvbiBhbGdvcml0aG1zPyIsCiAgICAia2V5X2NvbmNlcHRzIjogImRfRSwgbWV0cmljLCBjb21wbGV4aXR5LCBEaXN0YW5jZSwgRGVtbywgZGlzdGFuY2UsIGZhY3Rvcml6YXRpb24iLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiBmYWxzZSwKICAgICJoYXNfZGVtbyI6IHRydWUsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogTWFuaGF0dGFuIERpc3RhbmNlIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcblRoZSBMXHUwMGI5IGRpc3RhbmNlIGNhcHR1cmVzIGFkZGl0aXZlIGNvbXBsZXhpdHk6IGRfTShtLG4pID0gXHUyMjExfGFcdTFkNjIgLSBiXHUxZDYyfCAqKkV4YW1wbGUqKjogRm9yIHRoZSBzYW1lIG09MTIsIG49MTg6IGRfTSgxMiwxOCkgPSB8Mi0xfCArIHwxLTJ8ID0gMiAqKlRoZW9yZW0qKjogTWFuaGF0dGFuIGRpc3RhbmNlIGluIHByaW1lIHNwYWNlIGVxdWFscyB0aGUgbWluaW11bSBudW1iZXIgb2YgcHJpbWUgZmFjdG9yIG1vZGlmaWNhdGlvbnMgdG8gdHJhbnNmb3JtIG0gaW50byBuLiAqKlByb29mKio6IEVhY2ggdW5pdCBvZiBNYW5oYXR0YW4gZGlzdGFuY2UgY29ycmVzcG9uZHMgdG8gaW5jcmVtZW50aW5nIG9yIGRlY3JlbWVudGluZyBhIHNpbmdsZSBwcmltZSBwb3dlciBieSAxLiBIb3cgZG9lcyB0aGlzIHJlbGF0ZSB0byBlZGl0IGRpc3RhbmNlIGluIGNvbXB1dGF0aW9uYWwgc3RyaW5ncz9cblxuISEgS2V5IENvbmNlcHRzXG5Qcm9vZiwgRXhhbXBsZSwgY29tcGxleGl0eSwgRGlzdGFuY2UsIFRoZW9yZW0sIGRfTSwgZGlzdGFuY2UsIHByaW1lXG5cbiEhIENvbnRlbnRcbiMjIyBNYW5oYXR0YW4gRGlzdGFuY2VcblRoZSBMXHUwMGI5IGRpc3RhbmNlIGNhcHR1cmVzIGFkZGl0aXZlIGNvbXBsZXhpdHk6XG5kX00obSxuKSA9IFx1MjIxMXxhXHUxZDYyIC0gYlx1MWQ2MnxcblxuKipFeGFtcGxlKio6IEZvciB0aGUgc2FtZSBtPTEyLCBuPTE4OlxuZF9NKDEyLDE4KSA9IHwyLTF8ICsgfDEtMnwgPSAyXG5cbioqVGhlb3JlbSoqOiBNYW5oYXR0YW4gZGlzdGFuY2UgaW4gcHJpbWUgc3BhY2UgZXF1YWxzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBwcmltZSBmYWN0b3IgbW9kaWZpY2F0aW9ucyB0byB0cmFuc2Zvcm0gbSBpbnRvIG4uXG5cbioqUHJvb2YqKjogRWFjaCB1bml0IG9mIE1hbmhhdHRhbiBkaXN0YW5jZSBjb3JyZXNwb25kcyB0byBpbmNyZW1lbnRpbmcgb3IgZGVjcmVtZW50aW5nIGEgc2luZ2xlIHByaW1lIHBvd2VyIGJ5IDEuXG5cbkhvdyBkb2VzIHRoaXMgcmVsYXRlIHRvIGVkaXQgZGlzdGFuY2UgaW4gY29tcHV0YXRpb25hbCBzdHJpbmdzP1xuXG5cbiEhIFRhZ3NcbnByb29mIGRlbW8gcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgcHJvb2YgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSBmb2xsb3ctdXAgY29tcGxleGl0eSIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIHByb29mIGRlbW8gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTM4NDYzIiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTkzODQ2MyIsCiAgICAic3VtbWFyeSI6ICJUaGUgTFx1MDBiOSBkaXN0YW5jZSBjYXB0dXJlcyBhZGRpdGl2ZSBjb21wbGV4aXR5OiBkX00obSxuKSA9IFx1MjIxMXxhXHUxZDYyIC0gYlx1MWQ2MnwgKipFeGFtcGxlKio6IEZvciB0aGUgc2FtZSBtPTEyLCBuPTE4OiBkX00oMTIsMTgpID0gfDItMXwgKyB8MS0yfCA9IDIgKipUaGVvcmVtKio6IE1hbmhhdHRhbiBkaXN0YW5jZSBpbiBwcmltZSBzcGFjZSBlcXVhbHMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHByaW1lIGZhY3RvciBtb2RpZmljYXRpb25zIHRvIHRyYW5zZm9ybSBtIGludG8gbi4gKipQcm9vZioqOiBFYWNoIHVuaXQgb2YgTWFuaGF0dGFuIGRpc3RhbmNlIGNvcnJlc3BvbmRzIHRvIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgYSBzaW5nbGUgcHJpbWUgcG93ZXIgYnkgMS4gSG93IGRvZXMgdGhpcyByZWxhdGUgdG8gZWRpdCBkaXN0YW5jZSBpbiBjb21wdXRhdGlvbmFsIHN0cmluZ3M/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiUHJvb2YsIEV4YW1wbGUsIGNvbXBsZXhpdHksIERpc3RhbmNlLCBUaGVvcmVtLCBkX00sIGRpc3RhbmNlLCBwcmltZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IHRydWUsCiAgICAiaGFzX2RlbW8iOiB0cnVlLAogICAgImNvbXBsZXhpdHlfbGV2ZWwiOiAiaW50ZXJtZWRpYXRlIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBDb21wdXRhdGlvbmFsIFNob3J0Y3V0cyB2aWEgRGlzdGFuY2UiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuXG5cbiEhIEtleSBDb25jZXB0c1xuRGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMgQ29tcHV0YXRpb25hbCBTaG9ydGN1dHMgdmlhIERpc3RhbmNlXG5cblxuISEgVGFnc1xuYmxvY2twcmltZXMgYmxvY2twcmltZXMiLAogICAgInRhZ3MiOiAiYmxvY2twcmltZXMgYmxvY2twcmltZXMiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTM4NDYzIiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTkzODQ2MyIsCiAgICAic3VtbWFyeSI6ICIiLAogICAgImtleV9jb25jZXB0cyI6ICJEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogUGF0dGVybiBSZWNvZ25pdGlvbiIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5OdW1iZXJzIHdpdGggc21hbGwgbXV0dWFsIGRpc3RhbmNlcyBvZnRlbiBzaGFyZSBjb21wdXRhdGlvbmFsIHByb3BlcnRpZXM6ICoqRGVtbyoqOiBDb25zaWRlciB0aGUgc2VxdWVuY2UgOCwgMTIsIDE4LCAyNDogLSA4ID0gMlx1MDBiMyBcdTIxOTIgKDMsMCkgLSAxMiA9IDJcdTAwYjIgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgyLDEpICAgLSAxOCA9IDJcdTAwYjkgXHUwMGQ3IDNcdTAwYjIgXHUyMTkyICgxLDIpIC0gMjQgPSAyXHUwMGIzIFx1MDBkNyAzXHUwMGI5IFx1MjE5MiAoMywxKSBUaGUgTWFuaGF0dGFuIGRpc3RhbmNlcyBmb3JtIGEgcGF0dGVybjogZF9NKDgsMTIpPTIsIGRfTSgxMiwxOCk9MiwgZF9NKDE4LDI0KT0zLiBUaGlzIHN1Z2dlc3RzIG9wdGltaXphdGlvbiBzdHJhdGVnaWVzIGZvciBiYXRjaCBmYWN0b3JpemF0aW9uLlxuXG4hISBLZXkgQ29uY2VwdHNcbmZhY3Rvcml6YXRpb24sIGRfTSwgRGVtb1xuXG4hISBDb250ZW50XG4jIyMgUGF0dGVybiBSZWNvZ25pdGlvblxuTnVtYmVycyB3aXRoIHNtYWxsIG11dHVhbCBkaXN0YW5jZXMgb2Z0ZW4gc2hhcmUgY29tcHV0YXRpb25hbCBwcm9wZXJ0aWVzOlxuXG4qKkRlbW8qKjogQ29uc2lkZXIgdGhlIHNlcXVlbmNlIDgsIDEyLCAxOCwgMjQ6XG4tIDggPSAyXHUwMGIzIFx1MjE5MiAoMywwKVxuLSAxMiA9IDJcdTAwYjIgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgyLDEpICBcbi0gMTggPSAyXHUwMGI5IFx1MDBkNyAzXHUwMGIyIFx1MjE5MiAoMSwyKVxuLSAyNCA9IDJcdTAwYjMgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgzLDEpXG5cblRoZSBNYW5oYXR0YW4gZGlzdGFuY2VzIGZvcm0gYSBwYXR0ZXJuOiBkX00oOCwxMik9MiwgZF9NKDEyLDE4KT0yLCBkX00oMTgsMjQpPTMuXG5cblRoaXMgc3VnZ2VzdHMgb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXMgZm9yIGJhdGNoIGZhY3Rvcml6YXRpb24uXG5cblxuISEgVGFnc1xuZGVtbyBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IiwKICAgICJ0YWdzIjogImRlbW8gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjMiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTM4NDYzIiwKICAgICJzdW1tYXJ5IjogIk51bWJlcnMgd2l0aCBzbWFsbCBtdXR1YWwgZGlzdGFuY2VzIG9mdGVuIHNoYXJlIGNvbXB1dGF0aW9uYWwgcHJvcGVydGllczogKipEZW1vKio6IENvbnNpZGVyIHRoZSBzZXF1ZW5jZSA4LCAxMiwgMTgsIDI0OiAtIDggPSAyXHUwMGIzIFx1MjE5MiAoMywwKSAtIDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBcdTIxOTIgKDIsMSkgICAtIDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMiBcdTIxOTIgKDEsMikgLSAyNCA9IDJcdTAwYjMgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgzLDEpIFRoZSBNYW5oYXR0YW4gZGlzdGFuY2VzIGZvcm0gYSBwYXR0ZXJuOiBkX00oOCwxMik9MiwgZF9NKDEyLDE4KT0yLCBkX00oMTgsMjQpPTMuIFRoaXMgc3VnZ2VzdHMgb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXMgZm9yIGJhdGNoIGZhY3Rvcml6YXRpb24uIiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgZF9NLCBEZW1vIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDAsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiB0cnVlLAogICAgImNvbXBsZXhpdHlfbGV2ZWwiOiAiYmFzaWMiCiAgfSwKICB7CiAgICAidGl0bGUiOiAiYmxvY2twcmltZXM6IENvbXByZXNzaW9uIFRocm91Z2ggRGlzdGFuY2UiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuSW5zdGVhZCBvZiBzdG9yaW5nIGZ1bGwgZmFjdG9yaXphdGlvbnMsIHdlIGNhbiBlbmNvZGU6IDEuIEEgcmVmZXJlbmNlIHBvaW50IChhbmNob3IgZmFjdG9yaXphdGlvbikgMi4gRGlzdGFuY2UgdmVjdG9ycyB0byBuZWFyYnkgbnVtYmVycyAqKkFsZ29yaXRobSoqOiAgYGBgIGZ1bmN0aW9uIGVuY29kZV9ibG9jayhudW1iZXJzKTogICAgIGFuY2hvciA9IGdlb21ldHJpY19tZWRpYW4obnVtYmVycykgICAgIHJldHVybiBbYW5jaG9yLCBbZGlzdGFuY2VfdmVjdG9yKG4sIGFuY2hvcikgZm9yIG4gaW4gbnVtYmVyc11dIGBgYCBXaGF0IGlzIHRoZSBjb21wcmVzc2lvbiByYXRpbyBjb21wYXJlZCB0byBuYWl2ZSBzdG9yYWdlP1xuXG4hISBLZXkgQ29uY2VwdHNcbmZhY3Rvcml6YXRpb24sIEFsZ29yaXRobSwgRGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMjIENvbXByZXNzaW9uIFRocm91Z2ggRGlzdGFuY2Vcbkluc3RlYWQgb2Ygc3RvcmluZyBmdWxsIGZhY3Rvcml6YXRpb25zLCB3ZSBjYW4gZW5jb2RlOlxuMS4gQSByZWZlcmVuY2UgcG9pbnQgKGFuY2hvciBmYWN0b3JpemF0aW9uKVxuMi4gRGlzdGFuY2UgdmVjdG9ycyB0byBuZWFyYnkgbnVtYmVyc1xuXG4qKkFsZ29yaXRobSoqOiBcbmBgYFxuZnVuY3Rpb24gZW5jb2RlX2Jsb2NrKG51bWJlcnMpOlxuICAgIGFuY2hvciA9IGdlb21ldHJpY19tZWRpYW4obnVtYmVycylcbiAgICByZXR1cm4gW2FuY2hvciwgW2Rpc3RhbmNlX3ZlY3RvcihuLCBhbmNob3IpIGZvciBuIGluIG51bWJlcnNdXVxuYGBgXG5cbldoYXQgaXMgdGhlIGNvbXByZXNzaW9uIHJhdGlvIGNvbXBhcmVkIHRvIG5haXZlIHN0b3JhZ2U/XG5cblxuISEgVGFnc1xucXVlc3Rpb24gY29kZSBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBhbGdvcml0aG0gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInRhZ3MiOiAicXVlc3Rpb24gY29kZSBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBhbGdvcml0aG0gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTM4NDYzIiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTkzODQ2MyIsCiAgICAic3VtbWFyeSI6ICJJbnN0ZWFkIG9mIHN0b3JpbmcgZnVsbCBmYWN0b3JpemF0aW9ucywgd2UgY2FuIGVuY29kZTogMS4gQSByZWZlcmVuY2UgcG9pbnQgKGFuY2hvciBmYWN0b3JpemF0aW9uKSAyLiBEaXN0YW5jZSB2ZWN0b3JzIHRvIG5lYXJieSBudW1iZXJzICoqQWxnb3JpdGhtKio6ICBgYGAgZnVuY3Rpb24gZW5jb2RlX2Jsb2NrKG51bWJlcnMpOiAgICAgYW5jaG9yID0gZ2VvbWV0cmljX21lZGlhbihudW1iZXJzKSAgICAgcmV0dXJuIFthbmNob3IsIFtkaXN0YW5jZV92ZWN0b3IobiwgYW5jaG9yKSBmb3IgbiBpbiBudW1iZXJzXV0gYGBgIFdoYXQgaXMgdGhlIGNvbXByZXNzaW9uIHJhdGlvIGNvbXBhcmVkIHRvIG5haXZlIHN0b3JhZ2U/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiZmFjdG9yaXphdGlvbiwgQWxnb3JpdGhtLCBEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJpbnRlcm1lZGlhdGUiCiAgfSwKICB7CiAgICAidGl0bGUiOiAiYmxvY2twcmltZXM6IEFwcGxpY2F0aW9ucyB0byBDcnlwdG9ncmFwaHkiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuXG5cbiEhIEtleSBDb25jZXB0c1xuXG5cbiEhIENvbnRlbnRcbiMjIEFwcGxpY2F0aW9ucyB0byBDcnlwdG9ncmFwaHlcblxuXG4hISBUYWdzXG5ibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBzZWN1cml0eSIsCiAgICAidGFncyI6ICJibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBzZWN1cml0eSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjMiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgxOTM4NDYzIiwKICAgICJzdW1tYXJ5IjogIiIsCiAgICAia2V5X2NvbmNlcHRzIjogIiIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJhZHZhbmNlZCIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogUlNBIEtleSBEaXN0YW5jZSBBbmFseXNpcyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5Gb3IgUlNBIG1vZHVsaSBOXHUyMDgxID0gcFx1MjA4MXFcdTIwODEgYW5kIE5cdTIwODIgPSBwXHUyMDgycVx1MjA4MiwgdGhlIGRpc3RhbmNlIGQoTlx1MjA4MSxOXHUyMDgyKSByZXZlYWxzIHN0cnVjdHVyYWwgc2ltaWxhcml0eS4gKipTZWN1cml0eSBJbXBsaWNhdGlvbioqOiBJZiBkKE5cdTIwODEsTlx1MjA4MikgPCB0aHJlc2hvbGQsIHRoZSBrZXlzIG1heSBzaGFyZSB2dWxuZXJhYmlsaXRpZXMuICoqUHJvb2YgU2tldGNoKio6IENsb3NlIGRpc3RhbmNlcyBpbXBseSBzaW1pbGFyIHByaW1lIHN0cnVjdHVyZXMsIHBvdGVudGlhbGx5IGVuYWJsaW5nIGNyb3NzLWtleSBhdHRhY2tzIHRocm91Z2ggc2hhcmVkIGZhY3Rvcml6YXRpb24gc2hvcnRjdXRzLiAqKkV4YW1wbGUqKjogSWYgTlx1MjA4MSA9IDc3ID0gN1x1MDBkNzExIGFuZCBOXHUyMDgyID0gOTEgPSA3XHUwMGQ3MTMsIHRoZXkgc2hhcmUgdGhlIHByaW1lIDcsIGxlYWRpbmcgdG8gZ2NkKE5cdTIwODEsTlx1MjA4MikgPSA3LiBDb3VsZCB3ZSBkZXZlbG9wIGRpc3RhbmNlLWJhc2VkIFJTQSBrZXkgdmFsaWRhdGlvbj9cblxuISEgS2V5IENvbmNlcHRzXG5Qcm9vZiwgRXhhbXBsZSwgU2VjdXJpdHkgSW1wbGljYXRpb24sIERpc3RhbmNlLCBQcm9vZiBTa2V0Y2gsIGRpc3RhbmNlLCBmYWN0b3JpemF0aW9uLCBwcmltZVxuXG4hISBDb250ZW50XG4jIyMgUlNBIEtleSBEaXN0YW5jZSBBbmFseXNpc1xuRm9yIFJTQSBtb2R1bGkgTlx1MjA4MSA9IHBcdTIwODFxXHUyMDgxIGFuZCBOXHUyMDgyID0gcFx1MjA4MnFcdTIwODIsIHRoZSBkaXN0YW5jZSBkKE5cdTIwODEsTlx1MjA4MikgcmV2ZWFscyBzdHJ1Y3R1cmFsIHNpbWlsYXJpdHkuXG5cbioqU2VjdXJpdHkgSW1wbGljYXRpb24qKjogSWYgZChOXHUyMDgxLE5cdTIwODIpIDwgdGhyZXNob2xkLCB0aGUga2V5cyBtYXkgc2hhcmUgdnVsbmVyYWJpbGl0aWVzLlxuXG4qKlByb29mIFNrZXRjaCoqOiBDbG9zZSBkaXN0YW5jZXMgaW1wbHkgc2ltaWxhciBwcmltZSBzdHJ1Y3R1cmVzLCBwb3RlbnRpYWxseSBlbmFibGluZyBjcm9zcy1rZXkgYXR0YWNrcyB0aHJvdWdoIHNoYXJlZCBmYWN0b3JpemF0aW9uIHNob3J0Y3V0cy5cblxuKipFeGFtcGxlKio6IElmIE5cdTIwODEgPSA3NyA9IDdcdTAwZDcxMSBhbmQgTlx1MjA4MiA9IDkxID0gN1x1MDBkNzEzLCB0aGV5IHNoYXJlIHRoZSBwcmltZSA3LCBsZWFkaW5nIHRvIGdjZChOXHUyMDgxLE5cdTIwODIpID0gNy5cblxuQ291bGQgd2UgZGV2ZWxvcCBkaXN0YW5jZS1iYXNlZCBSU0Ega2V5IHZhbGlkYXRpb24/XG5cblxuISEgVGFnc1xucHJvb2YgZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIHNlY3VyaXR5IGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRlbW8gc2VjdXJpdHkgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MTkzODQ2MyIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjMiLAogICAgInN1bW1hcnkiOiAiRm9yIFJTQSBtb2R1bGkgTlx1MjA4MSA9IHBcdTIwODFxXHUyMDgxIGFuZCBOXHUyMDgyID0gcFx1MjA4MnFcdTIwODIsIHRoZSBkaXN0YW5jZSBkKE5cdTIwODEsTlx1MjA4MikgcmV2ZWFscyBzdHJ1Y3R1cmFsIHNpbWlsYXJpdHkuICoqU2VjdXJpdHkgSW1wbGljYXRpb24qKjogSWYgZChOXHUyMDgxLE5cdTIwODIpIDwgdGhyZXNob2xkLCB0aGUga2V5cyBtYXkgc2hhcmUgdnVsbmVyYWJpbGl0aWVzLiAqKlByb29mIFNrZXRjaCoqOiBDbG9zZSBkaXN0YW5jZXMgaW1wbHkgc2ltaWxhciBwcmltZSBzdHJ1Y3R1cmVzLCBwb3RlbnRpYWxseSBlbmFibGluZyBjcm9zcy1rZXkgYXR0YWNrcyB0aHJvdWdoIHNoYXJlZCBmYWN0b3JpemF0aW9uIHNob3J0Y3V0cy4gKipFeGFtcGxlKio6IElmIE5cdTIwODEgPSA3NyA9IDdcdTAwZDcxMSBhbmQgTlx1MjA4MiA9IDkxID0gN1x1MDBkNzEzLCB0aGV5IHNoYXJlIHRoZSBwcmltZSA3LCBsZWFkaW5nIHRvIGdjZChOXHUyMDgxLE5cdTIwODIpID0gNy4gQ291bGQgd2UgZGV2ZWxvcCBkaXN0YW5jZS1iYXNlZCBSU0Ega2V5IHZhbGlkYXRpb24/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiUHJvb2YsIEV4YW1wbGUsIFNlY3VyaXR5IEltcGxpY2F0aW9uLCBEaXN0YW5jZSwgUHJvb2YgU2tldGNoLCBkaXN0YW5jZSwgZmFjdG9yaXphdGlvbiwgcHJpbWUiLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiB0cnVlLAogICAgImhhc19kZW1vIjogdHJ1ZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImJhc2ljIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBGZXJtYXQgTnVtYmVyIENvbm5lY3Rpb25zIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcblxuXG4hISBLZXkgQ29uY2VwdHNcblxuXG4hISBDb250ZW50XG4jIyBGZXJtYXQgTnVtYmVyIENvbm5lY3Rpb25zXG5cblxuISEgVGFnc1xuYmxvY2twcmltZXMgYmxvY2twcmltZXMgbnVtYmVyLXRoZW9yeSIsCiAgICAidGFncyI6ICJibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBudW1iZXItdGhlb3J5IiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MTkzODQ2MyIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjMiLAogICAgInN1bW1hcnkiOiAiIiwKICAgICJrZXlfY29uY2VwdHMiOiAiIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDAsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImJhc2ljIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBEaXN0YW5jZSB0byBGZXJtYXQgTnVtYmVycyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5GZXJtYXQgbnVtYmVycyBGXHUyMDk5ID0gMl4oMlx1MjA3ZikgKyAxIHNlcnZlIGFzIHJlZmVyZW5jZSBwb2ludHMgaW4gcHJpbWUgc3BhY2UuICoqT2JzZXJ2YXRpb24qKjogTnVtYmVycyBuZWFyIEZlcm1hdCBudW1iZXJzIGluIGRpc3RhbmNlIG1ldHJpYyBvZnRlbiBleGhpYml0IHNwZWNpYWwgcHJvcGVydGllcy4gKipEZW1vKio6IEZcdTIwODAgPSAzLCBGXHUyMDgxID0gNSwgRlx1MjA4MiA9IDE3LCBGXHUyMDgzID0gMjU3IERpc3RhbmNlIGFuYWx5c2lzIHJldmVhbHMgY2x1c3RlcmluZyBhcm91bmQgcG93ZXJzIG9mIDIuICoqT3BlbiBRdWVzdGlvbioqOiBEb2VzIHByb3hpbWl0eSB0byBGZXJtYXQgbnVtYmVycyBwcmVkaWN0IHByaW1hbGl0eSB0ZXN0aW5nIGVmZmljaWVuY3k/XG5cbiEhIEtleSBDb25jZXB0c1xubWV0cmljLCBEaXN0YW5jZSwgRGVtbywgT3BlbiBRdWVzdGlvbiwgZGlzdGFuY2UsIE9ic2VydmF0aW9uLCBwcmltZVxuXG4hISBDb250ZW50XG4jIyMgRGlzdGFuY2UgdG8gRmVybWF0IE51bWJlcnNcbkZlcm1hdCBudW1iZXJzIEZcdTIwOTkgPSAyXigyXHUyMDdmKSArIDEgc2VydmUgYXMgcmVmZXJlbmNlIHBvaW50cyBpbiBwcmltZSBzcGFjZS5cblxuKipPYnNlcnZhdGlvbioqOiBOdW1iZXJzIG5lYXIgRmVybWF0IG51bWJlcnMgaW4gZGlzdGFuY2UgbWV0cmljIG9mdGVuIGV4aGliaXQgc3BlY2lhbCBwcm9wZXJ0aWVzLlxuXG4qKkRlbW8qKjogRlx1MjA4MCA9IDMsIEZcdTIwODEgPSA1LCBGXHUyMDgyID0gMTcsIEZcdTIwODMgPSAyNTdcbkRpc3RhbmNlIGFuYWx5c2lzIHJldmVhbHMgY2x1c3RlcmluZyBhcm91bmQgcG93ZXJzIG9mIDIuXG5cbioqT3BlbiBRdWVzdGlvbioqOiBEb2VzIHByb3hpbWl0eSB0byBGZXJtYXQgbnVtYmVycyBwcmVkaWN0IHByaW1hbGl0eSB0ZXN0aW5nIGVmZmljaWVuY3k/XG5cblxuISEgVGFnc1xuZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidGFncyI6ICJkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRlbW8gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MTkzODQ2NCIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjQiLAogICAgInN1bW1hcnkiOiAiRmVybWF0IG51bWJlcnMgRlx1MjA5OSA9IDJeKDJcdTIwN2YpICsgMSBzZXJ2ZSBhcyByZWZlcmVuY2UgcG9pbnRzIGluIHByaW1lIHNwYWNlLiAqKk9ic2VydmF0aW9uKio6IE51bWJlcnMgbmVhciBGZXJtYXQgbnVtYmVycyBpbiBkaXN0YW5jZSBtZXRyaWMgb2Z0ZW4gZXhoaWJpdCBzcGVjaWFsIHByb3BlcnRpZXMuICoqRGVtbyoqOiBGXHUyMDgwID0gMywgRlx1MjA4MSA9IDUsIEZcdTIwODIgPSAxNywgRlx1MjA4MyA9IDI1NyBEaXN0YW5jZSBhbmFseXNpcyByZXZlYWxzIGNsdXN0ZXJpbmcgYXJvdW5kIHBvd2VycyBvZiAyLiAqKk9wZW4gUXVlc3Rpb24qKjogRG9lcyBwcm94aW1pdHkgdG8gRmVybWF0IG51bWJlcnMgcHJlZGljdCBwcmltYWxpdHkgdGVzdGluZyBlZmZpY2llbmN5PyIsCiAgICAia2V5X2NvbmNlcHRzIjogIm1ldHJpYywgRGlzdGFuY2UsIERlbW8sIE9wZW4gUXVlc3Rpb24sIGRpc3RhbmNlLCBPYnNlcnZhdGlvbiwgcHJpbWUiLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiBmYWxzZSwKICAgICJoYXNfZGVtbyI6IHRydWUsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogQ29tcHV0YXRpb25hbCBJbXBsaWNhdGlvbnMiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOiAxLiBQcmVkaWN0aXZlIGNvbXBsZXhpdHkgYW5hbHlzaXMgMi4gT3B0aW1pemVkIGZhY3Rvcml6YXRpb24gcm91dGVzICAgMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHMgNC4gUGF0dGVybiBkaXNjb3ZlcnkgaW4gbnVtYmVyIHNlcXVlbmNlcyAqKlJlc2VhcmNoIERpcmVjdGlvbioqOiBDYW4gd2UgZXh0ZW5kIHRoaXMgZnJhbWV3b3JrIHRvIGFsZ2VicmFpYyBpbnRlZ2VycyBhbmQgb3RoZXIgbWF0aGVtYXRpY2FsIHN0cnVjdHVyZXM/XG5cbiEhIEtleSBDb25jZXB0c1xubWV0cmljLCBSZXNlYXJjaCBEaXJlY3Rpb24sIGNvbXBsZXhpdHksIGRpc3RhbmNlLCBmYWN0b3JpemF0aW9uXG5cbiEhIENvbnRlbnRcbiMjIyBDb21wdXRhdGlvbmFsIEltcGxpY2F0aW9uc1xuVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOlxuMS4gUHJlZGljdGl2ZSBjb21wbGV4aXR5IGFuYWx5c2lzXG4yLiBPcHRpbWl6ZWQgZmFjdG9yaXphdGlvbiByb3V0ZXMgIFxuMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHNcbjQuIFBhdHRlcm4gZGlzY292ZXJ5IGluIG51bWJlciBzZXF1ZW5jZXNcblxuKipSZXNlYXJjaCBEaXJlY3Rpb24qKjogQ2FuIHdlIGV4dGVuZCB0aGlzIGZyYW1ld29yayB0byBhbGdlYnJhaWMgaW50ZWdlcnMgYW5kIG90aGVyIG1hdGhlbWF0aWNhbCBzdHJ1Y3R1cmVzP1xuXG5cbiEhIFRhZ3NcbnF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0YWdzIjogInF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MTkzODQ2NCIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODE5Mzg0NjQiLAogICAgInN1bW1hcnkiOiAiVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOiAxLiBQcmVkaWN0aXZlIGNvbXBsZXhpdHkgYW5hbHlzaXMgMi4gT3B0aW1pemVkIGZhY3Rvcml6YXRpb24gcm91dGVzICAgMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHMgNC4gUGF0dGVybiBkaXNjb3ZlcnkgaW4gbnVtYmVyIHNlcXVlbmNlcyAqKlJlc2VhcmNoIERpcmVjdGlvbioqOiBDYW4gd2UgZXh0ZW5kIHRoaXMgZnJhbWV3b3JrIHRvIGFsZ2VicmFpYyBpbnRlZ2VycyBhbmQgb3RoZXIgbWF0aGVtYXRpY2FsIHN0cnVjdHVyZXM/IiwKICAgICJrZXlfY29uY2VwdHMiOiAibWV0cmljLCBSZXNlYXJjaCBEaXJlY3Rpb24sIGNvbXBsZXhpdHksIGRpc3RhbmNlLCBmYWN0b3JpemF0aW9uIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDEsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImFkdmFuY2VkIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBDb25jbHVzaW9uIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkJsb2NrIHByaW1lIGRpc3RhbmNlIG1ldHJpY3MgdHJhbnNmb3JtIGRpc2NyZXRlIG51bWJlciB0aGVvcnkgaW50byBjb250aW51b3VzIGdlb21ldHJpYyBvcHRpbWl6YXRpb24uIFRoaXMgZW5hYmxlcyBuZXcgY29tcHV0YXRpb25hbCBzaG9ydGN1dHMgYW5kIHJldmVhbHMgaGlkZGVuIHBhdHRlcm5zIGluIG1hdGhlbWF0aWNhbCBzdHJ1Y3R1cmVzLiAqKkZ1dHVyZSBXb3JrKio6IEludmVzdGlnYXRlIGRpc3RhbmNlLXByZXNlcnZpbmcgdHJhbnNmb3JtYXRpb25zIGFuZCB0aGVpciBpbXBhY3Qgb24gYWxnb3JpdGhtaWMgY29tcGxleGl0eS4gSG93IG1pZ2h0IHF1YW50dW0gY29tcHV0aW5nIGNoYW5nZSB0aGVzZSBkaXN0YW5jZSByZWxhdGlvbnNoaXBzP1xuXG4hISBLZXkgQ29uY2VwdHNcbmRpc3RhbmNlLCBGdXR1cmUgV29yaywgY29tcGxleGl0eSwgcHJpbWVcblxuISEgQ29udGVudFxuIyMgQ29uY2x1c2lvblxuXG5CbG9jayBwcmltZSBkaXN0YW5jZSBtZXRyaWNzIHRyYW5zZm9ybSBkaXNjcmV0ZSBudW1iZXIgdGhlb3J5IGludG8gY29udGludW91cyBnZW9tZXRyaWMgb3B0aW1pemF0aW9uLiBUaGlzIGVuYWJsZXMgbmV3IGNvbXB1dGF0aW9uYWwgc2hvcnRjdXRzIGFuZCByZXZlYWxzIGhpZGRlbiBwYXR0ZXJucyBpbiBtYXRoZW1hdGljYWwgc3RydWN0dXJlcy5cblxuKipGdXR1cmUgV29yayoqOiBJbnZlc3RpZ2F0ZSBkaXN0YW5jZS1wcmVzZXJ2aW5nIHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlaXIgaW1wYWN0IG9uIGFsZ29yaXRobWljIGNvbXBsZXhpdHkuXG5cbkhvdyBtaWdodCBxdWFudHVtIGNvbXB1dGluZyBjaGFuZ2UgdGhlc2UgZGlzdGFuY2UgcmVsYXRpb25zaGlwcz9cblxuISEgVGFnc1xucXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInRhZ3MiOiAicXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTM4NDY0IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTkzODQ2NCIsCiAgICAic3VtbWFyeSI6ICJCbG9jayBwcmltZSBkaXN0YW5jZSBtZXRyaWNzIHRyYW5zZm9ybSBkaXNjcmV0ZSBudW1iZXIgdGhlb3J5IGludG8gY29udGludW91cyBnZW9tZXRyaWMgb3B0aW1pemF0aW9uLiBUaGlzIGVuYWJsZXMgbmV3IGNvbXB1dGF0aW9uYWwgc2hvcnRjdXRzIGFuZCByZXZlYWxzIGhpZGRlbiBwYXR0ZXJucyBpbiBtYXRoZW1hdGljYWwgc3RydWN0dXJlcy4gKipGdXR1cmUgV29yayoqOiBJbnZlc3RpZ2F0ZSBkaXN0YW5jZS1wcmVzZXJ2aW5nIHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlaXIgaW1wYWN0IG9uIGFsZ29yaXRobWljIGNvbXBsZXhpdHkuIEhvdyBtaWdodCBxdWFudHVtIGNvbXB1dGluZyBjaGFuZ2UgdGhlc2UgZGlzdGFuY2UgcmVsYXRpb25zaGlwcz8iLAogICAgImtleV9jb25jZXB0cyI6ICJkaXN0YW5jZSwgRnV0dXJlIFdvcmssIGNvbXBsZXhpdHksIHByaW1lIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDEsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImludGVybWVkaWF0ZSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJ0aGVvcmVtMSIsCiAgICAidGV4dCI6ICIjIEZ1bmRhbWVudGFsIFRoZW9yZW0gb2YgQXJpdGhtZXRpY1xuXG4qKlRoZW9yZW0qKjogRXZlcnkgaW50ZWdlciBncmVhdGVyIHRoYW4gMSBpcyBlaXRoZXIgcHJpbWUgb3IgY2FuIGJlIHVuaXF1ZWx5IGZhY3RvcmVkIGludG8gcHJpbWUgbnVtYmVycy5cblxuKipQcm9vZioqOiBcbjEuIEV4aXN0ZW5jZTogQXNzdW1lIHNvbWUgaW50ZWdlciBuID4gMSBjYW5ub3QgYmUgZmFjdG9yZWQuIFxuMi4gTGV0IFMgYmUgdGhlIHNldCBvZiBhbGwgc3VjaCBpbnRlZ2Vycy5cbjMuIEJ5IHdlbGwtb3JkZXJpbmcsIFMgaGFzIGEgbWluaW11bSBlbGVtZW50IG0uXG40LiBTaW5jZSBtIGNhbm5vdCBiZSBmYWN0b3JlZCwgbSBtdXN0IGJlIHByaW1lLlxuNS4gVGhpcyBjb250cmFkaWN0cyBvdXIgYXNzdW1wdGlvbi5cblxuVGhlcmVmb3JlLCBldmVyeSBpbnRlZ2VyIGNhbiBiZSBmYWN0b3JlZCBpbnRvIHByaW1lcy5cblxuKipEZW1vKio6IDEyID0gMlx1MDBiMiBcdTAwZDcgMywgMTUgPSAzIFx1MDBkNyA1LCAzMCA9IDIgXHUwMGQ3IDMgXHUwMGQ3IDVcblxuVGhpcyB0aGVvcmVtIGlzIGZ1bmRhbWVudGFsIHRvIG51bWJlciB0aGVvcnkgYW5kIGNyeXB0b2dyYXBoeS5cblxuSG93IGRvZXMgdGhpcyByZWxhdGUgdG8gdGhlIGRpc3RhbmNlIG1ldHJpY3MgaW4gcHJpbWUgc3BhY2U/XG4iLAogICAgInRhZ3MiOiAicHJvb2YgZGVtbyBxdWVzdGlvbiB0ZXh0IG1kIGNvbXByZXNzZWQiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgxOTM4NDY0IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MTkzODQ2NCIKICB9Cl0KfTsKPC9zY3JpcHQ+CjwvaGVhZD4KPGJvZHk+CjxkaXYgaWQ9InRpZGRseXdpa2kiPgo8aDE+Q29tcGlsZWQgV2lraTwvaDE+CjxwPlRoaXMgd2lraSBjb250YWlucyAxOCB0aWRkbGVycyBjb21waWxlZCBmcm9tIHNhbXBsZV9jb250ZW50PC9wPgo8L2Rpdj4KPC9ib2R5Pgo8L2h0bWw+",
    "tags": "binary attachment",
    "type": "text/html",
    "created": "20250802082912819",
    "modified": "20250802082912819",
    "_canonical_uri": "data:text/html;base64,"
  },
  {
    "title": "README",
    "text": "# TiddlyWiki Compiler\n\nA powerful tool for compiling files from directories into structured TiddlyWiki files with support for various media types, advanced compression, and intelligent content analysis.\n\n## Features\n\n### \ud83d\udd0d **Smart Content Analysis**\n- Automatic pattern detection for math content, proofs, algorithms, and more\n- Intelligent tagging based on content structure and patterns\n- Follow-up question detection and research direction identification\n- Complexity level estimation (basic, intermediate, advanced)\n\n### \ud83d\udcda **Blockprimes.md Structure Breaking**\n- Automatic breakdown of large markdown files into structured tiddlers\n- Summary extraction and key concept identification\n- Special handling for math content with distance-metric awareness\n- Proof, demo, and example pattern recognition\n\n### \ud83d\udddc\ufe0f **Advanced Compression**\n- Distance-metric based compression using blockprimes-style computational representations\n- Integration with aemergent codec system for optimal compression\n- math pattern recognition for efficient encoding\n- Hybrid compression strategies\n\n### \ud83d\udcc1 **Multi-Format Support**\n- Text files (markdown, txt, python, json, yaml)\n- Images (png, jpg, gif, etc.) with base64 encoding\n- Videos and audio files\n- Binary file support with MIME type detection\n\n### \ud83c\udff7\ufe0f **Intelligent Tagging System**\n- Automatic tag generation based on content patterns\n- Special tags for math concepts, proofs, algorithms\n- Security and cryptography pattern detection\n- Follow-up questions and research directions\n\n## Installation\n\n```bash\n# Clone or copy the tiddlywiki_compiler directory\ncd tiddlywiki_compiler\n\n# Optional: Install aemergent for advanced compression\npip install -e ../aemergent  # if aemergent is available\n```\n\n## Quick Start\n\n### Basic Usage\n\n```python\nfrom main import TiddlyWikiCompiler\n\n# Compile a directory into a TiddlyWiki\ncompiler = TiddlyWikiCompiler(\"source_directory\", \"output_wiki.html\")\ncompiler.compile()\n```\n\n### Command Line Usage\n\n```bash\npython main.py source_directory -o output_wiki.html\npython main.py source_directory --no-compression  # disable compression\n```\n\n### Demo\n\n```bash\npython demo.py\n```\n\nThis creates sample content and generates `demo_wiki.html` to showcase the system's capabilities.\n\n## Project Structure\n\n```\ntiddlywiki_compiler/\n\u251c\u2500\u2500 main.py              # Main compiler class and CLI\n\u251c\u2500\u2500 compression.py       # Advanced compression system\n\u251c\u2500\u2500 wiki_template.py     # TiddlyWiki HTML template generator\n\u251c\u2500\u2500 demo.py             # Demonstration script\n\u251c\u2500\u2500 sample_blockprimes.md # Sample math content\n\u2514\u2500\u2500 README.md           # This file\n```\n\n## Advanced Features\n\n### Distance-Metric Compression\n\nThe compiler includes a novel compression system inspired by blockprimes computational distance metrics:\n\n```python\nfrom compression import DistanceMetricCompressor\n\ncompressor = DistanceMetricCompressor()\ncompressed = compressor.encode_via_distances(text)\n```\n\nThis system:\n- Recognizes math sequences (primes, fibonacci, factorials)\n- Detects computational complexity patterns\n- Encodes content based on proximity to math concepts\n- Provides superior compression for math/technical content\n\n### Blockprimes Content Parsing\n\nFor `blockprimes.md` style content, the compiler automatically:\n\n1. **Splits by sections** (# and ## headers)\n2. **Extracts summaries** from first paragraphs\n3. **Identifies key concepts** (theorems, algorithms, proofs)\n4. **Detects patterns**:\n   - **Proof**: `**Proof**`, `**Theorem**`, `**Lemma**`\n   - **Demo**: `**Demo**`, `**Example**`, `**Illustration**`\n   - **algo**: `**algo**`, code blocks\n   - **Security**: RSA, cryptography patterns\n   - **Questions**: `What...?`, `How...?`, `**Research Direction**`\n\n### Custom Tagging\n\nThe system recognizes and tags:\n\n- **Mathematics**: formulas, equations, math symbols\n- **Proofs**: formal proof structures\n- **Demos**: examples and illustrations  \n- **Code**: algorithms and programming content\n- **Questions**: follow-up questions and research directions\n- **Security**: cryptographic concepts\n- **Complexity**: computational complexity analysis\n\n## Example Output\n\nGiven a `blockprimes.md` file, the compiler generates multiple tiddlers:\n\n```\nblockprimes: Introduction\n\u251c\u2500\u2500 Tags: mathematics, blockprimes, number-theory, basic\n\u251c\u2500\u2500 Summary: \"Block primes represent a novel approach...\"\n\u251c\u2500\u2500 Key Concepts: prime, factorization, coordinates, space\n\u2514\u2500\u2500 Content: Full section with enhanced formatting\n\nblockprimes: Distance Metrics in Prime Space  \n\u251c\u2500\u2500 Tags: proof, demo, distance-metric, mathematics, intermediate\n\u251c\u2500\u2500 Summary: \"For numbers m = \u220fp\u1d62^a\u1d62 and n = \u220fp\u1d62^b\u1d62...\"\n\u251c\u2500\u2500 Key Concepts: Euclidean, Manhattan, distance, metric\n\u2514\u2500\u2500 Content: math formulas and examples\n```\n\n## TiddlyWiki Features\n\nThe generated HTML includes:\n- **Interactive sidebar** with search and tag filtering\n- **Responsive design** optimized for math content\n- **Tag-based navigation** with color-coded categories\n- **Full-text search** across all tiddlers\n- **math formatting** support\n- **Statistics dashboard** showing content breakdown\n\n## Configuration\n\n### Compression Options\n\n```python\ncompiler = TiddlyWikiCompiler(\"source\", \"output.html\")\n\n# Disable compression\ncompiler.compression_enabled = False\n\n# Use specific compression type\nfrom compression import create_compressor\ncompressor = create_compressor(\"distance\")  # or \"aemergent\", \"hybrid\"\n```\n\n### Custom Pattern Detection\n\n```python\n# Add custom patterns to detect_file_patterns method\ndef detect_custom_patterns(self, content):\n    tags = []\n    if re.search(r'quantum|qubits', content, re.IGNORECASE):\n        tags.append(\"quantum\")\n    return tags\n```\n\n## Integration with Aemergent\n\nWhen aemergent is available, the compiler uses:\n- `CodecSystem` for advanced math compression\n- `Combit` for bit-level optimization\n- `Pascell` for pattern-based encoding\n\nThis provides superior compression ratios for math and computational content.\n\n## Use Cases\n\n1. **Research Documentation**: Convert math research papers into interactive wikis\n2. **Educational Content**: Structure textbook material with automatic concept extraction\n3. **Code Documentation**: Combine code, documentation, and examples into searchable wikis\n4. **math Archives**: Organize and compress large collections of math content\n\n## Browser Compatibility\n\nThe generated TiddlyWiki files work in all modern browsers:\n- Chrome/Chromium\n- Firefox\n- Safari\n- Edge\n\nNo server required - everything runs client-side.\n\n## License\n\nThis project builds upon TiddlyWiki concepts and integrates with the aemergent codec system. See individual license files for specific components.\n\n## Contributing\n\nContributions welcome! Areas of interest:\n- Additional compression algorithms\n- Enhanced math pattern recognition\n- New content type support\n- UI/UX improvements\n\n## Examples\n\nSee `demo.py` for a complete working example that generates sample content and demonstrates all features of the system.",
    "tags": "proof demo question code text md compressed",
    "type": "text/x-markdown",
    "created": "20250802082912820",
    "modified": "20250802082912820"
  },
  {
    "title": "main",
    "text": "#!/usr/bin/env python3\n\"\"\"\nTiddlyWiki Compiler\nCompiles files from directories into a TiddlyWiki file with support for:\n- Text files (markdown, txt, etc.)\n- Images (png, jpg, gif, etc.) \n- Videos (mp4, webm, etc.)\n- Compression using blockprimes-style distance metrics\n- Automatic tagging and structuring\n\"\"\"\n\nimport os\nimport json\nimport base64\nimport mimetypes\nimport hashlib\nfrom pathlib import Path\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass\nimport re\nfrom datetime import datetime\n\n\n@dataclass\nclass Tiddler:\n    \"\"\"Represents a TiddlyWiki tiddler\"\"\"\n    title: str\n    text: str\n    tags: List[str] = None\n    type: str = \"text/vnd.tiddlywiki\"\n    created: str = None\n    modified: str = None\n    fields: Dict[str, Any] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if self.fields is None:\n            self.fields = {}\n        if self.created is None:\n            self.created = datetime.now().strftime(\"%Y%m%d%H%M%S%f\")[:-3]\n        if self.modified is None:\n            self.modified = self.created\n\n\nclass TiddlyWikiCompiler:\n    \"\"\"Main compiler class for creating TiddlyWiki files\"\"\"\n    \n    def __init__(self, source_dir: str, output_file: str = \"wiki.html\"):\n        self.source_dir = Path(source_dir)\n        self.output_file = output_file\n        self.tiddlers: List[Tiddler] = []\n        self.compression_enabled = True\n        \n    def detect_file_patterns(self, content: str) -> List[str]:\n        \"\"\"Detect patterns in content and return appropriate tags\"\"\"\n        tags = []\n        \n        # math patterns\n        if re.search(r'\\$.*\\$|\\\\\\(.*\\\\\\)|\\\\\\[.*\\\\\\]', content):\n            tags.append(\"mathematics\")\n        \n        # Proof patterns\n        if re.search(r'\\b(proof|theorem|lemma|corollary|proposition)\\b', content, re.IGNORECASE):\n            tags.append(\"proof\")\n            \n        # Demo/example patterns\n        if re.search(r'\\b(demo|example|illustration|show)\\b', content, re.IGNORECASE):\n            tags.append(\"demo\")\n            \n        # Question patterns\n        if re.search(r'\\?|what if|how do|can we|would it', content, re.IGNORECASE):\n            tags.append(\"question\")\n            \n        # Code patterns\n        if re.search(r'```|`[^`]+`|def |class |import ', content):\n            tags.append(\"code\")\n            \n        return tags\n    \n    def compress_content(self, content: str) -> str:\n        \"\"\"Apply blockprimes-style compression using distance metrics\"\"\"\n        try:\n            from .compression import create_compressor\n            compressor = create_compressor(\"hybrid\")\n            return compressor.compress(content)\n        except ImportError:\n            # Fallback to simple compression\n            patterns = {\n                r'\\bcomputation\\b': 'comp',\n                r'\\brepresentation\\b': 'repr', \n                r'\\bmathematical\\b': 'math',\n                r'\\balgorithm\\b': 'algo',\n                r'\\bfunction\\b': 'func',\n            }\n            \n            compressed = content\n            for pattern, replacement in patterns.items():\n                compressed = re.sub(pattern, replacement, compressed, flags=re.IGNORECASE)\n                \n            return compressed\n    \n    def process_text_file(self, file_path: Path) -> List[Tiddler]:\n        \"\"\"Process a text file and create tiddlers\"\"\"\n        content = file_path.read_text(encoding='utf-8')\n        \n        # Special handling for blockprimes.md-style content\n        if file_path.name.endswith('.md') and 'blockprimes' in file_path.name:\n            return self.parse_blockprimes_content(content, file_path.stem)\n        \n        # Regular text file processing\n        tags = self.detect_file_patterns(content)\n        tags.append(\"text\")\n        tags.append(file_path.suffix[1:])  # file extension as tag\n        \n        if self.compression_enabled:\n            content = self.compress_content(content)\n            tags.append(\"compressed\")\n        \n        tiddler = Tiddler(\n            title=file_path.stem,\n            text=content,\n            tags=tags,\n            type=\"text/x-markdown\" if file_path.suffix == \".md\" else \"text/plain\"\n        )\n        \n        return [tiddler]\n    \n    def parse_blockprimes_content(self, content: str, base_name: str) -> List[Tiddler]:\n        \"\"\"Parse blockprimes.md-style content into multiple structured tiddlers\"\"\"\n        tiddlers = []\n        \n        # Split content by sections (assuming sections start with # or ##)\n        sections = re.split(r'\\n(?=#{1,6}\\s)', content)\n        \n        for i, section in enumerate(sections):\n            if not section.strip():\n                continue\n                \n            lines = section.split('\\n')\n            title_line = lines[0] if lines else f\"{base_name}_section_{i}\"\n            \n            # Extract title from markdown header\n            title_match = re.match(r'^#{1,6}\\s*(.+)$', title_line)\n            title = title_match.group(1) if title_match else title_line\n            \n            # Create summary from first paragraph\n            content_lines = [line for line in lines[1:] if line.strip()]\n            paragraph_end = next((i for i, line in enumerate(content_lines) \n                                if line.strip() == \"\"), len(content_lines))\n            summary_lines = content_lines[:paragraph_end]\n            summary = ' '.join(summary_lines) if summary_lines else \"\"\n            \n            # Enhanced tag detection\n            tags = self.detect_file_patterns(section)\n            tags.extend([base_name, \"blockprimes\"])\n            \n            # Specific blockprimes pattern detection\n            if re.search(r'\\*\\*Proof\\*\\*|\\*\\*Theorem\\*\\*|\\*\\*Lemma\\*\\*|\\*\\*Corollary\\*\\*', section):\n                tags.append(\"proof\")\n            \n            if re.search(r'\\*\\*Demo\\*\\*|\\*\\*Example\\*\\*|\\*\\*Illustration\\*\\*', section):\n                tags.append(\"demo\")\n                \n            if re.search(r'\\*\\*algo\\*\\*|\\*\\*Procedure\\*\\*|```', section):\n                tags.append(\"algo\")\n                \n            if re.search(r'\\*\\*Security\\*\\*|\\*\\*Implication\\*\\*|RSA|cryptography', section, re.IGNORECASE):\n                tags.append(\"security\")\n                \n            if re.search(r'distance|metric|d_[EM]|geometric', section):\n                tags.append(\"distance-metric\")\n                \n            if re.search(r'Fermat|prime|factorization', section, re.IGNORECASE):\n                tags.append(\"number-theory\")\n                \n            # Check for follow-up questions and research directions\n            question_patterns = [\n                r'What.*\\?', r'How.*\\?', r'Can.*\\?', r'Could.*\\?', r'Would.*\\?',\n                r'\\*\\*Open Question\\*\\*', r'\\*\\*Research Direction\\*\\*', r'\\*\\*Future Work\\*\\*'\n            ]\n            \n            for pattern in question_patterns:\n                if re.search(pattern, section):\n                    tags.append(\"follow-up\")\n                    break\n            \n            # Detect math complexity\n            if re.search(r'O\\(.*\\)|complexity|algo', section, re.IGNORECASE):\n                tags.append(\"complexity\")\n                \n            # Structure the tiddler content with enhanced formatting\n            structured_content = f\"\"\"!! Summary\n{summary}\n\n!! Key Concepts\n{self.extract_key_concepts(section)}\n\n!! Content\n{section}\n\n!! Tags\n{' '.join(tags)}\"\"\"\n            \n            # Extract metadata\n            metadata = {\n                \"summary\": summary,\n                \"key_concepts\": self.extract_key_concepts(section),\n                \"question_count\": len(re.findall(r'\\?', section)),\n                \"has_proof\": \"proof\" in tags,\n                \"has_demo\": \"demo\" in tags,\n                \"complexity_level\": self.estimate_complexity(section)\n            }\n            \n            tiddler = Tiddler(\n                title=f\"{base_name}: {title}\",\n                text=structured_content,\n                tags=tags,\n                type=\"text/x-markdown\",\n                fields=metadata\n            )\n            \n            tiddlers.append(tiddler)\n        \n        return tiddlers\n    \n    def extract_key_concepts(self, text: str) -> str:\n        \"\"\"Extract key math and computational concepts from text\"\"\"\n        concepts = []\n        \n        # math terms\n        math_terms = re.findall(r'\\b(theorem|lemma|proof|algo|distance|metric|prime|factorization|complexity)\\b', \n                               text, re.IGNORECASE)\n        concepts.extend(list(set(math_terms)))\n        \n        # Technical symbols and notations\n        symbols = re.findall(r'd_[A-Z]|O\\([^)]+\\)|[\u2248\u2261\u2234\u2235]', text)\n        concepts.extend(symbols)\n        \n        # Formatted definitions\n        definitions = re.findall(r'\\*\\*([^*]+)\\*\\*:', text)\n        concepts.extend(definitions)\n        \n        return ', '.join(list(set(concepts))[:10])  # Limit to top 10\n    \n    def estimate_complexity(self, text: str) -> str:\n        \"\"\"Estimate the complexity level of the content\"\"\"\n        indicators = {\n            \"basic\": [\"example\", \"demo\", \"simple\"],\n            \"intermediate\": [\"theorem\", \"proof\", \"algo\"],\n            \"advanced\": [\"research\", \"open question\", \"cryptography\", \"quantum\"]\n        }\n        \n        text_lower = text.lower()\n        scores = {}\n        \n        for level, terms in indicators.items():\n            scores[level] = sum(1 for term in terms if term in text_lower)\n        \n        return max(scores, key=scores.get) if any(scores.values()) else \"basic\"\n    \n    def process_binary_file(self, file_path: Path) -> Tiddler:\n        \"\"\"Process binary files (images, videos, etc.) as data tiddlers\"\"\"\n        with open(file_path, 'rb') as f:\n            content = f.read()\n        \n        # Encode as base64\n        encoded_content = base64.b64encode(content).decode('utf-8')\n        \n        # Determine MIME type\n        mime_type, _ = mimetypes.guess_type(str(file_path))\n        if not mime_type:\n            mime_type = \"application/octet-stream\"\n        \n        tags = [\"binary\", \"attachment\"]\n        if mime_type.startswith(\"image/\"):\n            tags.append(\"image\")\n        elif mime_type.startswith(\"video/\"):\n            tags.append(\"video\")\n        elif mime_type.startswith(\"audio/\"):\n            tags.append(\"audio\")\n        \n        tiddler = Tiddler(\n            title=file_path.name,\n            text=encoded_content,\n            tags=tags,\n            type=mime_type,\n            fields={\"_canonical_uri\": f\"data:{mime_type};base64,\"}\n        )\n        \n        return tiddler\n    \n    def compile_directory(self):\n        \"\"\"Compile all files in the source directory\"\"\"\n        if not self.source_dir.exists():\n            raise FileNotFoundError(f\"Source directory {self.source_dir} not found\")\n        \n        for file_path in self.source_dir.rglob(\"*\"):\n            if file_path.is_file():\n                try:\n                    # Determine file type and process accordingly\n                    mime_type, _ = mimetypes.guess_type(str(file_path))\n                    \n                    if file_path.suffix in ['.txt', '.md', '.py', '.json', '.yaml', '.yml']:\n                        tiddlers = self.process_text_file(file_path)\n                        self.tiddlers.extend(tiddlers)\n                    else:\n                        # Binary file\n                        tiddler = self.process_binary_file(file_path)\n                        self.tiddlers.append(tiddler)\n                        \n                except Exception as e:\n                    print(f\"Error processing {file_path}: {e}\")\n    \n    def generate_wiki_html(self) -> str:\n        \"\"\"Generate the final TiddlyWiki HTML file\"\"\"\n        # Create the tiddlers JSON data\n        tiddlers_data = []\n        for tiddler in self.tiddlers:\n            tiddler_dict = {\n                \"title\": tiddler.title,\n                \"text\": tiddler.text,\n                \"tags\": \" \".join(tiddler.tags) if tiddler.tags else \"\",\n                \"type\": tiddler.type,\n                \"created\": tiddler.created,\n                \"modified\": tiddler.modified\n            }\n            tiddler_dict.update(tiddler.fields)\n            tiddlers_data.append(tiddler_dict)\n        \n        # Use the advanced template\n        try:\n            from .wiki_template import generate_tiddlywiki_html\n            return generate_tiddlywiki_html(tiddlers_data, f\"Compiled Wiki - {self.source_dir.name}\")\n        except ImportError:\n            # Fallback to basic template\n            html_template = f\"\"\"<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>Compiled Wiki</title>\n<script>\nvar $tw = {{\n    preloadTiddlers: {json.dumps(tiddlers_data, indent=2)}\n}};\n</script>\n</head>\n<body>\n<div id=\"tiddlywiki\">\n<h1>Compiled Wiki</h1>\n<p>This wiki contains {len(self.tiddlers)} tiddlers compiled from {self.source_dir}</p>\n</div>\n</body>\n</html>\"\"\"\n            \n            return html_template\n    \n    def compile(self):\n        \"\"\"Main compilation method\"\"\"\n        print(f\"Compiling directory: {self.source_dir}\")\n        self.compile_directory()\n        \n        html_content = self.generate_wiki_html()\n        \n        with open(self.output_file, 'w', encoding='utf-8') as f:\n            f.write(html_content)\n        \n        print(f\"Wiki compiled to {self.output_file} with {len(self.tiddlers)} tiddlers\")\n\n\nif __name__ == \"__main__\":\n    import argparse\n    \n    parser = argparse.ArgumentParser(description=\"Compile files into TiddlyWiki\")\n    parser.add_argument(\"source_dir\", help=\"Source directory to compile\")\n    parser.add_argument(\"-o\", \"--output\", default=\"wiki.html\", help=\"Output wiki file\")\n    parser.add_argument(\"--no-compression\", action=\"store_true\", help=\"Disable compression\")\n    \n    args = parser.parse_args()\n    \n    compiler = TiddlyWikiCompiler(args.source_dir, args.output)\n    if args.no_compression:\n        compiler.compression_enabled = False\n    \n    compiler.compile()",
    "tags": "mathematics proof demo question code text py compressed",
    "type": "text/plain",
    "created": "20250802082912821",
    "modified": "20250802082912821"
  },
  {
    "title": "wikic",
    "text": "#!/usr/bin/env python3\n\"\"\"\nwikic - TiddlyWiki Compiler\nSimple zip-like interface for compiling directories into TiddlyWiki files\n\nUsage:\n    wikic output.html directory\n    wikic wikihtml .\n    wikic myproject.html src/\n\"\"\"\n\nimport sys\nimport argparse\nfrom pathlib import Path\n\n# Import our compiler\nfrom main import TiddlyWikiCompiler\n\n\ndef main():\n    \"\"\"Main CLI interface with zip-like syntax\"\"\"\n    \n    # Simple argument parsing - zip-like interface\n    parser = argparse.ArgumentParser(\n        description='Compile directories into TiddlyWiki files',\n        usage='wikic OUTPUT.html DIRECTORY [options]',\n        add_help=False\n    )\n    \n    # Positional arguments (like zip)\n    parser.add_argument('output', help='Output wiki file (e.g., wiki.html)')\n    parser.add_argument('directory', default='.', nargs='?', help='Directory to compile (default: current directory)')\n    \n    # Optional flags\n    parser.add_argument('-h', '--help', action='help', help='Show this help message')\n    parser.add_argument('--no-compression', action='store_true', help='Disable compression')\n    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')\n    parser.add_argument('--version', action='version', version='wikic 1.0.0')\n    \n    # Handle no arguments\n    if len(sys.argv) == 1:\n        print(\"wikic - TiddlyWiki Compiler\")\n        print(\"\")\n        print(\"Usage:\")\n        print(\"  wikic output.html directory     # Compile directory into wiki\")\n        print(\"  wikic wikihtml .                # Compile current directory\")\n        print(\"  wikic project.html src/         # Compile src/ directory\")\n        print(\"\")\n        print(\"Options:\")\n        print(\"  --no-compression               # Disable compression\")\n        print(\"  -v, --verbose                  # Verbose output\")\n        print(\"  -h, --help                     # Show help\")\n        print(\"  --version                      # Show version\")\n        print(\"\")\n        print(\"Examples:\")\n        print(\"  wikic docs.html .              # Current directory -> docs.html\")\n        print(\"  wikic research.html papers/    # papers/ -> research.html\")\n        print(\"  wikic wiki.html ~/Documents    # Documents -> wiki.html\")\n        sys.exit(0)\n    \n    args = parser.parse_args()\n    \n    # Validate arguments\n    output_file = args.output\n    source_dir = Path(args.directory)\n    \n    # Ensure output has .html extension\n    if not output_file.endswith('.html'):\n        output_file += '.html'\n    \n    # Check if source directory exists\n    if not source_dir.exists():\n        print(f\"Error: Directory '{source_dir}' does not exist\")\n        sys.exit(1)\n    \n    if not source_dir.is_dir():\n        print(f\"Error: '{source_dir}' is not a directory\")\n        sys.exit(1)\n    \n    # Show what we're doing (like zip)\n    if args.verbose:\n        print(f\"wikic: compiling '{source_dir}' -> '{output_file}'\")\n    else:\n        print(f\"  compiling: {source_dir} -> {output_file}\")\n    \n    try:\n        # Create and run compiler\n        compiler = TiddlyWikiCompiler(str(source_dir), output_file)\n        compiler.compression_enabled = not args.no_compression\n        \n        # Compile with progress indication\n        if args.verbose:\n            print(f\"  scanning: {source_dir}\")\n        \n        compiler.compile()\n        \n        # Success message (like zip)\n        tiddler_count = len(compiler.tiddlers)\n        file_size = Path(output_file).stat().st_size\n        \n        if args.verbose:\n            print(f\"  created: {output_file} ({file_size:,} bytes, {tiddler_count} tiddlers)\")\n            \n            # Show tag statistics in verbose mode\n            all_tags = []\n            for tiddler in compiler.tiddlers:\n                all_tags.extend(tiddler.tags)\n            \n            if all_tags:\n                tag_counts = {}\n                for tag in all_tags:\n                    tag_counts[tag] = tag_counts.get(tag, 0) + 1\n                \n                print(\"  top tags:\", end=\"\")\n                top_tags = sorted(tag_counts.items(), key=lambda x: x[1], reverse=True)[:5]\n                for tag, count in top_tags:\n                    print(f\" {tag}({count})\", end=\"\")\n                print()\n        else:\n            print(f\"     added: {tiddler_count} tiddlers -> {output_file}\")\n    \n    except Exception as e:\n        print(f\"wikic: error: {e}\")\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()",
    "tags": "demo question code text py compressed",
    "type": "text/plain",
    "created": "20250802082912821",
    "modified": "20250802082912821"
  },
  {
    "title": "test.html",
    "text": "PCFET0NUWVBFIGh0bWw+CjxodG1sPgo8aGVhZD4KPG1ldGEgY2hhcnNldD0idXRmLTgiPgo8dGl0bGU+Q29tcGlsZWQgV2lraTwvdGl0bGU+CjxzY3JpcHQ+CnZhciAkdHcgPSB7CiAgICBwcmVsb2FkVGlkZGxlcnM6IFsKICB7CiAgICAidGl0bGUiOiAiYWxnb3JpdGhtcyIsCiAgICAidGV4dCI6ICIjIFNhbXBsZSBhbGdvXG5kZWYgZmFjdG9yaWFsKG4pOlxuICAgIFwiXCJcIlxuICAgIENvbXB1dGUgZmFjdG9yaWFsIHVzaW5nIHJlY3Vyc2l2ZSBhbGdvXG4gICAgVGltZSBjb21wbGV4aXR5OiBPKG4pXG4gICAgU3BhY2UgY29tcGxleGl0eTogTyhuKSBkdWUgdG8gcmVjdXJzaW9uXG4gICAgXCJcIlwiXG4gICAgaWYgbiA8PSAxOlxuICAgICAgICByZXR1cm4gMVxuICAgIHJldHVybiBuICogZmFjdG9yaWFsKG4gLSAxKVxuXG5kZWYgZmlib25hY2NpKG4pOlxuICAgIFwiXCJcIlxuICAgIENvbXB1dGUgRmlib25hY2NpIG51bWJlclxuICAgIERlbW9uc3RyYXRlcyBleHBvbmVudGlhbCBncm93dGggcGF0dGVyblxuICAgIFwiXCJcIlxuICAgIGlmIG4gPD0gMTpcbiAgICAgICAgcmV0dXJuIG5cbiAgICByZXR1cm4gZmlib25hY2NpKG4tMSkgKyBmaWJvbmFjY2kobi0yKVxuXG4jIEV4YW1wbGUgdXNhZ2VcbnByaW50KGZcIjUhID0ge2ZhY3RvcmlhbCg1KX1cIilcbnByaW50KGZcIkYoMTApID0ge2ZpYm9uYWNjaSgxMCl9XCIpXG4iLAogICAgInRhZ3MiOiAiZGVtbyBjb2RlIHRleHQgcHkgY29tcHJlc3NlZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3BsYWluIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyOTA4ODI1IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjkwODgyNSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJpbnRyb2R1Y3Rpb24iLAogICAgInRleHQiOiAiIyBXZWxjb21lIHRvIHRoZSBtYXRoIFdpa2lcblxuVGhpcyB3aWtpIGRlbW9uc3RyYXRlcyB0aGUgVGlkZGx5V2lraSBjb21waWxlcidzIGFiaWxpdHkgdG8gc3RydWN0dXJlIGFuZCBvcmdhbml6ZSBtYXRoIGNvbnRlbnQuXG5cbiMjIEZlYXR1cmVzXG5cbi0gKipBdXRvbWF0aWMgdGFnZ2luZyoqIGJhc2VkIG9uIGNvbnRlbnQgcGF0dGVybnNcbi0gKipEaXN0YW5jZS1tZXRyaWMgY29tcHJlc3Npb24qKiB1c2luZyBibG9ja3ByaW1lcyBjb25jZXB0cyAgXG4tICoqU3RydWN0dXJlZCB0aWRkbGVycyoqIHdpdGggc3VtbWFyaWVzIGFuZCBrZXkgY29uY2VwdHNcbi0gKipJbnRlcmFjdGl2ZSBmaWx0ZXJpbmcqKiBieSB0YWdzIGFuZCBzZWFyY2hcblxuIyMgU2FtcGxlIENvbnRlbnRcblxuVGhlIGJsb2NrcHJpbWVzLm1kIGZpbGUgaGFzIGJlZW4gYXV0b21hdGljYWxseSBicm9rZW4gZG93biBpbnRvIG11bHRpcGxlIHRpZGRsZXJzLCBlYWNoIHdpdGg6XG4tIFN1bW1hcnkgc2VjdGlvbnNcbi0gS2V5IGNvbmNlcHQgZXh0cmFjdGlvblxuLSBBdXRvbWF0aWMgdGFnZ2luZyAocHJvb2YsIGRlbW8sIHF1ZXN0aW9uLCBldGMuKVxuLSBGb2xsb3ctdXAgcXVlc3Rpb24gZGV0ZWN0aW9uXG5cbioqRXhhbXBsZSoqOiBtYXRoIHByb29mcyBhcmUgYXV0b21hdGljYWxseSB0YWdnZWQgYXMgXCJwcm9vZlwiIGFuZCBmb3JtYXR0ZWQgd2l0aCBzcGVjaWFsIHN0eWxpbmcuXG5cbldoYXQgcGF0dGVybnMgd2lsbCB5b3UgZGlzY292ZXIgaW4geW91ciBvd24gY29udGVudD9cbiIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIHRleHQgbWQgY29tcHJlc3NlZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODI5MDg4MjUiLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyOTA4ODI1IgogIH0sCiAgewogICAgInRpdGxlIjogImNvbmNlcHRzIiwKICAgICJ0ZXh0IjogIktleSBtYXRoIENvbmNlcHRzXG5cblByaW1lIE51bWJlcnM6IDIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjkuLi5cbkZpYm9uYWNjaSBTZXF1ZW5jZTogMSwgMSwgMiwgMywgNSwgOCwgMTMsIDIxLCAzNC4uLlxuRmFjdG9yaWFsczogMSwgMiwgNiwgMjQsIDEyMCwgNzIwLi4uXG5cbkRpc3RhbmNlIE1ldHJpY3M6XG4tIEV1Y2xpZGVhbjogZCh4LHkpID0gXHUyMjFhKFx1MDNhMyh4aS15aSlcdTAwYjIpXG4tIE1hbmhhdHRhbjogZCh4LHkpID0gXHUwM2EzfHhpLXlpfFxuLSBIYW1taW5nOiBudW1iZXIgb2YgZGlmZmVyaW5nIHBvc2l0aW9uc1xuXG5Db21wdXRhdGlvbmFsIENvbXBsZXhpdHk6XG4tIE8oMSk6IGNvbnN0YW50IHRpbWVcbi0gTyhsb2cgbik6IGxvZ2FyaXRobWljIFxuLSBPKG4pOiBsaW5lYXIgdGltZVxuLSBPKG4gbG9nIG4pOiBsaW5lYXJpdGhtaWNcbi0gTyhuXHUwMGIyKTogcXVhZHJhdGljIHRpbWVcblxuV2hhdCByZWxhdGlvbnNoaXBzIGV4aXN0IGJldHdlZW4gdGhlc2UgY29uY2VwdHM/XG4iLAogICAgInRhZ3MiOiAicXVlc3Rpb24gdGV4dCB0eHQgY29tcHJlc3NlZCIsCiAgICAidHlwZSI6ICJ0ZXh0L3BsYWluIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyOTA4ODI1IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjkwODgyNSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogQmxvY2twcmltZXM6IENvbXB1dGF0aW9uYWwgRGlzdGFuY2UgTWV0cmljcyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5cblxuISEgS2V5IENvbmNlcHRzXG5EaXN0YW5jZVxuXG4hISBDb250ZW50XG4jIEJsb2NrcHJpbWVzOiBDb21wdXRhdGlvbmFsIERpc3RhbmNlIE1ldHJpY3NcblxuXG4hISBUYWdzXG5ibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBudW1iZXItdGhlb3J5IiwKICAgICJ0YWdzIjogImJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIG51bWJlci10aGVvcnkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyOTA4ODI3IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjkwODgyNyIsCiAgICAic3VtbWFyeSI6ICIiLAogICAgImtleV9jb25jZXB0cyI6ICJEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogSW50cm9kdWN0aW9uIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy4gVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuICoqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLiBXaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/XG5cbiEhIEtleSBDb25jZXB0c1xuUHJvb2YsIHByaW1lLCBQcm9vZiBQYXR0ZXJuLCBmYWN0b3JpemF0aW9uLCBkaXN0YW5jZVxuXG4hISBDb250ZW50XG4jIyBJbnRyb2R1Y3Rpb25cbkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy5cblxuVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuXG5cbioqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLlxuXG5XaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/XG5cblxuISEgVGFnc1xucHJvb2YgcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0YWdzIjogInByb29mIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODI5MDg4MjciLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyOTA4ODI3IiwKICAgICJzdW1tYXJ5IjogIkJsb2NrIHByaW1lcyByZXByZXNlbnQgYSBub3ZlbCBhcHByb2FjaCB0byBjb21wdXRhdGlvbmFsIGRpc3RhbmNlIG1lYXN1cmVtZW50IGluIG1hdGhlbWF0aWNhbCBzcGFjZXMuIEJ5IGVuY29kaW5nIHByaW1lIGZhY3Rvcml6YXRpb25zIGFzIHNwYXRpYWwgY29vcmRpbmF0ZXMsIHdlIGNhbiB0cmFuc2Zvcm0gbnVtYmVyIHRoZW9yeSBwcm9ibGVtcyBpbnRvIGdlb21ldHJpYyBvcHRpbWl6YXRpb24gY2hhbGxlbmdlcy4gVGhlIGZ1bmRhbWVudGFsIGluc2lnaHQgaXMgdGhhdCBldmVyeSBjb21wb3NpdGUgbnVtYmVyIG4gY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgcG9pbnQgaW4gcHJpbWUtZmFjdG9yaXphdGlvbiBzcGFjZSwgd2hlcmUgY29vcmRpbmF0ZXMgY29ycmVzcG9uZCB0byBwcmltZSBwb3dlcnM6IG4gPSBwXHUyMDgxXmFcdTIwODEgXHUwMGQ3IHBcdTIwODJeYVx1MjA4MiBcdTAwZDcgLi4uIFx1MDBkNyBwXHUyMDk2XmFcdTIwOTYuICoqUHJvb2YgUGF0dGVybioqOiBHaXZlbiBhbnkgY29tcG9zaXRlIG51bWJlciBuLCBpdHMgdW5pcXVlIHByaW1lIGZhY3Rvcml6YXRpb24gcHJvdmlkZXMgY29vcmRpbmF0ZXMgKGFcdTIwODEsIGFcdTIwODIsIC4uLiwgYVx1MjA5NikgaW4gXHUyMTI0XHUxZDRmIHNwYWNlLiBXaGF0IGNvbXB1dGF0aW9uYWwgcGF0dGVybnMgZW1lcmdlIHdoZW4gd2UgbWVhc3VyZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGVzZSBwb2ludHM/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiUHJvb2YsIHByaW1lLCBQcm9vZiBQYXR0ZXJuLCBmYWN0b3JpemF0aW9uLCBkaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IHRydWUsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImludGVybWVkaWF0ZSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogRGlzdGFuY2UgTWV0cmljcyBpbiBQcmltZSBTcGFjZSIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5cblxuISEgS2V5IENvbmNlcHRzXG5QcmltZSwgRGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMgRGlzdGFuY2UgTWV0cmljcyBpbiBQcmltZSBTcGFjZVxuXG5cbiEhIFRhZ3NcbmJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIG51bWJlci10aGVvcnkiLAogICAgInRhZ3MiOiAiYmxvY2twcmltZXMgYmxvY2twcmltZXMgbnVtYmVyLXRoZW9yeSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODI5MDg4MjciLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyOTA4ODI3IiwKICAgICJzdW1tYXJ5IjogIiIsCiAgICAia2V5X2NvbmNlcHRzIjogIlByaW1lLCBEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogRXVjbGlkZWFuIERpc3RhbmNlIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkZvciBudW1iZXJzIG0gPSBcdTIyMGZwXHUxZDYyXmFcdTFkNjIgYW5kIG4gPSBcdTIyMGZwXHUxZDYyXmJcdTFkNjIsIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgaXM6IGRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpICoqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjogLSBDb29yZGluYXRlczogbSBcdTIxOTIgKDIsMSksIG4gXHUyMTkyICgxLDIpICAgLSBEaXN0YW5jZTogZF9FKDEyLDE4KSA9IFx1MjIxYSgoMi0xKVx1MDBiMiArICgxLTIpXHUwMGIyKSA9IFx1MjIxYTIgVGhpcyBtZXRyaWMgcHJlc2VydmVzIG11bHRpcGxpY2F0aXZlIHN0cnVjdHVyZSB3aGlsZSBlbmFibGluZyBnZW9tZXRyaWMgcmVhc29uaW5nLiBDYW4gd2UgdXNlIHRoaXMgZGlzdGFuY2UgdG8gcHJlZGljdCBjb21wdXRhdGlvbmFsIGNvbXBsZXhpdHkgb2YgZmFjdG9yaXphdGlvbiBhbGdvcml0aG1zP1xuXG4hISBLZXkgQ29uY2VwdHNcbm1ldHJpYywgRGVtbywgRGlzdGFuY2UsIGRfRSwgY29tcGxleGl0eSwgZmFjdG9yaXphdGlvbiwgZGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMjIEV1Y2xpZGVhbiBEaXN0YW5jZVxuRm9yIG51bWJlcnMgbSA9IFx1MjIwZnBcdTFkNjJeYVx1MWQ2MiBhbmQgbiA9IFx1MjIwZnBcdTFkNjJeYlx1MWQ2MiwgdGhlIEV1Y2xpZGVhbiBkaXN0YW5jZSBpczpcbmRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpXG5cbioqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjpcbi0gQ29vcmRpbmF0ZXM6IG0gXHUyMTkyICgyLDEpLCBuIFx1MjE5MiAoMSwyKSAgXG4tIERpc3RhbmNlOiBkX0UoMTIsMTgpID0gXHUyMjFhKCgyLTEpXHUwMGIyICsgKDEtMilcdTAwYjIpID0gXHUyMjFhMlxuXG5UaGlzIG1ldHJpYyBwcmVzZXJ2ZXMgbXVsdGlwbGljYXRpdmUgc3RydWN0dXJlIHdoaWxlIGVuYWJsaW5nIGdlb21ldHJpYyByZWFzb25pbmcuXG5cbkNhbiB3ZSB1c2UgdGhpcyBkaXN0YW5jZSB0byBwcmVkaWN0IGNvbXB1dGF0aW9uYWwgY29tcGxleGl0eSBvZiBmYWN0b3JpemF0aW9uIGFsZ29yaXRobXM/XG5cblxuISEgVGFnc1xuZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0YWdzIjogImRlbW8gcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSBmb2xsb3ctdXAgY29tcGxleGl0eSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODI5MDg4MjciLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyOTA4ODI3IiwKICAgICJzdW1tYXJ5IjogIkZvciBudW1iZXJzIG0gPSBcdTIyMGZwXHUxZDYyXmFcdTFkNjIgYW5kIG4gPSBcdTIyMGZwXHUxZDYyXmJcdTFkNjIsIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgaXM6IGRfRShtLG4pID0gXHUyMjFhKFx1MjIxMShhXHUxZDYyIC0gYlx1MWQ2MilcdTAwYjIpICoqRGVtbyoqOiBMZXQgbSA9IDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBhbmQgbiA9IDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMi4gVGhlbjogLSBDb29yZGluYXRlczogbSBcdTIxOTIgKDIsMSksIG4gXHUyMTkyICgxLDIpICAgLSBEaXN0YW5jZTogZF9FKDEyLDE4KSA9IFx1MjIxYSgoMi0xKVx1MDBiMiArICgxLTIpXHUwMGIyKSA9IFx1MjIxYTIgVGhpcyBtZXRyaWMgcHJlc2VydmVzIG11bHRpcGxpY2F0aXZlIHN0cnVjdHVyZSB3aGlsZSBlbmFibGluZyBnZW9tZXRyaWMgcmVhc29uaW5nLiBDYW4gd2UgdXNlIHRoaXMgZGlzdGFuY2UgdG8gcHJlZGljdCBjb21wdXRhdGlvbmFsIGNvbXBsZXhpdHkgb2YgZmFjdG9yaXphdGlvbiBhbGdvcml0aG1zPyIsCiAgICAia2V5X2NvbmNlcHRzIjogIm1ldHJpYywgRGVtbywgRGlzdGFuY2UsIGRfRSwgY29tcGxleGl0eSwgZmFjdG9yaXphdGlvbiwgZGlzdGFuY2UiLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiBmYWxzZSwKICAgICJoYXNfZGVtbyI6IHRydWUsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogTWFuaGF0dGFuIERpc3RhbmNlIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcblRoZSBMXHUwMGI5IGRpc3RhbmNlIGNhcHR1cmVzIGFkZGl0aXZlIGNvbXBsZXhpdHk6IGRfTShtLG4pID0gXHUyMjExfGFcdTFkNjIgLSBiXHUxZDYyfCAqKkV4YW1wbGUqKjogRm9yIHRoZSBzYW1lIG09MTIsIG49MTg6IGRfTSgxMiwxOCkgPSB8Mi0xfCArIHwxLTJ8ID0gMiAqKlRoZW9yZW0qKjogTWFuaGF0dGFuIGRpc3RhbmNlIGluIHByaW1lIHNwYWNlIGVxdWFscyB0aGUgbWluaW11bSBudW1iZXIgb2YgcHJpbWUgZmFjdG9yIG1vZGlmaWNhdGlvbnMgdG8gdHJhbnNmb3JtIG0gaW50byBuLiAqKlByb29mKio6IEVhY2ggdW5pdCBvZiBNYW5oYXR0YW4gZGlzdGFuY2UgY29ycmVzcG9uZHMgdG8gaW5jcmVtZW50aW5nIG9yIGRlY3JlbWVudGluZyBhIHNpbmdsZSBwcmltZSBwb3dlciBieSAxLiBIb3cgZG9lcyB0aGlzIHJlbGF0ZSB0byBlZGl0IGRpc3RhbmNlIGluIGNvbXB1dGF0aW9uYWwgc3RyaW5ncz9cblxuISEgS2V5IENvbmNlcHRzXG5Qcm9vZiwgcHJpbWUsIEV4YW1wbGUsIERpc3RhbmNlLCBkX00sIFRoZW9yZW0sIGNvbXBsZXhpdHksIGRpc3RhbmNlXG5cbiEhIENvbnRlbnRcbiMjIyBNYW5oYXR0YW4gRGlzdGFuY2VcblRoZSBMXHUwMGI5IGRpc3RhbmNlIGNhcHR1cmVzIGFkZGl0aXZlIGNvbXBsZXhpdHk6XG5kX00obSxuKSA9IFx1MjIxMXxhXHUxZDYyIC0gYlx1MWQ2MnxcblxuKipFeGFtcGxlKio6IEZvciB0aGUgc2FtZSBtPTEyLCBuPTE4OlxuZF9NKDEyLDE4KSA9IHwyLTF8ICsgfDEtMnwgPSAyXG5cbioqVGhlb3JlbSoqOiBNYW5oYXR0YW4gZGlzdGFuY2UgaW4gcHJpbWUgc3BhY2UgZXF1YWxzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBwcmltZSBmYWN0b3IgbW9kaWZpY2F0aW9ucyB0byB0cmFuc2Zvcm0gbSBpbnRvIG4uXG5cbioqUHJvb2YqKjogRWFjaCB1bml0IG9mIE1hbmhhdHRhbiBkaXN0YW5jZSBjb3JyZXNwb25kcyB0byBpbmNyZW1lbnRpbmcgb3IgZGVjcmVtZW50aW5nIGEgc2luZ2xlIHByaW1lIHBvd2VyIGJ5IDEuXG5cbkhvdyBkb2VzIHRoaXMgcmVsYXRlIHRvIGVkaXQgZGlzdGFuY2UgaW4gY29tcHV0YXRpb25hbCBzdHJpbmdzP1xuXG5cbiEhIFRhZ3NcbnByb29mIGRlbW8gcXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgcHJvb2YgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSBmb2xsb3ctdXAgY29tcGxleGl0eSIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIHByb29mIGRlbW8gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyOTA4ODI3IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjkwODgyNyIsCiAgICAic3VtbWFyeSI6ICJUaGUgTFx1MDBiOSBkaXN0YW5jZSBjYXB0dXJlcyBhZGRpdGl2ZSBjb21wbGV4aXR5OiBkX00obSxuKSA9IFx1MjIxMXxhXHUxZDYyIC0gYlx1MWQ2MnwgKipFeGFtcGxlKio6IEZvciB0aGUgc2FtZSBtPTEyLCBuPTE4OiBkX00oMTIsMTgpID0gfDItMXwgKyB8MS0yfCA9IDIgKipUaGVvcmVtKio6IE1hbmhhdHRhbiBkaXN0YW5jZSBpbiBwcmltZSBzcGFjZSBlcXVhbHMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHByaW1lIGZhY3RvciBtb2RpZmljYXRpb25zIHRvIHRyYW5zZm9ybSBtIGludG8gbi4gKipQcm9vZioqOiBFYWNoIHVuaXQgb2YgTWFuaGF0dGFuIGRpc3RhbmNlIGNvcnJlc3BvbmRzIHRvIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgYSBzaW5nbGUgcHJpbWUgcG93ZXIgYnkgMS4gSG93IGRvZXMgdGhpcyByZWxhdGUgdG8gZWRpdCBkaXN0YW5jZSBpbiBjb21wdXRhdGlvbmFsIHN0cmluZ3M/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiUHJvb2YsIHByaW1lLCBFeGFtcGxlLCBEaXN0YW5jZSwgZF9NLCBUaGVvcmVtLCBjb21wbGV4aXR5LCBkaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IHRydWUsCiAgICAiaGFzX2RlbW8iOiB0cnVlLAogICAgImNvbXBsZXhpdHlfbGV2ZWwiOiAiaW50ZXJtZWRpYXRlIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBDb21wdXRhdGlvbmFsIFNob3J0Y3V0cyB2aWEgRGlzdGFuY2UiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuXG5cbiEhIEtleSBDb25jZXB0c1xuRGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMgQ29tcHV0YXRpb25hbCBTaG9ydGN1dHMgdmlhIERpc3RhbmNlXG5cblxuISEgVGFnc1xuYmxvY2twcmltZXMgYmxvY2twcmltZXMiLAogICAgInRhZ3MiOiAiYmxvY2twcmltZXMgYmxvY2twcmltZXMiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyOTA4ODI3IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjkwODgyNyIsCiAgICAic3VtbWFyeSI6ICIiLAogICAgImtleV9jb25jZXB0cyI6ICJEaXN0YW5jZSIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogUGF0dGVybiBSZWNvZ25pdGlvbiIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5OdW1iZXJzIHdpdGggc21hbGwgbXV0dWFsIGRpc3RhbmNlcyBvZnRlbiBzaGFyZSBjb21wdXRhdGlvbmFsIHByb3BlcnRpZXM6ICoqRGVtbyoqOiBDb25zaWRlciB0aGUgc2VxdWVuY2UgOCwgMTIsIDE4LCAyNDogLSA4ID0gMlx1MDBiMyBcdTIxOTIgKDMsMCkgLSAxMiA9IDJcdTAwYjIgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgyLDEpICAgLSAxOCA9IDJcdTAwYjkgXHUwMGQ3IDNcdTAwYjIgXHUyMTkyICgxLDIpIC0gMjQgPSAyXHUwMGIzIFx1MDBkNyAzXHUwMGI5IFx1MjE5MiAoMywxKSBUaGUgTWFuaGF0dGFuIGRpc3RhbmNlcyBmb3JtIGEgcGF0dGVybjogZF9NKDgsMTIpPTIsIGRfTSgxMiwxOCk9MiwgZF9NKDE4LDI0KT0zLiBUaGlzIHN1Z2dlc3RzIG9wdGltaXphdGlvbiBzdHJhdGVnaWVzIGZvciBiYXRjaCBmYWN0b3JpemF0aW9uLlxuXG4hISBLZXkgQ29uY2VwdHNcbmRfTSwgRGVtbywgZmFjdG9yaXphdGlvblxuXG4hISBDb250ZW50XG4jIyMgUGF0dGVybiBSZWNvZ25pdGlvblxuTnVtYmVycyB3aXRoIHNtYWxsIG11dHVhbCBkaXN0YW5jZXMgb2Z0ZW4gc2hhcmUgY29tcHV0YXRpb25hbCBwcm9wZXJ0aWVzOlxuXG4qKkRlbW8qKjogQ29uc2lkZXIgdGhlIHNlcXVlbmNlIDgsIDEyLCAxOCwgMjQ6XG4tIDggPSAyXHUwMGIzIFx1MjE5MiAoMywwKVxuLSAxMiA9IDJcdTAwYjIgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgyLDEpICBcbi0gMTggPSAyXHUwMGI5IFx1MDBkNyAzXHUwMGIyIFx1MjE5MiAoMSwyKVxuLSAyNCA9IDJcdTAwYjMgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgzLDEpXG5cblRoZSBNYW5oYXR0YW4gZGlzdGFuY2VzIGZvcm0gYSBwYXR0ZXJuOiBkX00oOCwxMik9MiwgZF9NKDEyLDE4KT0yLCBkX00oMTgsMjQpPTMuXG5cblRoaXMgc3VnZ2VzdHMgb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXMgZm9yIGJhdGNoIGZhY3Rvcml6YXRpb24uXG5cblxuISEgVGFnc1xuZGVtbyBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IiwKICAgICJ0YWdzIjogImRlbW8gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGVtbyBkaXN0YW5jZS1tZXRyaWMgbnVtYmVyLXRoZW9yeSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODI5MDg4MjciLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyOTA4ODI3IiwKICAgICJzdW1tYXJ5IjogIk51bWJlcnMgd2l0aCBzbWFsbCBtdXR1YWwgZGlzdGFuY2VzIG9mdGVuIHNoYXJlIGNvbXB1dGF0aW9uYWwgcHJvcGVydGllczogKipEZW1vKio6IENvbnNpZGVyIHRoZSBzZXF1ZW5jZSA4LCAxMiwgMTgsIDI0OiAtIDggPSAyXHUwMGIzIFx1MjE5MiAoMywwKSAtIDEyID0gMlx1MDBiMiBcdTAwZDcgM1x1MDBiOSBcdTIxOTIgKDIsMSkgICAtIDE4ID0gMlx1MDBiOSBcdTAwZDcgM1x1MDBiMiBcdTIxOTIgKDEsMikgLSAyNCA9IDJcdTAwYjMgXHUwMGQ3IDNcdTAwYjkgXHUyMTkyICgzLDEpIFRoZSBNYW5oYXR0YW4gZGlzdGFuY2VzIGZvcm0gYSBwYXR0ZXJuOiBkX00oOCwxMik9MiwgZF9NKDEyLDE4KT0yLCBkX00oMTgsMjQpPTMuIFRoaXMgc3VnZ2VzdHMgb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXMgZm9yIGJhdGNoIGZhY3Rvcml6YXRpb24uIiwKICAgICJrZXlfY29uY2VwdHMiOiAiZF9NLCBEZW1vLCBmYWN0b3JpemF0aW9uIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDAsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiB0cnVlLAogICAgImNvbXBsZXhpdHlfbGV2ZWwiOiAiYmFzaWMiCiAgfSwKICB7CiAgICAidGl0bGUiOiAiYmxvY2twcmltZXM6IENvbXByZXNzaW9uIFRocm91Z2ggRGlzdGFuY2UiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuSW5zdGVhZCBvZiBzdG9yaW5nIGZ1bGwgZmFjdG9yaXphdGlvbnMsIHdlIGNhbiBlbmNvZGU6IDEuIEEgcmVmZXJlbmNlIHBvaW50IChhbmNob3IgZmFjdG9yaXphdGlvbikgMi4gRGlzdGFuY2UgdmVjdG9ycyB0byBuZWFyYnkgbnVtYmVycyAqKkFsZ29yaXRobSoqOiAgYGBgIGZ1bmN0aW9uIGVuY29kZV9ibG9jayhudW1iZXJzKTogICAgIGFuY2hvciA9IGdlb21ldHJpY19tZWRpYW4obnVtYmVycykgICAgIHJldHVybiBbYW5jaG9yLCBbZGlzdGFuY2VfdmVjdG9yKG4sIGFuY2hvcikgZm9yIG4gaW4gbnVtYmVyc11dIGBgYCBXaGF0IGlzIHRoZSBjb21wcmVzc2lvbiByYXRpbyBjb21wYXJlZCB0byBuYWl2ZSBzdG9yYWdlP1xuXG4hISBLZXkgQ29uY2VwdHNcbkFsZ29yaXRobSwgRGlzdGFuY2UsIGZhY3Rvcml6YXRpb25cblxuISEgQ29udGVudFxuIyMjIENvbXByZXNzaW9uIFRocm91Z2ggRGlzdGFuY2Vcbkluc3RlYWQgb2Ygc3RvcmluZyBmdWxsIGZhY3Rvcml6YXRpb25zLCB3ZSBjYW4gZW5jb2RlOlxuMS4gQSByZWZlcmVuY2UgcG9pbnQgKGFuY2hvciBmYWN0b3JpemF0aW9uKVxuMi4gRGlzdGFuY2UgdmVjdG9ycyB0byBuZWFyYnkgbnVtYmVyc1xuXG4qKkFsZ29yaXRobSoqOiBcbmBgYFxuZnVuY3Rpb24gZW5jb2RlX2Jsb2NrKG51bWJlcnMpOlxuICAgIGFuY2hvciA9IGdlb21ldHJpY19tZWRpYW4obnVtYmVycylcbiAgICByZXR1cm4gW2FuY2hvciwgW2Rpc3RhbmNlX3ZlY3RvcihuLCBhbmNob3IpIGZvciBuIGluIG51bWJlcnNdXVxuYGBgXG5cbldoYXQgaXMgdGhlIGNvbXByZXNzaW9uIHJhdGlvIGNvbXBhcmVkIHRvIG5haXZlIHN0b3JhZ2U/XG5cblxuISEgVGFnc1xucXVlc3Rpb24gY29kZSBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBhbGdvcml0aG0gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInRhZ3MiOiAicXVlc3Rpb24gY29kZSBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBhbGdvcml0aG0gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyOTA4ODI3IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjkwODgyNyIsCiAgICAic3VtbWFyeSI6ICJJbnN0ZWFkIG9mIHN0b3JpbmcgZnVsbCBmYWN0b3JpemF0aW9ucywgd2UgY2FuIGVuY29kZTogMS4gQSByZWZlcmVuY2UgcG9pbnQgKGFuY2hvciBmYWN0b3JpemF0aW9uKSAyLiBEaXN0YW5jZSB2ZWN0b3JzIHRvIG5lYXJieSBudW1iZXJzICoqQWxnb3JpdGhtKio6ICBgYGAgZnVuY3Rpb24gZW5jb2RlX2Jsb2NrKG51bWJlcnMpOiAgICAgYW5jaG9yID0gZ2VvbWV0cmljX21lZGlhbihudW1iZXJzKSAgICAgcmV0dXJuIFthbmNob3IsIFtkaXN0YW5jZV92ZWN0b3IobiwgYW5jaG9yKSBmb3IgbiBpbiBudW1iZXJzXV0gYGBgIFdoYXQgaXMgdGhlIGNvbXByZXNzaW9uIHJhdGlvIGNvbXBhcmVkIHRvIG5haXZlIHN0b3JhZ2U/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiQWxnb3JpdGhtLCBEaXN0YW5jZSwgZmFjdG9yaXphdGlvbiIsCiAgICAicXVlc3Rpb25fY291bnQiOiAxLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJpbnRlcm1lZGlhdGUiCiAgfSwKICB7CiAgICAidGl0bGUiOiAiYmxvY2twcmltZXM6IEFwcGxpY2F0aW9ucyB0byBDcnlwdG9ncmFwaHkiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuXG5cbiEhIEtleSBDb25jZXB0c1xuXG5cbiEhIENvbnRlbnRcbiMjIEFwcGxpY2F0aW9ucyB0byBDcnlwdG9ncmFwaHlcblxuXG4hISBUYWdzXG5ibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBzZWN1cml0eSIsCiAgICAidGFncyI6ICJibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBzZWN1cml0eSIsCiAgICAidHlwZSI6ICJ0ZXh0L3gtbWFya2Rvd24iLAogICAgImNyZWF0ZWQiOiAiMjAyNTA4MDIwODI5MDg4MjciLAogICAgIm1vZGlmaWVkIjogIjIwMjUwODAyMDgyOTA4ODI3IiwKICAgICJzdW1tYXJ5IjogIiIsCiAgICAia2V5X2NvbmNlcHRzIjogIiIsCiAgICAicXVlc3Rpb25fY291bnQiOiAwLAogICAgImhhc19wcm9vZiI6IGZhbHNlLAogICAgImhhc19kZW1vIjogZmFsc2UsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJhZHZhbmNlZCIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogUlNBIEtleSBEaXN0YW5jZSBBbmFseXNpcyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5Gb3IgUlNBIG1vZHVsaSBOXHUyMDgxID0gcFx1MjA4MXFcdTIwODEgYW5kIE5cdTIwODIgPSBwXHUyMDgycVx1MjA4MiwgdGhlIGRpc3RhbmNlIGQoTlx1MjA4MSxOXHUyMDgyKSByZXZlYWxzIHN0cnVjdHVyYWwgc2ltaWxhcml0eS4gKipTZWN1cml0eSBJbXBsaWNhdGlvbioqOiBJZiBkKE5cdTIwODEsTlx1MjA4MikgPCB0aHJlc2hvbGQsIHRoZSBrZXlzIG1heSBzaGFyZSB2dWxuZXJhYmlsaXRpZXMuICoqUHJvb2YgU2tldGNoKio6IENsb3NlIGRpc3RhbmNlcyBpbXBseSBzaW1pbGFyIHByaW1lIHN0cnVjdHVyZXMsIHBvdGVudGlhbGx5IGVuYWJsaW5nIGNyb3NzLWtleSBhdHRhY2tzIHRocm91Z2ggc2hhcmVkIGZhY3Rvcml6YXRpb24gc2hvcnRjdXRzLiAqKkV4YW1wbGUqKjogSWYgTlx1MjA4MSA9IDc3ID0gN1x1MDBkNzExIGFuZCBOXHUyMDgyID0gOTEgPSA3XHUwMGQ3MTMsIHRoZXkgc2hhcmUgdGhlIHByaW1lIDcsIGxlYWRpbmcgdG8gZ2NkKE5cdTIwODEsTlx1MjA4MikgPSA3LiBDb3VsZCB3ZSBkZXZlbG9wIGRpc3RhbmNlLWJhc2VkIFJTQSBrZXkgdmFsaWRhdGlvbj9cblxuISEgS2V5IENvbmNlcHRzXG5Qcm9vZiwgcHJpbWUsIEV4YW1wbGUsIERpc3RhbmNlLCBQcm9vZiBTa2V0Y2gsIFNlY3VyaXR5IEltcGxpY2F0aW9uLCBmYWN0b3JpemF0aW9uLCBkaXN0YW5jZVxuXG4hISBDb250ZW50XG4jIyMgUlNBIEtleSBEaXN0YW5jZSBBbmFseXNpc1xuRm9yIFJTQSBtb2R1bGkgTlx1MjA4MSA9IHBcdTIwODFxXHUyMDgxIGFuZCBOXHUyMDgyID0gcFx1MjA4MnFcdTIwODIsIHRoZSBkaXN0YW5jZSBkKE5cdTIwODEsTlx1MjA4MikgcmV2ZWFscyBzdHJ1Y3R1cmFsIHNpbWlsYXJpdHkuXG5cbioqU2VjdXJpdHkgSW1wbGljYXRpb24qKjogSWYgZChOXHUyMDgxLE5cdTIwODIpIDwgdGhyZXNob2xkLCB0aGUga2V5cyBtYXkgc2hhcmUgdnVsbmVyYWJpbGl0aWVzLlxuXG4qKlByb29mIFNrZXRjaCoqOiBDbG9zZSBkaXN0YW5jZXMgaW1wbHkgc2ltaWxhciBwcmltZSBzdHJ1Y3R1cmVzLCBwb3RlbnRpYWxseSBlbmFibGluZyBjcm9zcy1rZXkgYXR0YWNrcyB0aHJvdWdoIHNoYXJlZCBmYWN0b3JpemF0aW9uIHNob3J0Y3V0cy5cblxuKipFeGFtcGxlKio6IElmIE5cdTIwODEgPSA3NyA9IDdcdTAwZDcxMSBhbmQgTlx1MjA4MiA9IDkxID0gN1x1MDBkNzEzLCB0aGV5IHNoYXJlIHRoZSBwcmltZSA3LCBsZWFkaW5nIHRvIGdjZChOXHUyMDgxLE5cdTIwODIpID0gNy5cblxuQ291bGQgd2UgZGV2ZWxvcCBkaXN0YW5jZS1iYXNlZCBSU0Ega2V5IHZhbGlkYXRpb24/XG5cblxuISEgVGFnc1xucHJvb2YgZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIHNlY3VyaXR5IGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidGFncyI6ICJwcm9vZiBkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRlbW8gc2VjdXJpdHkgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MjkwODgyNyIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODI5MDg4MjciLAogICAgInN1bW1hcnkiOiAiRm9yIFJTQSBtb2R1bGkgTlx1MjA4MSA9IHBcdTIwODFxXHUyMDgxIGFuZCBOXHUyMDgyID0gcFx1MjA4MnFcdTIwODIsIHRoZSBkaXN0YW5jZSBkKE5cdTIwODEsTlx1MjA4MikgcmV2ZWFscyBzdHJ1Y3R1cmFsIHNpbWlsYXJpdHkuICoqU2VjdXJpdHkgSW1wbGljYXRpb24qKjogSWYgZChOXHUyMDgxLE5cdTIwODIpIDwgdGhyZXNob2xkLCB0aGUga2V5cyBtYXkgc2hhcmUgdnVsbmVyYWJpbGl0aWVzLiAqKlByb29mIFNrZXRjaCoqOiBDbG9zZSBkaXN0YW5jZXMgaW1wbHkgc2ltaWxhciBwcmltZSBzdHJ1Y3R1cmVzLCBwb3RlbnRpYWxseSBlbmFibGluZyBjcm9zcy1rZXkgYXR0YWNrcyB0aHJvdWdoIHNoYXJlZCBmYWN0b3JpemF0aW9uIHNob3J0Y3V0cy4gKipFeGFtcGxlKio6IElmIE5cdTIwODEgPSA3NyA9IDdcdTAwZDcxMSBhbmQgTlx1MjA4MiA9IDkxID0gN1x1MDBkNzEzLCB0aGV5IHNoYXJlIHRoZSBwcmltZSA3LCBsZWFkaW5nIHRvIGdjZChOXHUyMDgxLE5cdTIwODIpID0gNy4gQ291bGQgd2UgZGV2ZWxvcCBkaXN0YW5jZS1iYXNlZCBSU0Ega2V5IHZhbGlkYXRpb24/IiwKICAgICJrZXlfY29uY2VwdHMiOiAiUHJvb2YsIHByaW1lLCBFeGFtcGxlLCBEaXN0YW5jZSwgUHJvb2YgU2tldGNoLCBTZWN1cml0eSBJbXBsaWNhdGlvbiwgZmFjdG9yaXphdGlvbiwgZGlzdGFuY2UiLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiB0cnVlLAogICAgImhhc19kZW1vIjogdHJ1ZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImJhc2ljIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBGZXJtYXQgTnVtYmVyIENvbm5lY3Rpb25zIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcblxuXG4hISBLZXkgQ29uY2VwdHNcblxuXG4hISBDb250ZW50XG4jIyBGZXJtYXQgTnVtYmVyIENvbm5lY3Rpb25zXG5cblxuISEgVGFnc1xuYmxvY2twcmltZXMgYmxvY2twcmltZXMgbnVtYmVyLXRoZW9yeSIsCiAgICAidGFncyI6ICJibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBudW1iZXItdGhlb3J5IiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MjkwODgyNyIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODI5MDg4MjciLAogICAgInN1bW1hcnkiOiAiIiwKICAgICJrZXlfY29uY2VwdHMiOiAiIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDAsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImJhc2ljIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBEaXN0YW5jZSB0byBGZXJtYXQgTnVtYmVycyIsCiAgICAidGV4dCI6ICIhISBTdW1tYXJ5XG5GZXJtYXQgbnVtYmVycyBGXHUyMDk5ID0gMl4oMlx1MjA3ZikgKyAxIHNlcnZlIGFzIHJlZmVyZW5jZSBwb2ludHMgaW4gcHJpbWUgc3BhY2UuICoqT2JzZXJ2YXRpb24qKjogTnVtYmVycyBuZWFyIEZlcm1hdCBudW1iZXJzIGluIGRpc3RhbmNlIG1ldHJpYyBvZnRlbiBleGhpYml0IHNwZWNpYWwgcHJvcGVydGllcy4gKipEZW1vKio6IEZcdTIwODAgPSAzLCBGXHUyMDgxID0gNSwgRlx1MjA4MiA9IDE3LCBGXHUyMDgzID0gMjU3IERpc3RhbmNlIGFuYWx5c2lzIHJldmVhbHMgY2x1c3RlcmluZyBhcm91bmQgcG93ZXJzIG9mIDIuICoqT3BlbiBRdWVzdGlvbioqOiBEb2VzIHByb3hpbWl0eSB0byBGZXJtYXQgbnVtYmVycyBwcmVkaWN0IHByaW1hbGl0eSB0ZXN0aW5nIGVmZmljaWVuY3k/XG5cbiEhIEtleSBDb25jZXB0c1xucHJpbWUsIG1ldHJpYywgRGVtbywgT2JzZXJ2YXRpb24sIERpc3RhbmNlLCBPcGVuIFF1ZXN0aW9uLCBkaXN0YW5jZVxuXG4hISBDb250ZW50XG4jIyMgRGlzdGFuY2UgdG8gRmVybWF0IE51bWJlcnNcbkZlcm1hdCBudW1iZXJzIEZcdTIwOTkgPSAyXigyXHUyMDdmKSArIDEgc2VydmUgYXMgcmVmZXJlbmNlIHBvaW50cyBpbiBwcmltZSBzcGFjZS5cblxuKipPYnNlcnZhdGlvbioqOiBOdW1iZXJzIG5lYXIgRmVybWF0IG51bWJlcnMgaW4gZGlzdGFuY2UgbWV0cmljIG9mdGVuIGV4aGliaXQgc3BlY2lhbCBwcm9wZXJ0aWVzLlxuXG4qKkRlbW8qKjogRlx1MjA4MCA9IDMsIEZcdTIwODEgPSA1LCBGXHUyMDgyID0gMTcsIEZcdTIwODMgPSAyNTdcbkRpc3RhbmNlIGFuYWx5c2lzIHJldmVhbHMgY2x1c3RlcmluZyBhcm91bmQgcG93ZXJzIG9mIDIuXG5cbioqT3BlbiBRdWVzdGlvbioqOiBEb2VzIHByb3hpbWl0eSB0byBGZXJtYXQgbnVtYmVycyBwcmVkaWN0IHByaW1hbGl0eSB0ZXN0aW5nIGVmZmljaWVuY3k/XG5cblxuISEgVGFnc1xuZGVtbyBxdWVzdGlvbiBibG9ja3ByaW1lcyBibG9ja3ByaW1lcyBkZW1vIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCIsCiAgICAidGFncyI6ICJkZW1vIHF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRlbW8gZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MjkwODgyOCIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODI5MDg4MjgiLAogICAgInN1bW1hcnkiOiAiRmVybWF0IG51bWJlcnMgRlx1MjA5OSA9IDJeKDJcdTIwN2YpICsgMSBzZXJ2ZSBhcyByZWZlcmVuY2UgcG9pbnRzIGluIHByaW1lIHNwYWNlLiAqKk9ic2VydmF0aW9uKio6IE51bWJlcnMgbmVhciBGZXJtYXQgbnVtYmVycyBpbiBkaXN0YW5jZSBtZXRyaWMgb2Z0ZW4gZXhoaWJpdCBzcGVjaWFsIHByb3BlcnRpZXMuICoqRGVtbyoqOiBGXHUyMDgwID0gMywgRlx1MjA4MSA9IDUsIEZcdTIwODIgPSAxNywgRlx1MjA4MyA9IDI1NyBEaXN0YW5jZSBhbmFseXNpcyByZXZlYWxzIGNsdXN0ZXJpbmcgYXJvdW5kIHBvd2VycyBvZiAyLiAqKk9wZW4gUXVlc3Rpb24qKjogRG9lcyBwcm94aW1pdHkgdG8gRmVybWF0IG51bWJlcnMgcHJlZGljdCBwcmltYWxpdHkgdGVzdGluZyBlZmZpY2llbmN5PyIsCiAgICAia2V5X2NvbmNlcHRzIjogInByaW1lLCBtZXRyaWMsIERlbW8sIE9ic2VydmF0aW9uLCBEaXN0YW5jZSwgT3BlbiBRdWVzdGlvbiwgZGlzdGFuY2UiLAogICAgInF1ZXN0aW9uX2NvdW50IjogMSwKICAgICJoYXNfcHJvb2YiOiBmYWxzZSwKICAgICJoYXNfZGVtbyI6IHRydWUsCiAgICAiY29tcGxleGl0eV9sZXZlbCI6ICJiYXNpYyIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJibG9ja3ByaW1lczogQ29tcHV0YXRpb25hbCBJbXBsaWNhdGlvbnMiLAogICAgInRleHQiOiAiISEgU3VtbWFyeVxuVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOiAxLiBQcmVkaWN0aXZlIGNvbXBsZXhpdHkgYW5hbHlzaXMgMi4gT3B0aW1pemVkIGZhY3Rvcml6YXRpb24gcm91dGVzICAgMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHMgNC4gUGF0dGVybiBkaXNjb3ZlcnkgaW4gbnVtYmVyIHNlcXVlbmNlcyAqKlJlc2VhcmNoIERpcmVjdGlvbioqOiBDYW4gd2UgZXh0ZW5kIHRoaXMgZnJhbWV3b3JrIHRvIGFsZ2VicmFpYyBpbnRlZ2VycyBhbmQgb3RoZXIgbWF0aGVtYXRpY2FsIHN0cnVjdHVyZXM/XG5cbiEhIEtleSBDb25jZXB0c1xubWV0cmljLCBjb21wbGV4aXR5LCBSZXNlYXJjaCBEaXJlY3Rpb24sIGZhY3Rvcml6YXRpb24sIGRpc3RhbmNlXG5cbiEhIENvbnRlbnRcbiMjIyBDb21wdXRhdGlvbmFsIEltcGxpY2F0aW9uc1xuVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOlxuMS4gUHJlZGljdGl2ZSBjb21wbGV4aXR5IGFuYWx5c2lzXG4yLiBPcHRpbWl6ZWQgZmFjdG9yaXphdGlvbiByb3V0ZXMgIFxuMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHNcbjQuIFBhdHRlcm4gZGlzY292ZXJ5IGluIG51bWJlciBzZXF1ZW5jZXNcblxuKipSZXNlYXJjaCBEaXJlY3Rpb24qKjogQ2FuIHdlIGV4dGVuZCB0aGlzIGZyYW1ld29yayB0byBhbGdlYnJhaWMgaW50ZWdlcnMgYW5kIG90aGVyIG1hdGhlbWF0aWNhbCBzdHJ1Y3R1cmVzP1xuXG5cbiEhIFRhZ3NcbnF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0YWdzIjogInF1ZXN0aW9uIGJsb2NrcHJpbWVzIGJsb2NrcHJpbWVzIGRpc3RhbmNlLW1ldHJpYyBudW1iZXItdGhlb3J5IGZvbGxvdy11cCBjb21wbGV4aXR5IiwKICAgICJ0eXBlIjogInRleHQveC1tYXJrZG93biIsCiAgICAiY3JlYXRlZCI6ICIyMDI1MDgwMjA4MjkwODgyOCIsCiAgICAibW9kaWZpZWQiOiAiMjAyNTA4MDIwODI5MDg4MjgiLAogICAgInN1bW1hcnkiOiAiVGhlIGRpc3RhbmNlIG1ldHJpYyBlbmFibGVzOiAxLiBQcmVkaWN0aXZlIGNvbXBsZXhpdHkgYW5hbHlzaXMgMi4gT3B0aW1pemVkIGZhY3Rvcml6YXRpb24gcm91dGVzICAgMy4gQ29tcHJlc3Npb24gb2YgbWF0aGVtYXRpY2FsIG9iamVjdHMgNC4gUGF0dGVybiBkaXNjb3ZlcnkgaW4gbnVtYmVyIHNlcXVlbmNlcyAqKlJlc2VhcmNoIERpcmVjdGlvbioqOiBDYW4gd2UgZXh0ZW5kIHRoaXMgZnJhbWV3b3JrIHRvIGFsZ2VicmFpYyBpbnRlZ2VycyBhbmQgb3RoZXIgbWF0aGVtYXRpY2FsIHN0cnVjdHVyZXM/IiwKICAgICJrZXlfY29uY2VwdHMiOiAibWV0cmljLCBjb21wbGV4aXR5LCBSZXNlYXJjaCBEaXJlY3Rpb24sIGZhY3Rvcml6YXRpb24sIGRpc3RhbmNlIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDEsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImFkdmFuY2VkIgogIH0sCiAgewogICAgInRpdGxlIjogImJsb2NrcHJpbWVzOiBDb25jbHVzaW9uIiwKICAgICJ0ZXh0IjogIiEhIFN1bW1hcnlcbkJsb2NrIHByaW1lIGRpc3RhbmNlIG1ldHJpY3MgdHJhbnNmb3JtIGRpc2NyZXRlIG51bWJlciB0aGVvcnkgaW50byBjb250aW51b3VzIGdlb21ldHJpYyBvcHRpbWl6YXRpb24uIFRoaXMgZW5hYmxlcyBuZXcgY29tcHV0YXRpb25hbCBzaG9ydGN1dHMgYW5kIHJldmVhbHMgaGlkZGVuIHBhdHRlcm5zIGluIG1hdGhlbWF0aWNhbCBzdHJ1Y3R1cmVzLiAqKkZ1dHVyZSBXb3JrKio6IEludmVzdGlnYXRlIGRpc3RhbmNlLXByZXNlcnZpbmcgdHJhbnNmb3JtYXRpb25zIGFuZCB0aGVpciBpbXBhY3Qgb24gYWxnb3JpdGhtaWMgY29tcGxleGl0eS4gSG93IG1pZ2h0IHF1YW50dW0gY29tcHV0aW5nIGNoYW5nZSB0aGVzZSBkaXN0YW5jZSByZWxhdGlvbnNoaXBzP1xuXG4hISBLZXkgQ29uY2VwdHNcbnByaW1lLCBGdXR1cmUgV29yaywgY29tcGxleGl0eSwgZGlzdGFuY2VcblxuISEgQ29udGVudFxuIyMgQ29uY2x1c2lvblxuXG5CbG9jayBwcmltZSBkaXN0YW5jZSBtZXRyaWNzIHRyYW5zZm9ybSBkaXNjcmV0ZSBudW1iZXIgdGhlb3J5IGludG8gY29udGludW91cyBnZW9tZXRyaWMgb3B0aW1pemF0aW9uLiBUaGlzIGVuYWJsZXMgbmV3IGNvbXB1dGF0aW9uYWwgc2hvcnRjdXRzIGFuZCByZXZlYWxzIGhpZGRlbiBwYXR0ZXJucyBpbiBtYXRoZW1hdGljYWwgc3RydWN0dXJlcy5cblxuKipGdXR1cmUgV29yayoqOiBJbnZlc3RpZ2F0ZSBkaXN0YW5jZS1wcmVzZXJ2aW5nIHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlaXIgaW1wYWN0IG9uIGFsZ29yaXRobWljIGNvbXBsZXhpdHkuXG5cbkhvdyBtaWdodCBxdWFudHVtIGNvbXB1dGluZyBjaGFuZ2UgdGhlc2UgZGlzdGFuY2UgcmVsYXRpb25zaGlwcz9cblxuISEgVGFnc1xucXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInRhZ3MiOiAicXVlc3Rpb24gYmxvY2twcmltZXMgYmxvY2twcmltZXMgZGlzdGFuY2UtbWV0cmljIG51bWJlci10aGVvcnkgZm9sbG93LXVwIGNvbXBsZXhpdHkiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyOTA4ODI4IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjkwODgyOCIsCiAgICAic3VtbWFyeSI6ICJCbG9jayBwcmltZSBkaXN0YW5jZSBtZXRyaWNzIHRyYW5zZm9ybSBkaXNjcmV0ZSBudW1iZXIgdGhlb3J5IGludG8gY29udGludW91cyBnZW9tZXRyaWMgb3B0aW1pemF0aW9uLiBUaGlzIGVuYWJsZXMgbmV3IGNvbXB1dGF0aW9uYWwgc2hvcnRjdXRzIGFuZCByZXZlYWxzIGhpZGRlbiBwYXR0ZXJucyBpbiBtYXRoZW1hdGljYWwgc3RydWN0dXJlcy4gKipGdXR1cmUgV29yayoqOiBJbnZlc3RpZ2F0ZSBkaXN0YW5jZS1wcmVzZXJ2aW5nIHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlaXIgaW1wYWN0IG9uIGFsZ29yaXRobWljIGNvbXBsZXhpdHkuIEhvdyBtaWdodCBxdWFudHVtIGNvbXB1dGluZyBjaGFuZ2UgdGhlc2UgZGlzdGFuY2UgcmVsYXRpb25zaGlwcz8iLAogICAgImtleV9jb25jZXB0cyI6ICJwcmltZSwgRnV0dXJlIFdvcmssIGNvbXBsZXhpdHksIGRpc3RhbmNlIiwKICAgICJxdWVzdGlvbl9jb3VudCI6IDEsCiAgICAiaGFzX3Byb29mIjogZmFsc2UsCiAgICAiaGFzX2RlbW8iOiBmYWxzZSwKICAgICJjb21wbGV4aXR5X2xldmVsIjogImludGVybWVkaWF0ZSIKICB9LAogIHsKICAgICJ0aXRsZSI6ICJ0aGVvcmVtMSIsCiAgICAidGV4dCI6ICIjIEZ1bmRhbWVudGFsIFRoZW9yZW0gb2YgQXJpdGhtZXRpY1xuXG4qKlRoZW9yZW0qKjogRXZlcnkgaW50ZWdlciBncmVhdGVyIHRoYW4gMSBpcyBlaXRoZXIgcHJpbWUgb3IgY2FuIGJlIHVuaXF1ZWx5IGZhY3RvcmVkIGludG8gcHJpbWUgbnVtYmVycy5cblxuKipQcm9vZioqOiBcbjEuIEV4aXN0ZW5jZTogQXNzdW1lIHNvbWUgaW50ZWdlciBuID4gMSBjYW5ub3QgYmUgZmFjdG9yZWQuIFxuMi4gTGV0IFMgYmUgdGhlIHNldCBvZiBhbGwgc3VjaCBpbnRlZ2Vycy5cbjMuIEJ5IHdlbGwtb3JkZXJpbmcsIFMgaGFzIGEgbWluaW11bSBlbGVtZW50IG0uXG40LiBTaW5jZSBtIGNhbm5vdCBiZSBmYWN0b3JlZCwgbSBtdXN0IGJlIHByaW1lLlxuNS4gVGhpcyBjb250cmFkaWN0cyBvdXIgYXNzdW1wdGlvbi5cblxuVGhlcmVmb3JlLCBldmVyeSBpbnRlZ2VyIGNhbiBiZSBmYWN0b3JlZCBpbnRvIHByaW1lcy5cblxuKipEZW1vKio6IDEyID0gMlx1MDBiMiBcdTAwZDcgMywgMTUgPSAzIFx1MDBkNyA1LCAzMCA9IDIgXHUwMGQ3IDMgXHUwMGQ3IDVcblxuVGhpcyB0aGVvcmVtIGlzIGZ1bmRhbWVudGFsIHRvIG51bWJlciB0aGVvcnkgYW5kIGNyeXB0b2dyYXBoeS5cblxuSG93IGRvZXMgdGhpcyByZWxhdGUgdG8gdGhlIGRpc3RhbmNlIG1ldHJpY3MgaW4gcHJpbWUgc3BhY2U/XG4iLAogICAgInRhZ3MiOiAicHJvb2YgZGVtbyBxdWVzdGlvbiB0ZXh0IG1kIGNvbXByZXNzZWQiLAogICAgInR5cGUiOiAidGV4dC94LW1hcmtkb3duIiwKICAgICJjcmVhdGVkIjogIjIwMjUwODAyMDgyOTA4ODI4IiwKICAgICJtb2RpZmllZCI6ICIyMDI1MDgwMjA4MjkwODgyOCIKICB9Cl0KfTsKPC9zY3JpcHQ+CjwvaGVhZD4KPGJvZHk+CjxkaXYgaWQ9InRpZGRseXdpa2kiPgo8aDE+Q29tcGlsZWQgV2lraTwvaDE+CjxwPlRoaXMgd2lraSBjb250YWlucyAxOCB0aWRkbGVycyBjb21waWxlZCBmcm9tIHNhbXBsZV9jb250ZW50PC9wPgo8L2Rpdj4KPC9ib2R5Pgo8L2h0bWw+",
    "tags": "binary attachment",
    "type": "text/html",
    "created": "20250802082912822",
    "modified": "20250802082912822",
    "_canonical_uri": "data:text/html;base64,"
  },
  {
    "title": "wiki_template",
    "text": "\"\"\"\nTiddlyWiki HTML Template Generator\nCreates a complete TiddlyWiki HTML file with all necessary components\n\"\"\"\n\nimport json\nfrom typing import List, Dict, Any\n\n\ndef generate_tiddlywiki_html(tiddlers_data: List[Dict[str, Any]], title: str = \"Compiled Wiki\") -> str:\n    \"\"\"Generate a complete TiddlyWiki HTML file\"\"\"\n    \n    # Convert tiddlers to proper TiddlyWiki format\n    formatted_tiddlers = []\n    for tiddler in tiddlers_data:\n        formatted_tiddler = {\n            \"title\": tiddler[\"title\"],\n            \"text\": tiddler[\"text\"],\n            \"tags\": tiddler[\"tags\"],\n            \"type\": tiddler.get(\"type\", \"text/vnd.tiddlywiki\"),\n            \"created\": tiddler.get(\"created\", \"\"),\n            \"modified\": tiddler.get(\"modified\", \"\"),\n        }\n        \n        # Add custom fields\n        for key, value in tiddler.items():\n            if key not in [\"title\", \"text\", \"tags\", \"type\", \"created\", \"modified\"]:\n                formatted_tiddler[key] = value\n                \n        formatted_tiddlers.append(formatted_tiddler)\n    \n    # Create tiddlers JSON string\n    tiddlers_json = json.dumps(formatted_tiddlers, indent=2, ensure_ascii=False)\n    \n    html_template = f\"\"\"<!doctype html>\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />\n<meta name=\"generator\" content=\"TiddlyWiki Compiler\" />\n<meta name=\"tiddlywiki-version\" content=\"5.3.0\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" />\n<meta name=\"mobile-web-app-capable\" content=\"yes\"/>\n<meta name=\"format-detection\" content=\"telephone=no\">\n<link id=\"faviconLink\" rel=\"shortcut icon\" href=\"favicon.ico\">\n<title>{title}</title>\n\n<style>\n/* Basic TiddlyWiki CSS */\n* {{\n    box-sizing: border-box;\n}}\n\nbody {{\n    font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    font-size: 14px;\n    line-height: 1.5;\n    color: #333;\n    background: #fff;\n    margin: 0;\n    padding: 0;\n}}\n\n.tc-page-container {{\n    position: relative;\n    min-height: 100vh;\n    background: #f4f4f4;\n}}\n\n.tc-sidebar-scrollable {{\n    position: fixed;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    width: 300px;\n    background: #f4f4f4;\n    border-right: 1px solid #ccc;\n    overflow-y: auto;\n    padding: 10px;\n}}\n\n.tc-story-river {{\n    margin-left: 320px;\n    padding: 20px;\n    background: #fff;\n    min-height: 100vh;\n}}\n\n.tc-tiddler-frame {{\n    margin-bottom: 20px;\n    background: #fff;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n}}\n\n.tc-tiddler-title {{\n    background: #5778d8;\n    color: #fff;\n    padding: 10px 15px;\n    border-radius: 5px 5px 0 0;\n    font-size: 18px;\n    font-weight: bold;\n}}\n\n.tc-tiddler-body {{\n    padding: 15px;\n}}\n\n.tc-tiddler-controls {{\n    background: #f8f9fa;\n    padding: 8px 15px;\n    border-top: 1px solid #ddd;\n    font-size: 12px;\n    color: #666;\n}}\n\n.tc-tag {{\n    display: inline-block;\n    background: #e7f3ff;\n    color: #0366d6;\n    padding: 2px 8px;\n    margin: 2px;\n    border-radius: 12px;\n    font-size: 11px;\n    text-decoration: none;\n}}\n\n.tc-tag:hover {{\n    background: #cce7ff;\n}}\n\n.tc-tag.tag-proof {{\n    background: #fff3cd;\n    color: #856404;\n}}\n\n.tc-tag.tag-demo {{\n    background: #d4edda;\n    color: #155724;\n}}\n\n.tc-tag.tag-question {{\n    background: #f8d7da;\n    color: #721c24;\n}}\n\n.tc-tag.tag-follow-up {{\n    background: #e2e3e5;\n    color: #383d41;\n}}\n\n.tc-sidebar-tab {{\n    display: block;\n    padding: 8px 12px;\n    margin: 2px 0;\n    background: #fff;\n    border: 1px solid #ddd;\n    border-radius: 3px;\n    text-decoration: none;\n    color: #333;\n    transition: background 0.2s;\n}}\n\n.tc-sidebar-tab:hover {{\n    background: #e9ecef;\n}}\n\n.tc-sidebar-tab.tc-tab-selected {{\n    background: #5778d8;\n    color: #fff;\n}}\n\nh1, h2, h3, h4, h5, h6 {{\n    color: #333;\n    margin-top: 20px;\n    margin-bottom: 10px;\n}}\n\nh1 {{ font-size: 24px; }}\nh2 {{ font-size: 20px; }}\nh3 {{ font-size: 16px; }}\n\npre {{\n    background: #f8f9fa;\n    border: 1px solid #e9ecef;\n    border-radius: 3px;\n    padding: 10px;\n    overflow-x: auto;\n}}\n\ncode {{\n    background: #f8f9fa;\n    padding: 2px 4px;\n    border-radius: 3px;\n    font-family: \"Monaco\", \"Menlo\", \"Ubuntu Mono\", monospace;\n}}\n\n.tc-search-box {{\n    width: 100%;\n    padding: 8px;\n    margin-bottom: 10px;\n    border: 1px solid #ddd;\n    border-radius: 3px;\n}}\n\n.math {{\n    font-style: italic;\n}}\n\n.tc-summary {{\n    background: #e7f3ff;\n    padding: 10px;\n    border-left: 4px solid #0366d6;\n    margin-bottom: 15px;\n}}\n\n.tc-key-concepts {{\n    background: #f8f9fa;\n    padding: 8px;\n    border-radius: 3px;\n    margin-bottom: 10px;\n    font-size: 12px;\n    color: #666;\n}}\n</style>\n\n<script>\nwindow.$tw = window.$tw || {{}};\n$tw.boot = $tw.boot || {{}};\n$tw.utils = $tw.utils || {{}};\n\n// Preload tiddlers\n$tw.preloadTiddlers = {tiddlers_json};\n\n// Basic TiddlyWiki functionality\n$tw.utils.parseStringArray = func(value) {{\n    if(typeof value === \"string\") {{\n        return value.split(\" \").filter(func(item) {{ return item.length > 0; }});\n    }}\n    return [];\n}};\n\n$tw.utils.stringifyList = func(value) {{\n    return value.join(\" \");\n}};\n\n// Simple wiki rendering\n$tw.wiki = {{\n    getTiddler: func(title) {{\n        return $tw.preloadTiddlers.find(func(tiddler) {{\n            return tiddler.title === title;\n        }});\n    }},\n    \n    getTiddlers: func() {{\n        return $tw.preloadTiddlers.map(func(tiddler) {{\n            return tiddler.title;\n        }});\n    }},\n    \n    filterTiddlers: func(filter) {{\n        // Simple tag-based filtering\n        if(filter.startsWith(\"[tag[\") && filter.endsWith(\"]]\")) {{\n            var tag = filter.slice(5, -2);\n            return $tw.preloadTiddlers.filter(func(tiddler) {{\n                var tags = $tw.utils.parseStringArray(tiddler.tags);\n                return tags.indexOf(tag) !== -1;\n            }}).map(func(tiddler) {{\n                return tiddler.title;\n            }});\n        }}\n        return $tw.preloadTiddlers.map(func(tiddler) {{\n            return tiddler.title;\n        }});\n    }}\n}};\n\n// Render tiddler content\nfunc renderTiddler(title) {{\n    var tiddler = $tw.wiki.getTiddler(title);\n    if(!tiddler) return \"\";\n    \n    var text = tiddler.text || \"\";\n    var tags = $tw.utils.parseStringArray(tiddler.tags);\n    \n    // Simple markdown-like rendering\n    text = text.replace(/^!! (.+)$/gm, '<h2>$1</h2>');\n    text = text.replace(/^! (.+)$/gm, '<h1>$1</h1>');\n    text = text.replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>');\n    text = text.replace(/\\*([^*]+)\\*/g, '<em>$1</em>');\n    text = text.replace(/`([^`]+)`/g, '<code>$1</code>');\n    text = text.replace(/\\\\n/g, '<br>');\n    \n    // Render special sections\n    if(text.includes('!! Summary')) {{\n        text = text.replace(/!! Summary\\\\s*([^!]+)/g, '<div class=\"tc-summary\">$1</div>');\n    }}\n    \n    if(text.includes('!! Key Concepts')) {{\n        text = text.replace(/!! Key Concepts\\\\s*([^!]+)/g, '<div class=\"tc-key-concepts\"><strong>Key Concepts:</strong> $1</div>');\n    }}\n    \n    var tagHtml = tags.map(func(tag) {{\n        return '<a href=\"#\" class=\"tc-tag tag-' + tag.replace(/[^a-zA-Z0-9]/g, '-') + '\" onclick=\"filterByTag(\\\\''+tag+'\\\\'); return false;\">' + tag + '</a>';\n    }}).join(' ');\n    \n    return '<div class=\"tc-tiddler-frame\">' +\n           '<div class=\"tc-tiddler-title\">' + title + '</div>' +\n           '<div class=\"tc-tiddler-body\">' + text + '</div>' +\n           '<div class=\"tc-tiddler-controls\">Tags: ' + tagHtml + '</div>' +\n           '</div>';\n}}\n\n// Render all tiddlers\nfunc renderStory() {{\n    var storyElement = document.getElementById('tc-story-river');\n    var html = '';\n    \n    $tw.wiki.getTiddlers().forEach(func(title) {{\n        html += renderTiddler(title);\n    }});\n    \n    storyElement.innerHTML = html;\n}}\n\n// Filter by tag\nfunc filterByTag(tag) {{\n    var storyElement = document.getElementById('tc-story-river');\n    var html = '';\n    \n    var filteredTiddlers = $tw.wiki.filterTiddlers('[tag[' + tag + ']]');\n    filteredTiddlers.forEach(func(title) {{\n        html += renderTiddler(title);\n    }});\n    \n    storyElement.innerHTML = html;\n}}\n\n// Search functionality\nfunc searchTiddlers() {{\n    var query = document.getElementById('search-input').value.toLowerCase();\n    var storyElement = document.getElementById('tc-story-river');\n    var html = '';\n    \n    $tw.preloadTiddlers.forEach(func(tiddler) {{\n        if(tiddler.title.toLowerCase().includes(query) || \n           (tiddler.text && tiddler.text.toLowerCase().includes(query))) {{\n            html += renderTiddler(tiddler.title);\n        }}\n    }});\n    \n    storyElement.innerHTML = html;\n}}\n\n// Get unique tags\nfunc getUniqueTags() {{\n    var allTags = [];\n    $tw.preloadTiddlers.forEach(func(tiddler) {{\n        var tags = $tw.utils.parseStringArray(tiddler.tags);\n        allTags = allTags.concat(tags);\n    }});\n    \n    return [...new Set(allTags)].sort();\n}}\n\n// Initialize the wiki\nwindow.addEventListener('load', func() {{\n    renderStory();\n    \n    // Populate sidebar with tags\n    var tagsElement = document.getElementById('tags-list');\n    var tags = getUniqueTags();\n    \n    tags.forEach(func(tag) {{\n        var tagElement = document.createElement('a');\n        tagElement.href = '#';\n        tagElement.className = 'tc-sidebar-tab';\n        tagElement.textContent = tag;\n        tagElement.onclick = func() {{ filterByTag(tag); return false; }};\n        tagsElement.appendChild(tagElement);\n    }});\n}});\n</script>\n</head>\n\n<body class=\"tc-body\">\n<div class=\"tc-page-container\">\n    <div class=\"tc-sidebar-scrollable\">\n        <h3>Search</h3>\n        <input type=\"text\" id=\"search-input\" class=\"tc-search-box\" placeholder=\"Search tiddlers...\" onkeyup=\"searchTiddlers()\">\n        \n        <h3>Navigation</h3>\n        <a href=\"#\" class=\"tc-sidebar-tab\" onclick=\"renderStory(); return false;\">All Tiddlers</a>\n        \n        <h3>Tags</h3>\n        <div id=\"tags-list\"></div>\n        \n        <h3>Statistics</h3>\n        <div style=\"font-size: 12px; color: #666; padding: 8px;\">\n            <div>Total Tiddlers: <span id=\"tiddler-count\">{len(formatted_tiddlers)}</span></div>\n            <div>Total Tags: <span id=\"tag-count\"></span></div>\n        </div>\n    </div>\n    \n    <div class=\"tc-story-river\" id=\"tc-story-river\">\n        <!-- Tiddlers will be rendered here -->\n    </div>\n</div>\n\n<script>\n// Update tag count after initialization\nwindow.addEventListener('load', func() {{\n    document.getElementById('tag-count').textContent = getUniqueTags().length;\n}});\n</script>\n\n</body>\n</html>\"\"\"\n    \n    return html_template",
    "tags": "mathematics proof demo code text py compressed",
    "type": "text/plain",
    "created": "20250802082912823",
    "modified": "20250802082912823"
  },
  {
    "title": "algorithms",
    "text": "# Sample algo\ndef factorial(n):\n    \"\"\"\n    Compute factorial using recursive algo\n    Time complexity: O(n)\n    Space complexity: O(n) due to recursion\n    \"\"\"\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n\ndef fibonacci(n):\n    \"\"\"\n    Compute Fibonacci number\n    Demonstrates exponential growth pattern\n    \"\"\"\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Example usage\nprint(f\"5! = {factorial(5)}\")\nprint(f\"F(10) = {fibonacci(10)}\")\n",
    "tags": "demo code text py compressed",
    "type": "text/plain",
    "created": "20250802082912823",
    "modified": "20250802082912823"
  },
  {
    "title": "introduction",
    "text": "# Welcome to the math Wiki\n\nThis wiki demonstrates the TiddlyWiki compiler's ability to structure and organize math content.\n\n## Features\n\n- **Automatic tagging** based on content patterns\n- **Distance-metric compression** using blockprimes concepts  \n- **Structured tiddlers** with summaries and key concepts\n- **Interactive filtering** by tags and search\n\n## Sample Content\n\nThe blockprimes.md file has been automatically broken down into multiple tiddlers, each with:\n- Summary sections\n- Key concept extraction\n- Automatic tagging (proof, demo, question, etc.)\n- Follow-up question detection\n\n**Example**: math proofs are automatically tagged as \"proof\" and formatted with special styling.\n\nWhat patterns will you discover in your own content?\n",
    "tags": "proof demo question text md compressed",
    "type": "text/x-markdown",
    "created": "20250802082912823",
    "modified": "20250802082912823"
  },
  {
    "title": "concepts",
    "text": "Key math Concepts\n\nPrime Numbers: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29...\nFibonacci Sequence: 1, 1, 2, 3, 5, 8, 13, 21, 34...\nFactorials: 1, 2, 6, 24, 120, 720...\n\nDistance Metrics:\n- Euclidean: d(x,y) = \u221a(\u03a3(xi-yi)\u00b2)\n- Manhattan: d(x,y) = \u03a3|xi-yi|\n- Hamming: number of differing positions\n\nComputational Complexity:\n- O(1): constant time\n- O(log n): logarithmic \n- O(n): linear time\n- O(n log n): linearithmic\n- O(n\u00b2): quadratic time\n\nWhat relationships exist between these concepts?\n",
    "tags": "question text txt compressed",
    "type": "text/plain",
    "created": "20250802082912823",
    "modified": "20250802082912823"
  },
  {
    "title": "blockprimes: Blockprimes: Computational Distance Metrics",
    "text": "!! Summary\n\n\n!! Key Concepts\nDistance\n\n!! Content\n# Blockprimes: Computational Distance Metrics\n\n\n!! Tags\nblockprimes blockprimes number-theory",
    "tags": "blockprimes blockprimes number-theory",
    "type": "text/x-markdown",
    "created": "20250802082912823",
    "modified": "20250802082912823",
    "summary": "",
    "key_concepts": "Distance",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "basic"
  },
  {
    "title": "blockprimes: Introduction",
    "text": "!! Summary\nBlock primes represent a novel approach to computational distance measurement in mathematical spaces. By encoding prime factorizations as spatial coordinates, we can transform number theory problems into geometric optimization challenges. The fundamental insight is that every composite number n can be represented as a point in prime-factorization space, where coordinates correspond to prime powers: n = p\u2081^a\u2081 \u00d7 p\u2082^a\u2082 \u00d7 ... \u00d7 p\u2096^a\u2096. **Proof Pattern**: Given any composite number n, its unique prime factorization provides coordinates (a\u2081, a\u2082, ..., a\u2096) in \u2124\u1d4f space. What computational patterns emerge when we measure distances between these points?\n\n!! Key Concepts\nfactorization, distance, prime, Proof Pattern, Proof\n\n!! Content\n## Introduction\nBlock primes represent a novel approach to computational distance measurement in mathematical spaces. By encoding prime factorizations as spatial coordinates, we can transform number theory problems into geometric optimization challenges.\n\nThe fundamental insight is that every composite number n can be represented as a point in prime-factorization space, where coordinates correspond to prime powers: n = p\u2081^a\u2081 \u00d7 p\u2082^a\u2082 \u00d7 ... \u00d7 p\u2096^a\u2096.\n\n**Proof Pattern**: Given any composite number n, its unique prime factorization provides coordinates (a\u2081, a\u2082, ..., a\u2096) in \u2124\u1d4f space.\n\nWhat computational patterns emerge when we measure distances between these points?\n\n\n!! Tags\nproof question blockprimes blockprimes distance-metric number-theory follow-up",
    "tags": "proof question blockprimes blockprimes distance-metric number-theory follow-up",
    "type": "text/x-markdown",
    "created": "20250802082912823",
    "modified": "20250802082912823",
    "summary": "Block primes represent a novel approach to computational distance measurement in mathematical spaces. By encoding prime factorizations as spatial coordinates, we can transform number theory problems into geometric optimization challenges. The fundamental insight is that every composite number n can be represented as a point in prime-factorization space, where coordinates correspond to prime powers: n = p\u2081^a\u2081 \u00d7 p\u2082^a\u2082 \u00d7 ... \u00d7 p\u2096^a\u2096. **Proof Pattern**: Given any composite number n, its unique prime factorization provides coordinates (a\u2081, a\u2082, ..., a\u2096) in \u2124\u1d4f space. What computational patterns emerge when we measure distances between these points?",
    "key_concepts": "factorization, distance, prime, Proof Pattern, Proof",
    "question_count": 1,
    "has_proof": true,
    "has_demo": false,
    "complexity_level": "intermediate"
  },
  {
    "title": "blockprimes: Distance Metrics in Prime Space",
    "text": "!! Summary\n\n\n!! Key Concepts\nDistance, Prime\n\n!! Content\n## Distance Metrics in Prime Space\n\n\n!! Tags\nblockprimes blockprimes number-theory",
    "tags": "blockprimes blockprimes number-theory",
    "type": "text/x-markdown",
    "created": "20250802082912823",
    "modified": "20250802082912823",
    "summary": "",
    "key_concepts": "Distance, Prime",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "basic"
  },
  {
    "title": "blockprimes: Euclidean Distance",
    "text": "!! Summary\nFor numbers m = \u220fp\u1d62^a\u1d62 and n = \u220fp\u1d62^b\u1d62, the Euclidean distance is: d_E(m,n) = \u221a(\u2211(a\u1d62 - b\u1d62)\u00b2) **Demo**: Let m = 12 = 2\u00b2 \u00d7 3\u00b9 and n = 18 = 2\u00b9 \u00d7 3\u00b2. Then: - Coordinates: m \u2192 (2,1), n \u2192 (1,2)   - Distance: d_E(12,18) = \u221a((2-1)\u00b2 + (1-2)\u00b2) = \u221a2 This metric preserves multiplicative structure while enabling geometric reasoning. Can we use this distance to predict computational complexity of factorization algorithms?\n\n!! Key Concepts\nmetric, factorization, d_E, complexity, distance, Distance, Demo\n\n!! Content\n### Euclidean Distance\nFor numbers m = \u220fp\u1d62^a\u1d62 and n = \u220fp\u1d62^b\u1d62, the Euclidean distance is:\nd_E(m,n) = \u221a(\u2211(a\u1d62 - b\u1d62)\u00b2)\n\n**Demo**: Let m = 12 = 2\u00b2 \u00d7 3\u00b9 and n = 18 = 2\u00b9 \u00d7 3\u00b2. Then:\n- Coordinates: m \u2192 (2,1), n \u2192 (1,2)  \n- Distance: d_E(12,18) = \u221a((2-1)\u00b2 + (1-2)\u00b2) = \u221a2\n\nThis metric preserves multiplicative structure while enabling geometric reasoning.\n\nCan we use this distance to predict computational complexity of factorization algorithms?\n\n\n!! Tags\ndemo question blockprimes blockprimes demo distance-metric number-theory follow-up complexity",
    "tags": "demo question blockprimes blockprimes demo distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "For numbers m = \u220fp\u1d62^a\u1d62 and n = \u220fp\u1d62^b\u1d62, the Euclidean distance is: d_E(m,n) = \u221a(\u2211(a\u1d62 - b\u1d62)\u00b2) **Demo**: Let m = 12 = 2\u00b2 \u00d7 3\u00b9 and n = 18 = 2\u00b9 \u00d7 3\u00b2. Then: - Coordinates: m \u2192 (2,1), n \u2192 (1,2)   - Distance: d_E(12,18) = \u221a((2-1)\u00b2 + (1-2)\u00b2) = \u221a2 This metric preserves multiplicative structure while enabling geometric reasoning. Can we use this distance to predict computational complexity of factorization algorithms?",
    "key_concepts": "metric, factorization, d_E, complexity, distance, Distance, Demo",
    "question_count": 1,
    "has_proof": false,
    "has_demo": true,
    "complexity_level": "basic"
  },
  {
    "title": "blockprimes: Manhattan Distance",
    "text": "!! Summary\nThe L\u00b9 distance captures additive complexity: d_M(m,n) = \u2211|a\u1d62 - b\u1d62| **Example**: For the same m=12, n=18: d_M(12,18) = |2-1| + |1-2| = 2 **Theorem**: Manhattan distance in prime space equals the minimum number of prime factor modifications to transform m into n. **Proof**: Each unit of Manhattan distance corresponds to incrementing or decrementing a single prime power by 1. How does this relate to edit distance in computational strings?\n\n!! Key Concepts\ncomplexity, distance, prime, Example, d_M, Distance, Theorem, Proof\n\n!! Content\n### Manhattan Distance\nThe L\u00b9 distance captures additive complexity:\nd_M(m,n) = \u2211|a\u1d62 - b\u1d62|\n\n**Example**: For the same m=12, n=18:\nd_M(12,18) = |2-1| + |1-2| = 2\n\n**Theorem**: Manhattan distance in prime space equals the minimum number of prime factor modifications to transform m into n.\n\n**Proof**: Each unit of Manhattan distance corresponds to incrementing or decrementing a single prime power by 1.\n\nHow does this relate to edit distance in computational strings?\n\n\n!! Tags\nproof demo question blockprimes blockprimes proof demo distance-metric number-theory follow-up complexity",
    "tags": "proof demo question blockprimes blockprimes proof demo distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "The L\u00b9 distance captures additive complexity: d_M(m,n) = \u2211|a\u1d62 - b\u1d62| **Example**: For the same m=12, n=18: d_M(12,18) = |2-1| + |1-2| = 2 **Theorem**: Manhattan distance in prime space equals the minimum number of prime factor modifications to transform m into n. **Proof**: Each unit of Manhattan distance corresponds to incrementing or decrementing a single prime power by 1. How does this relate to edit distance in computational strings?",
    "key_concepts": "complexity, distance, prime, Example, d_M, Distance, Theorem, Proof",
    "question_count": 1,
    "has_proof": true,
    "has_demo": true,
    "complexity_level": "intermediate"
  },
  {
    "title": "blockprimes: Computational Shortcuts via Distance",
    "text": "!! Summary\n\n\n!! Key Concepts\nDistance\n\n!! Content\n## Computational Shortcuts via Distance\n\n\n!! Tags\nblockprimes blockprimes",
    "tags": "blockprimes blockprimes",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "",
    "key_concepts": "Distance",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "basic"
  },
  {
    "title": "blockprimes: Pattern Recognition",
    "text": "!! Summary\nNumbers with small mutual distances often share computational properties: **Demo**: Consider the sequence 8, 12, 18, 24: - 8 = 2\u00b3 \u2192 (3,0) - 12 = 2\u00b2 \u00d7 3\u00b9 \u2192 (2,1)   - 18 = 2\u00b9 \u00d7 3\u00b2 \u2192 (1,2) - 24 = 2\u00b3 \u00d7 3\u00b9 \u2192 (3,1) The Manhattan distances form a pattern: d_M(8,12)=2, d_M(12,18)=2, d_M(18,24)=3. This suggests optimization strategies for batch factorization.\n\n!! Key Concepts\nfactorization, Demo, d_M\n\n!! Content\n### Pattern Recognition\nNumbers with small mutual distances often share computational properties:\n\n**Demo**: Consider the sequence 8, 12, 18, 24:\n- 8 = 2\u00b3 \u2192 (3,0)\n- 12 = 2\u00b2 \u00d7 3\u00b9 \u2192 (2,1)  \n- 18 = 2\u00b9 \u00d7 3\u00b2 \u2192 (1,2)\n- 24 = 2\u00b3 \u00d7 3\u00b9 \u2192 (3,1)\n\nThe Manhattan distances form a pattern: d_M(8,12)=2, d_M(12,18)=2, d_M(18,24)=3.\n\nThis suggests optimization strategies for batch factorization.\n\n\n!! Tags\ndemo blockprimes blockprimes demo distance-metric number-theory",
    "tags": "demo blockprimes blockprimes demo distance-metric number-theory",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "Numbers with small mutual distances often share computational properties: **Demo**: Consider the sequence 8, 12, 18, 24: - 8 = 2\u00b3 \u2192 (3,0) - 12 = 2\u00b2 \u00d7 3\u00b9 \u2192 (2,1)   - 18 = 2\u00b9 \u00d7 3\u00b2 \u2192 (1,2) - 24 = 2\u00b3 \u00d7 3\u00b9 \u2192 (3,1) The Manhattan distances form a pattern: d_M(8,12)=2, d_M(12,18)=2, d_M(18,24)=3. This suggests optimization strategies for batch factorization.",
    "key_concepts": "factorization, Demo, d_M",
    "question_count": 0,
    "has_proof": false,
    "has_demo": true,
    "complexity_level": "basic"
  },
  {
    "title": "blockprimes: Compression Through Distance",
    "text": "!! Summary\nInstead of storing full factorizations, we can encode: 1. A reference point (anchor factorization) 2. Distance vectors to nearby numbers **Algorithm**:  ``` function encode_block(numbers):     anchor = geometric_median(numbers)     return [anchor, [distance_vector(n, anchor) for n in numbers]] ``` What is the compression ratio compared to naive storage?\n\n!! Key Concepts\nfactorization, Distance, Algorithm\n\n!! Content\n### Compression Through Distance\nInstead of storing full factorizations, we can encode:\n1. A reference point (anchor factorization)\n2. Distance vectors to nearby numbers\n\n**Algorithm**: \n```\nfunction encode_block(numbers):\n    anchor = geometric_median(numbers)\n    return [anchor, [distance_vector(n, anchor) for n in numbers]]\n```\n\nWhat is the compression ratio compared to naive storage?\n\n\n!! Tags\nquestion code blockprimes blockprimes algorithm distance-metric number-theory follow-up complexity",
    "tags": "question code blockprimes blockprimes algorithm distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "Instead of storing full factorizations, we can encode: 1. A reference point (anchor factorization) 2. Distance vectors to nearby numbers **Algorithm**:  ``` function encode_block(numbers):     anchor = geometric_median(numbers)     return [anchor, [distance_vector(n, anchor) for n in numbers]] ``` What is the compression ratio compared to naive storage?",
    "key_concepts": "factorization, Distance, Algorithm",
    "question_count": 1,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "intermediate"
  },
  {
    "title": "blockprimes: Applications to Cryptography",
    "text": "!! Summary\n\n\n!! Key Concepts\n\n\n!! Content\n## Applications to Cryptography\n\n\n!! Tags\nblockprimes blockprimes security",
    "tags": "blockprimes blockprimes security",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "",
    "key_concepts": "",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "advanced"
  },
  {
    "title": "blockprimes: RSA Key Distance Analysis",
    "text": "!! Summary\nFor RSA moduli N\u2081 = p\u2081q\u2081 and N\u2082 = p\u2082q\u2082, the distance d(N\u2081,N\u2082) reveals structural similarity. **Security Implication**: If d(N\u2081,N\u2082) < threshold, the keys may share vulnerabilities. **Proof Sketch**: Close distances imply similar prime structures, potentially enabling cross-key attacks through shared factorization shortcuts. **Example**: If N\u2081 = 77 = 7\u00d711 and N\u2082 = 91 = 7\u00d713, they share the prime 7, leading to gcd(N\u2081,N\u2082) = 7. Could we develop distance-based RSA key validation?\n\n!! Key Concepts\nfactorization, Security Implication, distance, prime, Example, Distance, Proof, Proof Sketch\n\n!! Content\n### RSA Key Distance Analysis\nFor RSA moduli N\u2081 = p\u2081q\u2081 and N\u2082 = p\u2082q\u2082, the distance d(N\u2081,N\u2082) reveals structural similarity.\n\n**Security Implication**: If d(N\u2081,N\u2082) < threshold, the keys may share vulnerabilities.\n\n**Proof Sketch**: Close distances imply similar prime structures, potentially enabling cross-key attacks through shared factorization shortcuts.\n\n**Example**: If N\u2081 = 77 = 7\u00d711 and N\u2082 = 91 = 7\u00d713, they share the prime 7, leading to gcd(N\u2081,N\u2082) = 7.\n\nCould we develop distance-based RSA key validation?\n\n\n!! Tags\nproof demo question blockprimes blockprimes demo security distance-metric number-theory follow-up",
    "tags": "proof demo question blockprimes blockprimes demo security distance-metric number-theory follow-up",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "For RSA moduli N\u2081 = p\u2081q\u2081 and N\u2082 = p\u2082q\u2082, the distance d(N\u2081,N\u2082) reveals structural similarity. **Security Implication**: If d(N\u2081,N\u2082) < threshold, the keys may share vulnerabilities. **Proof Sketch**: Close distances imply similar prime structures, potentially enabling cross-key attacks through shared factorization shortcuts. **Example**: If N\u2081 = 77 = 7\u00d711 and N\u2082 = 91 = 7\u00d713, they share the prime 7, leading to gcd(N\u2081,N\u2082) = 7. Could we develop distance-based RSA key validation?",
    "key_concepts": "factorization, Security Implication, distance, prime, Example, Distance, Proof, Proof Sketch",
    "question_count": 1,
    "has_proof": true,
    "has_demo": true,
    "complexity_level": "basic"
  },
  {
    "title": "blockprimes: Fermat Number Connections",
    "text": "!! Summary\n\n\n!! Key Concepts\n\n\n!! Content\n## Fermat Number Connections\n\n\n!! Tags\nblockprimes blockprimes number-theory",
    "tags": "blockprimes blockprimes number-theory",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "",
    "key_concepts": "",
    "question_count": 0,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "basic"
  },
  {
    "title": "blockprimes: Distance to Fermat Numbers",
    "text": "!! Summary\nFermat numbers F\u2099 = 2^(2\u207f) + 1 serve as reference points in prime space. **Observation**: Numbers near Fermat numbers in distance metric often exhibit special properties. **Demo**: F\u2080 = 3, F\u2081 = 5, F\u2082 = 17, F\u2083 = 257 Distance analysis reveals clustering around powers of 2. **Open Question**: Does proximity to Fermat numbers predict primality testing efficiency?\n\n!! Key Concepts\nmetric, Observation, Open Question, distance, prime, Distance, Demo\n\n!! Content\n### Distance to Fermat Numbers\nFermat numbers F\u2099 = 2^(2\u207f) + 1 serve as reference points in prime space.\n\n**Observation**: Numbers near Fermat numbers in distance metric often exhibit special properties.\n\n**Demo**: F\u2080 = 3, F\u2081 = 5, F\u2082 = 17, F\u2083 = 257\nDistance analysis reveals clustering around powers of 2.\n\n**Open Question**: Does proximity to Fermat numbers predict primality testing efficiency?\n\n\n!! Tags\ndemo question blockprimes blockprimes demo distance-metric number-theory follow-up",
    "tags": "demo question blockprimes blockprimes demo distance-metric number-theory follow-up",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "Fermat numbers F\u2099 = 2^(2\u207f) + 1 serve as reference points in prime space. **Observation**: Numbers near Fermat numbers in distance metric often exhibit special properties. **Demo**: F\u2080 = 3, F\u2081 = 5, F\u2082 = 17, F\u2083 = 257 Distance analysis reveals clustering around powers of 2. **Open Question**: Does proximity to Fermat numbers predict primality testing efficiency?",
    "key_concepts": "metric, Observation, Open Question, distance, prime, Distance, Demo",
    "question_count": 1,
    "has_proof": false,
    "has_demo": true,
    "complexity_level": "basic"
  },
  {
    "title": "blockprimes: Computational Implications",
    "text": "!! Summary\nThe distance metric enables: 1. Predictive complexity analysis 2. Optimized factorization routes   3. Compression of mathematical objects 4. Pattern discovery in number sequences **Research Direction**: Can we extend this framework to algebraic integers and other mathematical structures?\n\n!! Key Concepts\nmetric, factorization, complexity, distance, Research Direction\n\n!! Content\n### Computational Implications\nThe distance metric enables:\n1. Predictive complexity analysis\n2. Optimized factorization routes  \n3. Compression of mathematical objects\n4. Pattern discovery in number sequences\n\n**Research Direction**: Can we extend this framework to algebraic integers and other mathematical structures?\n\n\n!! Tags\nquestion blockprimes blockprimes distance-metric number-theory follow-up complexity",
    "tags": "question blockprimes blockprimes distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "The distance metric enables: 1. Predictive complexity analysis 2. Optimized factorization routes   3. Compression of mathematical objects 4. Pattern discovery in number sequences **Research Direction**: Can we extend this framework to algebraic integers and other mathematical structures?",
    "key_concepts": "metric, factorization, complexity, distance, Research Direction",
    "question_count": 1,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "advanced"
  },
  {
    "title": "blockprimes: Conclusion",
    "text": "!! Summary\nBlock prime distance metrics transform discrete number theory into continuous geometric optimization. This enables new computational shortcuts and reveals hidden patterns in mathematical structures. **Future Work**: Investigate distance-preserving transformations and their impact on algorithmic complexity. How might quantum computing change these distance relationships?\n\n!! Key Concepts\ndistance, Future Work, prime, complexity\n\n!! Content\n## Conclusion\n\nBlock prime distance metrics transform discrete number theory into continuous geometric optimization. This enables new computational shortcuts and reveals hidden patterns in mathematical structures.\n\n**Future Work**: Investigate distance-preserving transformations and their impact on algorithmic complexity.\n\nHow might quantum computing change these distance relationships?\n\n!! Tags\nquestion blockprimes blockprimes distance-metric number-theory follow-up complexity",
    "tags": "question blockprimes blockprimes distance-metric number-theory follow-up complexity",
    "type": "text/x-markdown",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "summary": "Block prime distance metrics transform discrete number theory into continuous geometric optimization. This enables new computational shortcuts and reveals hidden patterns in mathematical structures. **Future Work**: Investigate distance-preserving transformations and their impact on algorithmic complexity. How might quantum computing change these distance relationships?",
    "key_concepts": "distance, Future Work, prime, complexity",
    "question_count": 1,
    "has_proof": false,
    "has_demo": false,
    "complexity_level": "intermediate"
  },
  {
    "title": "main.cpython-313.pyc",
    "text": "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XCpcKnxcKlwqVGhlb3JlbVwqXCp8XCpcKkxlbW1hXCpcKnxcKlwqQ29yb2xsYXJ5XCpcKnI0AAAAejFcKlwqRGVtb1wqXCp8XCpcKkV4YW1wbGVcKlwqfFwqXCpJbGx1c3RyYXRpb25cKlwqcjUAAAB6J1wqXCpBbGdvcml0aG1cKlwqfFwqXCpQcm9jZWR1cmVcKlwqfGBgYNoJYWxnb3JpdGhtejVcKlwqU2VjdXJpdHlcKlwqfFwqXCpJbXBsaWNhdGlvblwqXCp8UlNBfGNyeXB0b2dyYXBoedoIc2VjdXJpdHl6IGRpc3RhbmNlfG1ldHJpY3xkX1tFTV18Z2VvbWV0cmljeg9kaXN0YW5jZS1tZXRyaWN6GkZlcm1hdHxwcmltZXxmYWN0b3JpemF0aW9ueg1udW1iZXItdGhlb3J5KQh6CFdoYXQuKlw/egdIb3cuKlw/egdDYW4uKlw/eglDb3VsZC4qXD96CVdvdWxkLipcP3oVXCpcKk9wZW4gUXVlc3Rpb25cKlwqehpcKlwqUmVzZWFyY2ggRGlyZWN0aW9uXCpcKnoTXCpcKkZ1dHVyZSBXb3JrXCpcKnoJZm9sbG93LXVwehxPXCguKlwpfGNvbXBsZXhpdHl8YWxnb3JpdGht2gpjb21wbGV4aXR5egshISBTdW1tYXJ5CnoSCgohISBLZXkgQ29uY2VwdHMKeg0KCiEhIENvbnRlbnQKegoKCiEhIFRhZ3MKegJcPykG2gdzdW1tYXJ52gxrZXlfY29uY2VwdHPaDnF1ZXN0aW9uX2NvdW502gloYXNfcHJvb2baCGhhc19kZW1v2hBjb21wbGV4aXR5X2xldmVs+gI6IHJbAAAAqQVyDQAAAHIOAAAAcg8AAAByEAAAAHITAAAAKRJyOAAAANoFc3BsaXTaCWVudW1lcmF0ZXJrAAAA2gVtYXRjaNoFZ3JvdXDaBG5leHTaA2xlbtoEam9pbnI8AAAA2gZleHRlbmRyOQAAAHI6AAAAcjsAAADaFGV4dHJhY3Rfa2V5X2NvbmNlcHRz2gdmaW5kYWxs2hNlc3RpbWF0ZV9jb21wbGV4aXR5cgsAAAApFnIYAAAAcjAAAAByZQAAAHIsAAAA2ghzZWN0aW9uc3JtAAAA2gdzZWN0aW9u2gVsaW5lc9oKdGl0bGVfbGluZdoLdGl0bGVfbWF0Y2hyDQAAAHJuAAAA2g1jb250ZW50X2xpbmVz2g1wYXJhZ3JhcGhfZW5k2g1zdW1tYXJ5X2xpbmVzcnUAAAByDwAAANoRcXVlc3Rpb25fcGF0dGVybnNyUAAAANoSc3RydWN0dXJlZF9jb250ZW502ghtZXRhZGF0YXJiAAAAcxYAAAAgICAgICAgICAgICAgICAgICAgICAgchkAAAByXwAAANosVGlkZGx5V2lraUNvbXBpbGVyLnBhcnNlX2Jsb2NrcHJpbWVzX2NvbnRlbnSBAAAAcwcDAACAAOATFYgI9AYAFBaXOJI40BwtqHfTEzeICOQaI6BI1xotiUqIQdgTGpc9kT2XP5E/2RAY4BQbl02RTaAk0xQniEXeJSqYFZhxmhiwObAruFnAccBj0DBKiEr0BgAbHZ8omijQIzWwetMaQohL3iw3kEvXFCXRFCWgYdQUKLhaiEXwBgAvNLBBsEKpadMcSKppoGS/Ork6vzyfVKlpiE3QHEjcHCDxAAEiN7Q5uF3UM0vzAAEiN9w4O7hN0zhK8wMBHUwBiE3gHCmoLqg90Bw5iE3eMT6QY5dokWiYfdQWLcBCiEfwBgAUGNcTLNETLKhX0xM1iETYDBCPS4lLmBmgTdAYMtQMM/QGABASj3mKedAZWdBbYtcPY9EPY9gQFJcLkQuYR9QQJOQPEY95innQGU3Id9cPV9EPV9gQFJcLkQuYRtQQI+QPEY95innQGUPAV9cPTdEPTdgQFJcLkQuYS9QQKOQPEY95innQGVHQU1rUXF7XXGnRXGnXD2rRD2rYEBSXC5ELmErUECfkDxGPeYp50Bk8uGfXD0bRD0bYEBSXC5EL0Bwt1BAu5A8Rj3mKedAZNrgHxBLHHcEd1w9P0Q9P2BAUlwuRC5hP1BAs8gYDIQ7QDB3zCgAcLZAH3BMVlzmSOZhXoGfXEy7TEy7YFBiXS5FLoAvUFCzZFBnxBwAcLfQMABASj3mKedAZOLgnxDLHPcE91w9R0Q9R2BAUlwuRC5hM1BAp8AYBJgHYAQiACfAAAwoB8AYAAgbXARrRARqYN9MBI9AAJPAAAyUB8AYAAgmACfAAAwoB8AYAAgWHGIEYiCSDHtAAEPAVCiIU0Awe8BwAHCPYICTXIDnRIDm4J9MgQtwiJaRip2qiarAVuAfTJkDTIkHYHSSoBJlf2BwioGSZTtgkKNckPNEkPLhX0yRF8Q0HGA6ISPQSABce2BkimAugMqBloFfQFi3YFSfYFRnYFSbYFx/xCwYXDohH8BAADRWPT4lPmEfXDCTxbwIAGy7wcgIAEBiID/nyWwIAHUkBcwwAAADCHhhNLwbCOgZNLwZyDgAAAGMCAAAAAAAAAAAAAAAHAAAAAwAAAPOEAQAAlQAvAG4CWwAAAAAAAAAAAFICAAAAAAAAAAAAAAAAAAAAAAAAIgBTAVUBWwAAAAAAAAAAAFIEAAAAAAAAAAAAAAAAAAAAAAAANQMAAAAAAABuA1UCUgcAAAAAAAAAAAAAAAAAAAAAAABbCQAAAAAAAAAAWwsAAAAAAAAAAFUDNQEAAAAAAAA1AQAAAAAAADUBAAAAAAAAIABbAAAAAAAAAAAAUgIAAAAAAAAAAAAAAAAAAAAAAAAiAFMCVQE1AgAAAAAAAG4EVQJSBwAAAAAAAAAAAAAAAAAAAAAAAFUENQEAAAAAAAAgAFsAAAAAAAAAAABSAgAAAAAAAAAAAAAAAAAAAAAAACIAUwNVATUCAAAAAAAAbgVVAlIHAAAAAAAAAAAAAAAAAAAAAAAAVQU1AQAAAAAAACAAUwRSDQAAAAAAAAAAAAAAAAAAAAAAAFsJAAAAAAAAAABbCwAAAAAAAAAAVQI1AQAAAAAAADUBAAAAAAAAUwVTBgQANQEAAAAAAAAkACkHej1FeHRyYWN0IGtleSBtYXRoZW1hdGljYWwgYW5kIGNvbXB1dGF0aW9uYWwgY29uY2VwdHMgZnJvbSB0ZXh0elJcYih0aGVvcmVtfGxlbW1hfHByb29mfGFsZ29yaXRobXxkaXN0YW5jZXxtZXRyaWN8cHJpbWV8ZmFjdG9yaXphdGlvbnxjb21wbGV4aXR5KVxidSEAAABkX1tBLVpdfE9cKFteKV0rXCl8W+KJiOKJoeKItOKItV16EFwqXCooW14qXSspXCpcKjp6AiwgTukKAAAAKQdyOAAAAHKGAAAAcjsAAAByhAAAANoEbGlzdNoDc2V0coMAAAApBnIYAAAAcg4AAADaCGNvbmNlcHRz2gptYXRoX3Rlcm1z2gdzeW1ib2xz2gtkZWZpbml0aW9uc3MGAAAAICAgICAgchkAAAByhQAAANonVGlkZGx5V2lraUNvbXBpbGVyLmV4dHJhY3Rfa2V5X2NvbmNlcHRz4wAAAHOVAAAAgADgExWICPQGABYYl1qSWtAgddgfI6RSp12hXfMDARY0iArgCBCPD4kPnAScU6Aam1/TGC3UCC70BgATFZcqkirQHUHANNMSSIgH2AgQjw+JD5gH1Agg9AYAFxmXapJq0CE0sGTTFjuIC9gIEI8PiQ+YC9QIJOAPE495iXmcFJxjoCibbdMZLKhTqGLQGTHTDzLQCDJyHAAAAGMCAAAAAAAAAAAAAAAFAAAAAwAAAPMGAQAAXgaVAC8AUwFRAS8AUwJRAS8AUwNRAVMELgNuAlUBUgEAAAAAAAAAAAAAAAAAAAAAAAA1AAAAAAAAAG0GMABuA1UCUgMAAAAAAAAAAAAAAAAAAAAAAAA1AAAAAAAAABMASBwAAHUCAABwRVsFAAAAAAAAAABVBjQBUwUaAGoIVQUTADUAAAAAAAAANQEAAAAAAABYNCcAAABNHgAACwAgAFsHAAAAAAAAAABVA1IJAAAAAAAAAAAAAAAAAAAAAAAANQAAAAAAAAA1AQAAAAAAACgAAAAAAAAAYRMAAFsLAAAAAAAAAABYM1IMAAAAAAAAAAAAAAAAAAAAAAAAUwY5AiQAUwckACkIeixFc3RpbWF0ZSB0aGUgY29tcGxleGl0eSBsZXZlbCBvZiB0aGUgY29udGVudCkD2gdleGFtcGxlcjUAAADaBnNpbXBsZSkD2gd0aGVvcmVtcjQAAABycgAAACkE2ghyZXNlYXJjaHoNb3BlbiBxdWVzdGlvbtoMY3J5cHRvZ3JhcGh52gdxdWFudHVtKQPaBWJhc2lj2gxpbnRlcm1lZGlhdGXaCGFkdmFuY2VkYwEAAAAAAAAAAAAAAAMAAAAzAAAA8zYAAAA+ASMAIACVAFUAEwBIDgAAbxFUAjsAAABkAgAATQoAAFMAdgCVBSAATRAAAAsAIABnATcDZgEpAnI/AAAATnIlAAAAKQNybAAAANoEdGVybdoKdGV4dF9sb3dlcnMDAAAAICCAchkAAABybwAAANo5VGlkZGx5V2lraUNvbXBpbGVyLmVzdGltYXRlX2NvbXBsZXhpdHkuPGxvY2Fscz4uPGdlbmV4cHI+AgEAAHMYAAAA+OkAgADQH0qqZaBkuHrRN0mnAaEBqmX5cwgAAACDCRkBkAkZASkB2gNrZXlypAAAACkH2gVsb3dlcnJLAAAA2gNzdW3aA2FuedoGdmFsdWVz2gNtYXjaA2dldCkHchgAAAByDgAAANoKaW5kaWNhdG9yc9oGc2NvcmVz2gVsZXZlbNoFdGVybXNyqQAAAHMHAAAAICAgICAgQHIZAAAAcocAAADaJlRpZGRseVdpa2lDb21waWxlci5lc3RpbWF0ZV9jb21wbGV4aXR59gAAAHN0AAAA+IAA8gYAFjPaHD3aGFDxBwQWCogK8AwAFhqXWpFak1yICtgRE4gG4Bwm1xws0Rws1hwuiUyIRdwcH9QfSqll0x9K0xxKiEaLTfEDAB0v9AYALzKwJrctsS2zL9cuQtEuQoxzkDafepl60Q8q0AhPyAfQCE9yHAAAAGMCAAAAAAAAAAAAAAAKAAAAAwAAAPNAAgAAlQBbAQAAAAAAAAAAVQFTATUCAAAAAAAAAgBuAlUCUgMAAAAAAAAAAAAAAAAAAAAAAAA1AAAAAAAAAG4DUwJTAlMCNQIAAAAAAAAgAFsEAAAAAAAAAABSBgAAAAAAAAAAAAAAAAAAAAAAACIAVwM1AQAAAAAAAFIJAAAAAAAAAAAAAAAAAAAAAAAAUwM1AQAAAAAAAG4EWwoAAAAAAAAAAFIMAAAAAAAAAAAAAAAAAAAAAAAAIgBbDwAAAAAAAAAAVQE1AQAAAAAAADUBAAAAAAAAdQIAAHBWVQUoAAAAAAAAAGQCAABTBG4FUwVTBi8CbgdVBVIRAAAAAAAAAAAAAAAAAAAAAAAAUwc1AQAAAAAAACgAAAAAAAAAYRIAAFUHUhMAAAAAAAAAAAAAAAAAAAAAAABTCDUBAAAAAAAAIABPT1UFUhEAAAAAAAAAAAAAAAAAAAAAAABTCTUBAAAAAAAAKAAAAAAAAABhEgAAVQdSEwAAAAAAAAAAAAAAAAAAAAAAAFMKNQEAAAAAAAAgAE8nVQVSEQAAAAAAAAAAAAAAAAAAAAAAAFMLNQEAAAAAAAAoAAAAAAAAAGERAABVB1ITAAAAAAAAAAAAAAAAAAAAAAAAUww1AQAAAAAAACAAWxUAAAAAAAAAAFUBUhYAAAAAAAAAAAAAAAAAAAAAAABVBFUHVQVTDVMOVQUOAFMPMwMwAVMQOQVuCFUIJAAhACwAKAAAAAAAAABkAQAAZgIgAB8AIAAgAE73PQMfAGYBKRF6PFByb2Nlc3MgYmluYXJ5IGZpbGVzIChpbWFnZXMsIHZpZGVvcywgZXRjLikgYXMgZGF0YSB0aWRkbGVyc9oCcmJOclYAAAB6GGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbdoGYmluYXJ52gphdHRhY2htZW50egZpbWFnZS/aBWltYWdlegZ2aWRlby/aBXZpZGVvegZhdWRpby/aBWF1ZGlv2g5fY2Fub25pY2FsX3VyaXoFZGF0YTp6CDtiYXNlNjQscnwAAAApDNoEb3BlbtoEcmVhZNoGYmFzZTY02gliNjRlbmNvZGXaBmRlY29kZdoJbWltZXR5cGVz2gpndWVzc190eXBlciIAAADaCnN0YXJ0c3dpdGhyOgAAAHILAAAAcl0AAAApCXIYAAAAclQAAADaAWZyMAAAANoPZW5jb2RlZF9jb250ZW502gltaW1lX3R5cGXaAV9yDwAAAHJiAAAAcwkAAAAgICAgICAgICByGQAAANoTcHJvY2Vzc19iaW5hcnlfZmlsZdomVGlkZGx5V2lraUNvbXBpbGVyLnByb2Nlc3NfYmluYXJ5X2ZpbGUGAQAAc/cAAACAAOQNEZApmFTUDSKgYdgWF5dmkWaTaIhH9wMADiP0CAAbIdcaKtIaKqg30xoz1xo60Ro6uDfTGkOID/QGABgh1xcr0hcrrEOwCatO0xc7iQyICd4PGNgYMohJ4BAYmCzQDyeIBNgLFNcLH9ELH6AI1wsp0Qsp2AwQj0uJS5gH1Qwg2A0W1w0h0Q0hoCjXDSvRDSvYDBCPS4lLmAfVDCDYDRbXDSHRDSGgKNcNK9ENK9gMEI9LiUuYB9QMIOQSGdgSG5cukS7YESDYERXYERrYFCSoBahpqFu4CNAmQdATQvELBhMKiAfwEAAQF4gO9zcADiPVDSL6cwsAAACNEUQPA8QPCkQdB2MBAAAAAAAAAAAAAAAIAAAAAwAAAPNQAgAAlQBVAFIAAAAAAAAAAAAAAAAAAAAAAAAAUgMAAAAAAAAAAAAAAAAAAAAAAAA1AAAAAAAAACgAAAAAAAAAZBkAAFsFAAAAAAAAAABTAVUAUgAAAAAAAAAAAAAAAAAAAAAAAAAOAFMCMwM1AQAAAAAAAGUBVQBSAAAAAAAAAAAAAAAAAAAAAAAAAFIHAAAAAAAAAAAAAAAAAAAAAAAAUwM1AQAAAAAAABMASKYAAG4BVQFSCQAAAAAAAAAAAAAAAAAAAAAAADUAAAAAAAAAKAAAAAAAAABkAgAATRoAAB4AWwoAAAAAAAAAAFIMAAAAAAAAAAAAAAAAAAAAAAAAIgBbDwAAAAAAAAAAVQE1AQAAAAAAADUBAAAAAAAAdQIAAHAjVQFSEAAAAAAAAAAAAAAAAAAAAAAAAFMEOwAAAGEuAABVAFITAAAAAAAAAAAAAAAAAAAAAAAAVQE1AQAAAAAAAG4EVQBSFAAAAAAAAAAAAAAAAAAAAAAAAFIXAAAAAAAAAAAAAAAAAAAAAAAAVQQ1AQAAAAAAACAATXoAAFUAUhkAAAAAAAAAAAAAAAAAAAAAAABVATUBAAAAAAAAbgVVAFIUAAAAAAAAAAAAAAAAAAAAAAAAUhsAAAAAAAAAAAAAAAAAAAAAAABVBTUBAAAAAAAAIABNqAAACwAgAGcHIQBbHAAAAAAAAAAABwBhHAAAbgZbHwAAAAAAAAAAUwVVAQ4AUwZVBg4AMwQ1AQAAAAAAACAAHwBTB24GQQZNzAAAUwduBkEGZgFmAD0DHwBmASkIeilDb21waWxlIGFsbCBmaWxlcyBpbiB0aGUgc291cmNlIGRpcmVjdG9yeXoRU291cmNlIGRpcmVjdG9yeSB6CiBub3QgZm91bmTaASopBnoELnR4dHJZAAAAegMucHl6BS5qc29uegUueWFtbHoELnltbHoRRXJyb3IgcHJvY2Vzc2luZyByewAAAE4pEHIpAAAA2gZleGlzdHPaEUZpbGVOb3RGb3VuZEVycm9y2gVyZ2xvYtoHaXNfZmlsZXLEAAAAcsUAAAByIgAAAHJhAAAAcmMAAAByLAAAAHKEAAAAcssAAAByOgAAANoJRXhjZXB0aW9u2gVwcmludCkHchgAAAByVAAAAHLJAAAAcsoAAAByLAAAAHJiAAAA2gFlcwcAAAAgICAgICAgchkAAADaEWNvbXBpbGVfZGlyZWN0b3J52iRUaWRkbHlXaWtpQ29tcGlsZXIuY29tcGlsZV9kaXJlY3RvcnklAQAAc/UAAACAAOAPE49/iX/XDyXRDyXXDyfRDyfcEiPQJje4BL8PuQ/QN0jICtAkU9MSVNAMVOAZHZ8fmR/XGS7RGS6oc9YZM4hJ2A8Y1w8g0Q8g1w8i0w8i8AINEUAB5CMs1yM30iM3vAO4SbsO0yNHkUyQSeAXINcXJ9EXJ9ArW9MXW9gjJ9cjOdEjObgp0yNEmAjYGByfDZkN1xgs0RgsqFjWGDbwBgAjJ9ciOtEiOrg50yJFmAfYGByfDZkN1xgs0RgsqFfWGDXyGQAaNPj0HAAYIfMAARFAAdwUGdAcLahpqFu4ArgxuCPQGj7XFD/SFD/78AMBEUAB+nMfAAAAwS9BHUM/AsMOLEM/AsM/CkQlBcQJEUQgBcQgBUQlBWMBAAAAAAAAAAAAAAAIAAAAAwAAAPM8AgAAlQAvAG4BVQBSAAAAAAAAAAAAAAAAAAAAAAAAABMASJYAAG4CVQJSAgAAAAAAAAAAAAAAAAAAAAAAAFUCUgQAAAAAAAAAAAAAAAAAAAAAAABVAlIGAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAABhGwAAUwFSCQAAAAAAAAAAAAAAAAAAAAAAAFUCUgYAAAAAAAAAAAAAAAAAAAAAAAA1AQAAAAAAAE8BUwJVAlIKAAAAAAAAAAAAAAAAAAAAAAAAVQJSDAAAAAAAAAAAAAAAAAAAAAAAAFUCUg4AAAAAAAAAAAAAAAAAAAAAAABTAy4GbgNVA1IRAAAAAAAAAAAAAAAAAAAAAAAAVQJSEgAAAAAAAAAAAAAAAAAAAAAAADUBAAAAAAAAIABVAVIVAAAAAAAAAAAAAAAAAAAAAAAAVQM1AQAAAAAAACAATZgAAAsAIAAeAFMEUwVLC0oMbgQgAFUEIgBVAVMGVQBSGgAAAAAAAAAAAAAAAAAAAAAAAFIcAAAAAAAAAAAAAAAAAAAAAAAADgAzAjUCAAAAAAAAJAAhAFseAAAAAAAAAAAHAGFBAAAgAFMHWyAAAAAAAAAAAFIiAAAAAAAAAAAAAAAAAAAAAAAAIgBVAVMIUwk5Ag4AUwpbJQAAAAAAAAAAVQBSAAAAAAAAAAAAAAAAAAAAAAAAADUBAAAAAAAADgBTC1UAUhoAAAAAAAAAAAAAAAAAAAAAAAAOAFMMMwduBVUFcwIfACQAZgA9Ax8AZgEpDXonR2VuZXJhdGUgdGhlIGZpbmFsIFRpZGRseVdpa2kgSFRNTCBmaWxlcnEAAAByagAAACkGcg0AAAByDgAAAHIPAAAAchAAAAByEQAAAHISAAAAcj8AAAApAdoYZ2VuZXJhdGVfdGlkZGx5d2lraV9odG1sehBDb21waWxlZCBXaWtpIC0genw8IURPQ1RZUEUgaHRtbD4KPGh0bWw+CjxoZWFkPgo8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+Cjx0aXRsZT5Db21waWxlZCBXaWtpPC90aXRsZT4KPHNjcmlwdD4KdmFyICR0dyA9IHsKICAgIHByZWxvYWRUaWRkbGVyczog6QIAAAApAdoGaW5kZW50emAKfTsKPC9zY3JpcHQ+CjwvaGVhZD4KPGJvZHk+CjxkaXYgaWQ9InRpZGRseXdpa2kiPgo8aDE+Q29tcGlsZWQgV2lraTwvaDE+CjxwPlRoaXMgd2lraSBjb250YWlucyB6GCB0aWRkbGVycyBjb21waWxlZCBmcm9tIHobPC9wPgo8L2Rpdj4KPC9ib2R5Pgo8L2h0bWw+KRNyLAAAAHINAAAAcg4AAAByDwAAAHKDAAAAchAAAAByEQAAAHISAAAA2gZ1cGRhdGVyEwAAAHI6AAAA2g13aWtpX3RlbXBsYXRlctkAAAByKQAAAHJdAAAAckoAAADaBGpzb27aBWR1bXBzcoIAAAApBnIYAAAA2g10aWRkbGVyc19kYXRhcmIAAADaDHRpZGRsZXJfZGljdHLZAAAA2g1odG1sX3RlbXBsYXRlcwYAAAAgICAgICByGQAAANoSZ2VuZXJhdGVfd2lraV9odG1s2iVUaWRkbHlXaWtpQ29tcGlsZXIuZ2VuZXJhdGVfd2lraV9odG1sOwEAAHMDAQAAgADwBgAZG4gN2Bcbl32UfYhH4Bkgnx2ZHdgYH58MmQzYMjm3LLcsmAOfCJkIoBenHKEc1BguwELYGB+fDJkM2Bsinz+ZP9gcI9ccLNEcLPENBxwOiEzwEAANGdcMH9EMH6AHpw6hDtQML9gMGdcMINEMIKAc1gwu8RUAGCXwGhgJId0MP9kTK6hN0D1NyGTPb8lv105i0U5i0E1j0Dtk0xNl0Axl+NwPGvMAFQkh8AQHIRb0DgAXG5dqkmqgHbBx0RY50BU68AAHOxf0DgAYG5g0nz2ZPdMXKdAWKtAqQsA0xz/BP9BCU/AAA1QBCPAdER0LiE3wJgAUIdIMIPArFQkh+nMTAAAAwiolQxAAwxBBCEQbA8QaAUQbA2MBAAAAAAAAAAAAAAAIAAAAAwAAAPNSAQAAlQBbAQAAAAAAAAAAUwFVAFICAAAAAAAAAAAAAAAAAAAAAAAADgAzAjUBAAAAAAAAIABVAFIFAAAAAAAAAAAAAAAAAAAAAAAANQAAAAAAAAAgAFUAUgcAAAAAAAAAAAAAAAAAAAAAAAA1AAAAAAAAAG4BWwkAAAAAAAAAAFUAUgoAAAAAAAAAAAAAAAAAAAAAAABTAlMDUwQ5AwIAbgJVAlINAAAAAAAAAAAAAAAAAAAAAAAAVQE1AQAAAAAAACAAUwVTBVMFNQIAAAAAAAAgAFsBAAAAAAAAAABTBlUAUgoAAAAAAAAAAAAAAAAAAAAAAAAOAFMHWw8AAAAAAAAAAFUAUhAAAAAAAAAAAAAAAAAAAAAAAAA1AQAAAAAAAA4AUwgzBTUBAAAAAAAAIABnBSEALAAoAAAAAAAAAGQBAABmAiAAHwAgACAATj49Ax8AZgEpCXoXTWFpbiBjb21waWxhdGlvbiBtZXRob2R6FUNvbXBpbGluZyBkaXJlY3Rvcnk6INoBd3JWAAAAclcAAABOehFXaWtpIGNvbXBpbGVkIHRvIHoGIHdpdGggegkgdGlkZGxlcnMpCXLUAAAAcikAAABy1gAAAHLjAAAAcr8AAAByKgAAANoFd3JpdGVyggAAAHIsAAAAKQNyGAAAANoMaHRtbF9jb250ZW50cscAAABzAwAAACAgIHIZAAAA2gdjb21waWxl2hpUaWRkbHlXaWtpQ29tcGlsZXIuY29tcGlsZWYBAABzigAAAIAA5AgN0BAloGSnb6Fv0CU20A431Ag42AgM1wge0Qge1Agg4Bcb1xcu0Rcu0xcwiAzkDRGQJNcSItESIqBDsCfSDTq4YdgMDY9HiUeQTNQMIfcDAA479AYACQ7QECGgJNciMtEiMtAhM7A2vCO4ZL9tuW3TOkzQOU3IWdAOV9UIWPcHAA471Q06+nMMAAAAwQ4SQhgDwhgKQiYHKQRyLQAAAHIqAAAAcikAAAByLAAAAE4pAfoJd2lraS5odG1sKRVyHQAAAHIeAAAAch8AAAByIAAAAHIhAAAAciIAAAByLgAAAHIFAAAAcjwAAAByUgAAAHIDAAAAcgsAAAByYwAAAHJfAAAAcoUAAAByhwAAAHLLAAAActYAAABy4wAAAHLpAAAAciQAAAByJQAAAHIcAAAAchkAAAByJwAAAHInAAAALgAAAHPRAAAAhgDZBDvxBAQFKKAz8AAEBSiwU/UABAUo8AwYBRSoQ/AAGAUUsES4E7FJ9AAYBRTwNBQFHqgD8AAUBR6wA/QAFAUe8CwYBRmoNPAAGAUZsES4F7FN9AAYBRnwNGABBRiwE/AAYAEFGMAT8ABgAQUYyBTIZ8kd9ABgAQUY8EQDEQUzqBPwABEFM7AT9AARBTPwJg4FUAGoA/AADgVQAbAD9AAOBVAB8CAdBReoVPAAHQUXsGf0AB0FF/I+FAVAAfAsKQUhoEP0ACkFIfVWAQoFWQFyHAAAAHInAAAA2ghfX21haW5fX3odQ29tcGlsZSBmaWxlcyBpbnRvIFRpZGRseVdpa2kpAdoLZGVzY3JpcHRpb25yKQAAAHobU291cmNlIGRpcmVjdG9yeSB0byBjb21waWxlKQHaBGhlbHB6Ai1veggtLW91dHB1dHLrAAAAehBPdXRwdXQgd2lraSBmaWxlKQLaB2RlZmF1bHRy7gAAAHoQLS1uby1jb21wcmVzc2lvbtoKc3RvcmVfdHJ1ZXoTRGlzYWJsZSBjb21wcmVzc2lvbikC2gZhY3Rpb25y7gAAAEYpIHIhAAAA2gJvc3LeAAAAcsEAAAByxAAAANoHaGFzaGxpYtoHcGF0aGxpYnIDAAAA2gZ0eXBpbmdyBAAAAHIFAAAAcgYAAAByBwAAANoLZGF0YWNsYXNzZXNyCAAAAHI4AAAAcgkAAAByCwAAAHInAAAAch0AAADaCGFyZ3BhcnNl2g5Bcmd1bWVudFBhcnNlctoGcGFyc2Vy2gxhZGRfYXJndW1lbnTaCnBhcnNlX2FyZ3PaBGFyZ3NyKQAAANoGb3V0cHV02ghjb21waWxlctoObm9fY29tcHJlc3Npb25yLQAAAHLpAAAAciUAAAByHAAAAHIZAAAA2gg8bW9kdWxlPnIAAQAAAQAAAHP6AAAA8AMBAQHxBAgBBPMUAAEK2wAL2wAN2wAQ2wAO3QAY3wAs0wAs3QAh2wAJ3QAd8AYAAgv3AhIBKfAAEgEp8wMAAgvwAhIBKfcqQgUBWQHxAEIFAVkB8EoKAAQMiHrTAxnbBBPgDRXXDSTSDSTQMVDRDVGARtgECtcEF9EEF5gM0CtI0AQX0QRJ2AQK1wQX0QQXmASYarAr0ERW0AQX0QRX2AQK1wQX0QQX0BgqsDzQRlvQBBfRBFzgCxHXCxzRCxzTCx6AROEPIaAkpy+hL7A0tzuxO9MPP4BI2AcL1wca1wca2CcsiAjUCCTgBAzXBBTRBBTVBBbwHQAEGnIcAAAA",
    "tags": "binary attachment",
    "type": "application/x-python-code",
    "created": "20250802082912824",
    "modified": "20250802082912824",
    "_canonical_uri": "data:application/x-python-code;base64,"
  },
  {
    "title": "theorem1",
    "text": "# Fundamental Theorem of Arithmetic\n\n**Theorem**: Every integer greater than 1 is either prime or can be uniquely factored into prime numbers.\n\n**Proof**: \n1. Existence: Assume some integer n > 1 cannot be factored. \n2. Let S be the set of all such integers.\n3. By well-ordering, S has a minimum element m.\n4. Since m cannot be factored, m must be prime.\n5. This contradicts our assumption.\n\nTherefore, every integer can be factored into primes.\n\n**Demo**: 12 = 2\u00b2 \u00d7 3, 15 = 3 \u00d7 5, 30 = 2 \u00d7 3 \u00d7 5\n\nThis theorem is fundamental to number theory and cryptography.\n\nHow does this relate to the distance metrics in prime space?\n",
    "tags": "proof demo question text md compressed",
    "type": "text/x-markdown",
    "created": "20250802082912825",
    "modified": "20250802082912825"
  }
]
};
</script>
</head>
<body>
<div id="tiddlywiki">
<h1>Compiled Wiki</h1>
<p>This wiki contains 43 tiddlers compiled from .</p>
</div>
</body>
</html>